================================================================================
BUNDLE.TXT - Sistema Jur√≠dico Inteligente - C√≥digo Fonte Completo
Gerado em: 2025-12-03 15:30:53
================================================================================

√çNDICE DE ARQUIVOS:
----------------------------------------
  1. replit.md (7,858 bytes)
  2. app.py (7,795 bytes)
  3. main.py (450 bytes)
  4. models.py (19,153 bytes)
  5. forms.py (8,793 bytes)
  6. extensions.py (183 bytes)
  7. routes.py (52,329 bytes)
  8. routes_batch.py (70,986 bytes)
  9. rpa.py (394,386 bytes)
 10. rpa_status.py (8,895 bytes)
 11. monitor_integration.py (5,862 bytes)
 12. gunicorn.conf.py (986 bytes)
 13. extractors/__init__.py (1,693 bytes)
 14. extractors/pipeline.py (31,220 bytes)
 15. extractors/llm_extractor.py (35,764 bytes)
 16. extractors/regex_utils.py (141,930 bytes)
 17. extractors/ocr_utils.py (40,247 bytes)
 18. extractors/header_parser.py (13,943 bytes)
 19. extractors/section_detector.py (9,373 bytes)
 20. extractors/document_classifier.py (8,059 bytes)
 21. extractors/posicao_mapping.py (11,777 bytes)
 22. extractors/client_priority.py (8,012 bytes)
 23. extractors/brand_map.py (6,305 bytes)
 24. extractors/audiencia.py (9,293 bytes)
 25. extractors/cadastro.py (647 bytes)
 26. extractors/decisao.py (2,475 bytes)
 27. extractors/dictionary.py (3,139 bytes)
 28. extractors/postprocess.py (8,479 bytes)
 29. extractors/reextract.py (13,310 bytes)
 30. utils/normalization.py (353 bytes)
 31. utils/cell_inference.py (4,153 bytes)
 32. utils/gap_filler.py (4,229 bytes)
 33. utils/jur_extraction.py (4,890 bytes)
 34. utils/option_catalog.py (786 bytes)
 35. data/clientes_database.json (28,649 bytes)
 36. data/actors.json (0 bytes)
 37. data/elaw_tipos_pedidos.json (55,918 bytes)
 38. data/trt_map.json (5,702 bytes)
 39. config/brand_map.json (682 bytes)
 40. config/client_aliases.json (1,010 bytes)
 41. config/client_cell_map.json (242 bytes)
 42. templates/base.html (25,074 bytes)
 43. templates/login.html (10,495 bytes)
 44. templates/dashboard.html (6,899 bytes)
 45. templates/error.html (3,499 bytes)
 46. templates/admin/users.html (2,868 bytes)
 47. templates/admin/create_user.html (3,591 bytes)
 48. templates/processes/list.html (14,468 bytes)
 49. templates/processes/view.html (63,079 bytes)
 50. templates/processes/create.html (11,494 bytes)
 51. templates/processes/edit.html (20,587 bytes)
 52. templates/processes/analysis.html (10,982 bytes)
 53. templates/processes/extract_from_pdf.html (9,692 bytes)
 54. templates/processes/confirm_extracted.html (19,311 bytes)
 55. templates/processes/reextract_ocr.html (10,129 bytes)
 56. templates/processes/batch_upload.html (11,126 bytes)
 57. templates/processes/batch_list.html (9,022 bytes)
 58. templates/processes/batch_detail.html (37,552 bytes)
 59. templates/processes/batch_progress.html (14,109 bytes)
 60. templates/processes/rpa_progress.html (23,930 bytes)
 61. requirements.txt (607 bytes)
 62. pyproject.toml (596 bytes)
----------------------------------------


================================================================================
FILE: replit.md
================================================================================
## Overview
This project is a Flask-based legal process management system designed to streamline the handling and tracking of legal cases. It provides user registration, robust authentication with role-based access control, and comprehensive metadata management for legal processes. A core feature is the automated classification and data extraction from PDF legal documents, supporting various Brazilian legal terminologies. The system prioritizes database values over PDF extraction for critical data. It also integrates an RPA automation module for interacting with external legal systems like eLaw, offering real-time progress tracking and verification through screenshots. The primary goal is to enhance efficiency in legal process management through automation and structured data handling, ultimately improving the legal process workflow.

## User Preferences
Preferred communication style: Simple, everyday language.
Deploy workflow: Sempre limpar arquivos pesados do Git (.venv/, attached_assets/, *.backup.db, bundle.txt) antes de preparar para republish, para garantir deploys r√°pidos (2-3 min ao inv√©s de 6-10 min).

## System Architecture

### UI/UX
The application uses server-side rendering with Jinja2 templates and Bootstrap for a responsive and consistent user interface. It employs template inheritance for a unified layout, and forms incorporate both client and server-side validation. The RPA progress screen features a modern UI with gradient backgrounds, animated progress bars, and real-time status updates.

### Technical Implementation & Feature Specifications
The system is built on the Flask web framework, utilizing SQLAlchemy for ORM and Flask-Login for user authentication and session management.

**Key Features:**

*   **Multi-Client Support:** Supports 24+ clients with fuzzy matching for name variations, prioritizing legal entities over individuals, and easily maintainable via a JSON database. Includes intelligent client prioritization and storage of secondary parties.
*   **Legal Nomenclature Support:** Recognizes and processes all 61 Brazilian legal terminologies from the eLaw system, adapting to document types to correctly identify parties without role inversion.
*   **Document Classification & Extraction:** Automatically classifies legal documents and extracts over 30 universal and document-specific fields. It intelligently adapts extraction to document type, prioritizes legal entities, includes multi-tier state detection, and extracts distribution dates and telepresential hearing links. Implements a 3-tier fallback system (Regex ‚Üí LLM ‚Üí OCR) for robust data extraction from various document types, including scanned PDFs. It includes data quality enhancements like auto-correction of inverted dates and enhanced entity extraction with blacklists and verb filters.
*   **Otimiza√ß√£o de Extra√ß√£o (2025-12-01):** Utilit√°rios compartilhados de normaliza√ß√£o (normalize_text, normalize_monetary, MESES_MAP, is_valid_brazilian_date, is_invalid_date_context) garantem consist√™ncia em todas as fun√ß√µes de extra√ß√£o. Regex otimizados para: sal√°rio (TRCT, contracheques, verbos de recebimento), datas (admiss√£o, demiss√£o, distribui√ß√£o, audi√™ncia), cargo/fun√ß√£o, PIS, CTPS. Valida√ß√£o de contexto para evitar falsos positivos.
*   **Pol√≠tica ZERO ERRORS (2025-12-01):** Fun√ß√µes de extra√ß√£o NUNCA fabricam dados. parse_date_extenso() rejeita datas s√≥ com m√™s/ano (n√£o assume dia=01). extract_data_hora_audiencia() s√≥ retorna hora com minutos expl√≠citos (n√£o fabrica :00). extract_data_distribuicao() removido fallback perigoso de "primeira data no cabe√ßalho".
*   **Extra√ß√£o por Zonas Ampliada (2025-12-01):** Pipeline agora extrai 35 p√°ginas iniciais (antes 15) para capturar se√ß√£o DOS PEDIDOS que normalmente fica entre p√°ginas 15-35 ap√≥s fundamenta√ß√£o jur√≠dica. √öltimas 15 p√°ginas mantidas para TRCT/dados trabalhistas.
*   **RPA Automation (eLaw Integration):** Headless RPA execution using Playwright for external system interaction, providing real-time, step-by-step progress tracking with field-by-field updates. It captures screenshots for verification, features robust status management, history logging, and graceful error handling. The system prioritizes database values over PDF extraction for critical fields and automatically registers first hearings. Supports parallel execution of RPA processes with isolated browser instances. Handles multiple defendants from PDF extraction to eLaw population.
*   **Data Isolation Fix (2025-12-02):** Corrigido bug de "data bleeding" onde dados de um processo vazavam para outro durante execu√ß√£o paralela do RPA. Solu√ß√£o: contextvars setados DENTRO da fun√ß√£o async (run_elaw_login_once) para garantir propaga√ß√£o correta quando asyncio.run() cria novo event loop. Debug logging expandido para campos trabalhistas cr√≠ticos (cargo, pis, ctps, sal√°rio, datas). Timeouts de produ√ß√£o aumentados para estabilidade.
*   **Otimiza√ß√µes Produ√ß√£o (2025-12-03):** Corre√ß√µes para estabilidade em ambiente Replit de produ√ß√£o:
    - MAX_RPA_WORKERS: 5 (dev) ‚Üí 3 (produ√ß√£o) via detec√ß√£o autom√°tica de REPL_DEPLOYMENT
    - Timeouts aumentados: NAV_TIMEOUT e BROWSER_LAUNCH de 120s ‚Üí 180s (3 minutos)
    - Browser launch com retry: 3 tentativas com backoff exponencial (5s, 10s) antes de falhar
    - Parsing de pedidos corrigido: Trata pedidos_json como string JSON e parseia corretamente
*   **Sistema Inteligente de Prioriza√ß√£o de Pedidos:** 5 categorias de prioridade (P5-P1) garantem que verbas rescis√≥rias essenciais (aviso pr√©vio, f√©rias, FGTS, 13¬∫) sejam sempre inseridas primeiro, seguidas de salariais b√°sicas, adicionais, indenizat√≥rios e acess√≥rios. Limite configur√°vel de 30 pedidos com log detalhado de omiss√µes.
*   **Parallel PDF Extraction:** Processes multiple PDFs concurrently using a ThreadPoolExecutor, ensuring isolated database sessions and robust error handling for each extraction task.
*   **LLM Fallback Otimizado (2025-12-02):** Novas fun√ß√µes LLM para extra√ß√£o avan√ßada:
    - `extract_pedidos_with_llm()`: Extrai pedidos com categoriza√ß√£o (verbas_rescisorias, salariais, indenizatorios, acessorios) quando regex falha.
    - `extract_reclamadas_with_llm()`: Identifica todas as empresas reclamadas quando regex n√£o encontra.
    - `validate_extracted_data_with_llm()`: Valida consist√™ncia de datas, valores e documentos (dispon√≠vel para uso manual).
    - `classify_document_with_llm()`: Classifica tipo de documento (peti√ß√£o inicial, senten√ßa, etc).
    Pipeline usa fallback apenas quando regex falha (0 resultados) para manter velocidade.

### System Design Choices

*   **Modular Application Structure:** Uses Flask's Blueprint pattern for scalability and maintainability.
*   **Database Design:** Uses SQLite for development and supports PostgreSQL for production, with a user model linked to a comprehensive process model in a one-to-many relationship, including cascade deletes and tracking of secondary interested parties.
*   **Authentication & Authorization:** Implements role-based access control, secure password hashing, and protected routes.
*   **File Management:** Supports secure PDF document uploads with size limits and configurable storage.
*   **Configuration:** Environment-based configuration with sensible defaults.

## External Dependencies

*   **Web Framework:** Flask
*   **Database ORM:** Flask-SQLAlchemy
*   **Authentication & Session Management:** Flask-Login, Werkzeug
*   **Forms:** Flask-WTF, WTForms
*   **Frontend Libraries:** Bootstrap, Font Awesome
*   **Databases:** SQLite, PostgreSQL
*   **RPA Browser Automation:** Playwright
*   **RPA Monitoring:** rpa-monitor-client
*   **External Legal Systems:** eLaw
*   **Document Processing:** python-docx, Tesseract OCR, pdf2image
*   **Fuzzy Matching:** rapidfuzz


================================================================================
FILE: app.py
================================================================================
# app.py
import os
import json
import logging
from datetime import datetime
from zoneinfo import ZoneInfo
from dotenv import load_dotenv

from flask import (
    Flask, flash, redirect, url_for, request, send_from_directory, make_response, current_app
)
from werkzeug.middleware.proxy_fix import ProxyFix
from flask_migrate import Migrate
from sqlalchemy.exc import OperationalError, IntegrityError, SQLAlchemyError

# √öNICA inst√¢ncia de db e login_manager do projeto
from models import db, User, ensure_admin_user
from extensions import login_manager

load_dotenv(override=True)
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

logger.info("="*80)
logger.info("SISTEMA JUR√çDICO - Gerenciamento de Processos Trabalhistas - Iniciando")
logger.info("="*80)

# Inicializar monitor remoto (se habilitado)
try:
    from monitor_integration import init_monitor
    monitor_conectado = init_monitor(rpa_id="RPA-FGbularmaci-5")
    if monitor_conectado:
        logger.info("‚úÖ Monitor remoto ATIVO")
    else:
        logger.warning("‚ö†Ô∏è Monitor remoto DESABILITADO ou n√£o configurado")
except Exception as e:
    logger.warning(f"Erro ao inicializar monitor: {e}")

# Timezone brasileiro (UTC-3)
BRAZIL_TZ = ZoneInfo("America/Sao_Paulo")


def create_app():
    app = Flask(__name__)
    app.secret_key = os.environ.get("SESSION_SECRET", "dev-secret-key-change-in-production")
    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

    # ==============================
    # Config Banco
    # ==============================
    BASEDIR = os.path.abspath(os.path.dirname(__file__))
    
    # Usar PostgreSQL se dispon√≠vel, sen√£o SQLite com caminho absoluto
    default_db = f"sqlite:///{os.path.join(BASEDIR, 'instance', 'processos.db')}"
    database_uri = os.environ.get("DATABASE_URL", default_db)
    app.config["SQLALCHEMY_DATABASE_URI"] = database_uri
    app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
    
    # Log para debug
    print(f"[CONFIG] Usando banco de dados: {database_uri[:50]}...")
    logging.info(f"Database URI configurado: {database_uri[:50]}...")
    app.config["CLIENTE_CELULA_DOCX"] = os.path.join(BASEDIR, "data", "CLIENTE_X_CELULA.docx")

    if os.environ.get("DATABASE_URL", "").startswith("postgresql"):
        app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
            "pool_recycle": 270,
            "pool_pre_ping": True,
            "pool_size": 2,
            "max_overflow": 1,
            "pool_timeout": 30,
            "connect_args": {
                "connect_timeout": 20,
                "keepalives": 1,
                "keepalives_idle": 30,
                "keepalives_interval": 10,
                "keepalives_count": 3,
                "options": "-c statement_timeout=120000",
                "application_name": "flask_legal_app",
            },
        }
    else:
        app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
            "pool_recycle": 300,
            "pool_pre_ping": True,
        }

    # Uploads
    app.config["UPLOAD_FOLDER"] = os.path.join(os.getcwd(), "uploads")
    app.config["MAX_CONTENT_LENGTH"] = 350 * 1024 * 1024  # 350MB (20 arquivos x 16MB + overhead)
    os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

    # Recarregar templates automaticamente em dev
    app.config.setdefault("TEMPLATES_AUTO_RELOAD", True)

    # ==============================
    # Inicializa extens√µes
    # ==============================
    os.makedirs(app.instance_path, exist_ok=True)

    db.init_app(app)
    Migrate(app, db, render_as_batch=True, compare_type=True, compare_server_default=True)

    login_manager.init_app(app)
    login_manager.login_view = "core.login"
    login_manager.login_message = "Por favor, fa√ßa login para acessar esta p√°gina."

    @login_manager.user_loader
    def load_user(user_id):
        try:
            return User.query.get(int(user_id))
        except Exception:
            # Em caso de sess√£o quebrada, limpe a sess√£o do SQLAlchemy
            try:
                db.session.remove()
            except Exception:
                pass
            return None

    # ==============================
    # Filtros Jinja
    # ==============================
    @app.template_filter("from_json")
    def from_json_filter(value):
        if not value:
            return []
        try:
            return json.loads(value) if isinstance(value, str) else value
        except (json.JSONDecodeError, TypeError):
            return []
    
    @app.template_filter("brazil_datetime")
    def brazil_datetime_filter(dt, format_str="%d/%m/%Y %H:%M:%S"):
        """Converte datetime UTC para hor√°rio de Bras√≠lia"""
        if dt is None:
            return ""
        try:
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=ZoneInfo("UTC"))
            dt_brazil = dt.astimezone(BRAZIL_TZ)
            return dt_brazil.strftime(format_str)
        except Exception:
            return str(dt)

    # ==============================
    # Blueprints / Rotas
    # ==============================
    # Importa DEPOIS de init_app para evitar import c√≠clico
    from routes import bp as core_bp
    from routes_batch import batch_bp
    
    app.register_blueprint(core_bp)
    app.register_blueprint(batch_bp)

    # favicon (evita 404 quando n√£o h√° arquivo)
    @app.route("/favicon.ico")
    def favicon():
        static_favicon = os.path.join(app.static_folder or "static", "favicon.ico")
        if os.path.exists(static_favicon):
            return send_from_directory(app.static_folder, "favicon.ico")
        # Sem favicon: responde 204 para n√£o poluir logs
        return make_response(("", 204))

    # Rota raiz ‚Äúfallback‚Äù (se a sua index real estiver no blueprint, ela ser√° usada)
    @app.route("/")
    def root_index():
        if "core.index" in app.view_functions:
            return redirect(url_for("core.index"))
        if "index" in app.view_functions:
            return redirect(url_for("index"))
        if "dashboard" in app.view_functions:
            return redirect(url_for("dashboard"))
        if "process_create" in app.view_functions:
            return redirect(url_for("process_create"))
        if "core.login" in app.view_functions:
            return redirect(url_for("core.login"))
        return "Rota raiz n√£o configurada."

    # ==============================
    # Bootstrap de DB (dev-friendly)
    # ==============================
    with app.app_context():
        try:
            db.create_all()  # √∫til em SQLite/dev; em produ√ß√£o prefira Alembic
        except Exception:
            pass

        try:
            ensure_admin_user()
        except Exception:
            pass

    # ==============================
    # Handlers de erro (DB)
    # ==============================
    # Capture qualquer erro de SQLAlchemy (inclui OperationalError/IntegrityError)
    @app.errorhandler(SQLAlchemyError)
    def handle_sqlalchemy_error(error):
        db.session.rollback()
        current_app.logger.exception("DB error: %s", error)
        flash("Houve um problema no banco de dados. Tente novamente.", "danger")
        return redirect(request.referrer or url_for("core.dashboard")), 302

    # (Opcional) se quiser tratar especificamente OperationalError tamb√©m:
    @app.errorhandler(OperationalError)
    def handle_operational_error(error):
        db.session.rollback()
        current_app.logger.exception("Operational DB error: %s", error)
        flash("Falha de conex√£o/operacional com o banco. Tente novamente.", "danger")
        return redirect(request.referrer or url_for("core.dashboard")), 302

    return app


if __name__ == "__main__":
    # Em dev voc√™ pode rodar: python app.py
    app = create_app()
    app.run(debug=True)



================================================================================
FILE: main.py
================================================================================
from app import create_app
from flask import jsonify, Response
from pathlib import Path

app = create_app()

@app.get("/api/ultimo-processo")
def api_ultimo_processo():
    p = Path("instance/rpa_current.json")
    if p.exists():
        txt = p.read_text(encoding="utf-8")
        return Response(txt, status=200, mimetype="application/json; charset=utf-8")
    return jsonify({}), 200

if __name__ == "__main__":
    app.run(debug=True, port=5000)



================================================================================
FILE: models.py
================================================================================
# models.py
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from sqlalchemy import func, event
from flask_login import UserMixin, current_user

from extensions import db


# ---------------------------------------------------------------------
# Usu√°rio
# ---------------------------------------------------------------------
class User(UserMixin, db.Model):
    __tablename__ = "user"  # se sua tabela for "users", troque aqui e nos ForeignKeys abaixo

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(120), unique=True, index=True, nullable=False)
    email = db.Column(db.String(255), unique=True, index=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    is_admin = db.Column(db.Boolean, default=False, nullable=False)

    created_at = db.Column(db.DateTime, server_default=func.now(), nullable=False)
    updated_at = db.Column(db.DateTime, server_default=func.now(), onupdate=func.now(), nullable=False)

    # relacionamento principal (dono do processo)
    processes = db.relationship(
        "Process",
        back_populates="owner",
        foreign_keys="Process.owner_id",
        cascade="all, delete-orphan",
        lazy="dynamic",
    )

    # relacionamentos auxiliares (opcionais)
    created_processes = db.relationship(
        "Process",
        foreign_keys="Process.created_by",
        backref="creator",
        lazy="dynamic",
    )
    updated_processes = db.relationship(
        "Process",
        foreign_keys="Process.updated_by",
        backref="updater",
        lazy="dynamic",
    )

    # Helpers de senha
    def set_password(self, password: str) -> None:
        self.password_hash = generate_password_hash(password)

    def check_password(self, password: str) -> bool:
        return check_password_hash(self.password_hash, password)

    def __repr__(self) -> str:
        return f"<User {self.username}>"


# ---------------------------------------------------------------------
# Processo
# ---------------------------------------------------------------------
class Process(db.Model):
    __tablename__ = "process"

    id = db.Column(db.Integer, primary_key=True)

    # üîë Dono / respons√°vel (com FKs)
    owner_id   = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    created_by = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    updated_by = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)

    # lado inverso do relacionamento principal
    owner = db.relationship("User", back_populates="processes", foreign_keys=[owner_id])

    # Campos do cabe√ßalho
    cnj = db.Column(db.String(3))                 # "Sim" / "N√£o" (ou bool, se preferir)
    tipo_processo = db.Column(db.String(20))      # "Eletr√¥nico" / "F√≠sico"

    numero_processo = db.Column(db.String(50), index=True)
    numero_processo_antigo = db.Column(db.String(50))
    sistema_eletronico = db.Column(db.String(60))

    area_direito = db.Column(db.String(60))
    sub_area_direito = db.Column(db.String(120))

    estado = db.Column(db.String(2))
    comarca = db.Column(db.String(120))
    numero_orgao = db.Column(db.String(20))
    origem = db.Column(db.String(60))
    orgao = db.Column(db.String(160))
    vara = db.Column(db.String(160))
    celula = db.Column(db.String(160))
    foro = db.Column(db.String(160))
    instancia = db.Column(db.String(60))

    assunto = db.Column(db.String(255))
    npc = db.Column(db.String(60))
    objeto = db.Column(db.Text)
    sub_objeto = db.Column(db.Text)

    # Strings para evitar ALTER TYPE no SQLite
    audiencia_inicial = db.Column(db.String(25))            # "YYYY-MM-DD HH:MM:SS"
    link_audiencia = db.Column(db.String(500))               # Link Zoom/Meet/Teams para audi√™ncia telepresencial
    subtipo_audiencia = db.Column(db.String(120))            # "Una", "N√£o-Una", "Tentativa Concilia√ß√£o", etc
    envolvido_audiencia = db.Column(db.String(80))           # "Advogado", "Preposto", "Advogado e Preposto", etc
    data_hora_cadastro_manual = db.Column(db.String(25))    # "YYYY-MM-DD HH:MM:SS"

    # Complementares / RAG
    cliente_parte = db.Column(db.Text)
    advogado_autor = db.Column(db.String(255))
    advogado_reu = db.Column(db.String(255))
    prazo = db.Column(db.String(120))
    tipo_notificacao = db.Column(db.String(255))
    resultado_audiencia = db.Column(db.Text)
    prazos_derivados_audiencia = db.Column(db.Text)
    decisao_tipo = db.Column(db.String(255))
    decisao_resultado = db.Column(db.String(255))
    decisao_fundamentacao_resumida = db.Column(db.Text)

    id_interno_hilo = db.Column(db.String(120))

    estrategia = db.Column(db.String(120))
    indice_atualizacao = db.Column(db.String(120))

    # Parte interessada / parte adversa
    posicao_parte_interessada = db.Column(db.String(60))     # "AUTOR..." / "R√âU..."
    parte_interessada = db.Column(db.String(200))

    parte_adversa_tipo = db.Column(db.String(50))            # "FISICA" / "JURIDICA" / "PESSOA FISICA" / "PESSOA JURIDICA"
    parte_adversa_nome = db.Column(db.String(200))
    escritorio_parte_adversa = db.Column(db.String(200))
    uf_oab_advogado_adverso = db.Column(db.String(5))
    cpf_cnpj_parte_adversa = db.Column(db.String(30))
    telefone_parte_adversa = db.Column(db.String(50))
    email_parte_adversa = db.Column(db.String(200))
    endereco_parte_adversa = db.Column(db.String(300))

    data_distribuicao = db.Column(db.String(50))
    data_citacao = db.Column(db.String(50))
    risco = db.Column(db.String(50))
    valor_causa = db.Column(db.String(30))
    rito = db.Column(db.String(120))
    observacao = db.Column(db.String(300))

    cadastrar_primeira_audiencia = db.Column(db.Boolean, default=False, nullable=False)
    
    # Campos adicionais
    cliente = db.Column(db.String(200))
    outra_reclamada_cliente = db.Column(db.String(200), nullable=True)  # Para casos de m√∫ltiplos clientes no polo (ex: CBSI + CSN onde CBSI √© principal)
    parte = db.Column(db.String(200))
    pdf_filename = db.Column(db.String(255))
    
    # Status do preenchimento no eLaw
    elaw_status = db.Column(db.String(20), default='pending', nullable=False)  # pending, running, success, error
    elaw_filled_at = db.Column(db.DateTime, nullable=True)  # Quando foi preenchido com sucesso
    elaw_error_message = db.Column(db.Text, nullable=True)  # Mensagem de erro se falhou
    
    # Screenshots do RPA (antes e depois de salvar)
    elaw_screenshot_before_path = db.Column(db.String(500), nullable=True)  # Screenshot do formul√°rio preenchido (ANTES de clicar Salvar)
    elaw_screenshot_after_path = db.Column(db.String(500), nullable=True)   # Screenshot ap√≥s salvar (sucesso ou erro)
    elaw_screenshot_path = db.Column(db.String(500), nullable=True)  # DEPRECATED: usar elaw_screenshot_before_path
    
    # ‚úÖ M√öLTIPLAS RECLAMADAS - URLs e screenshots
    elaw_detail_url = db.Column(db.String(500), nullable=True)  # URL da tela de detalhes do processo no eLaw
    elaw_screenshot_reclamadas_path = db.Column(db.String(500), nullable=True)  # Screenshot da aba "Partes e Advogados" ap√≥s inserir reclamadas extras
    elaw_screenshot_pedidos_path = db.Column(db.String(500), nullable=True)  # Screenshot da aba "Pedidos" ap√≥s inserir pedidos
    
    # ‚úÖ DADOS TRABALHISTAS - Informa√ß√µes espec√≠ficas de processos trabalhistas
    data_admissao = db.Column(db.String(50), nullable=True)          # Data de admiss√£o do trabalhador (DD/MM/AAAA)
    data_demissao = db.Column(db.String(50), nullable=True)          # Data de demiss√£o/dispensa (DD/MM/AAAA)
    salario = db.Column(db.String(50), nullable=True)                # Sal√°rio do trabalhador (R$ X.XXX,XX)
    cargo_funcao = db.Column(db.String(200), nullable=True)          # Cargo/Fun√ß√£o exercida
    empregador = db.Column(db.String(300), nullable=True)            # Nome da empresa empregadora
    pis = db.Column(db.String(20), nullable=True)                    # N√∫mero do PIS (XXX.XXXXX.XX-X)
    ctps = db.Column(db.String(50), nullable=True)                   # CTPS (n√∫mero e s√©rie)
    local_trabalho = db.Column(db.String(300), nullable=True)        # Local de trabalho/presta√ß√£o de servi√ßos
    motivo_demissao = db.Column(db.String(100), nullable=True)       # Motivo da demiss√£o (Sem Justa Causa, Rescis√£o Indireta, etc)
    
    # ‚úÖ PEDIDOS - Lista de pedidos extra√≠dos do PDF (JSON)
    pedidos_json = db.Column(db.Text, nullable=True)                 # JSON com lista de pedidos extra√≠dos

    created_at = db.Column(db.DateTime, server_default=func.now(), nullable=False)
    updated_at = db.Column(db.DateTime, server_default=func.now(), onupdate=func.now(), nullable=False)

    def __repr__(self) -> str:
        return f"<Process {self.numero_processo or self.id}>"

    # Campos cr√≠ticos que devem estar preenchidos para RPA (todos os campos do fluxo eLaw)
    CRITICAL_FIELDS = [
        # Identifica√ß√£o do processo
        'numero_processo',
        'area_direito',
        # Localiza√ß√£o
        'estado',
        'comarca',
        'numero_orgao',
        'orgao',
        'celula',
        'foro',
        'instancia',
        # Assunto/Objeto
        'assunto',
        # Partes
        'cliente',
        'posicao_parte_interessada',
        'parte_interessada',
        'parte_adversa_tipo',
        'parte_adversa_nome',
        # Datas
        'data_distribuicao',
        'data_admissao',
        'data_demissao',
        # Dados trabalhistas
        'salario',
        'cargo_funcao',
        'empregador',
        'local_trabalho',
        'motivo_demissao',
        'pis',
        'ctps',
        # Valor
        'valor_causa',
    ]
    
    CRITICAL_FIELD_LABELS = {
        # Identifica√ß√£o do processo
        'numero_processo': 'N√∫mero CNJ',
        'area_direito': '√Årea do Direito',
        # Localiza√ß√£o
        'estado': 'Estado',
        'comarca': 'Comarca',
        'numero_orgao': 'N¬∫ √ìrg√£o',
        'orgao': '√ìrg√£o',
        'celula': 'C√©lula',
        'foro': 'Foro',
        'instancia': 'Inst√¢ncia',
        # Assunto/Objeto
        'assunto': 'Assunto',
        # Partes
        'cliente': 'Cliente',
        'posicao_parte_interessada': 'Posi√ß√£o',
        'parte_interessada': 'Parte Interessada',
        'parte_adversa_tipo': 'Tipo Parte Adversa',
        'parte_adversa_nome': 'Nome Parte Adversa',
        # Datas
        'data_distribuicao': 'Data Distribui√ß√£o',
        'data_admissao': 'Data Admiss√£o',
        'data_demissao': 'Data Demiss√£o',
        # Dados trabalhistas
        'salario': 'Sal√°rio',
        'cargo_funcao': 'Cargo',
        'empregador': 'Empregador',
        'local_trabalho': 'Local Trabalho',
        'motivo_demissao': 'Motivo Demiss√£o',
        'pis': 'PIS',
        'ctps': 'CTPS',
        # Valor
        'valor_causa': 'Valor da Causa',
    }

    def get_missing_critical_fields(self) -> list:
        """Retorna lista de campos cr√≠ticos que est√£o vazios."""
        missing = []
        for field in self.CRITICAL_FIELDS:
            value = getattr(self, field, None)
            if not value or (isinstance(value, str) and not value.strip()):
                missing.append(self.CRITICAL_FIELD_LABELS.get(field, field))
        return missing

    def has_missing_critical_fields(self) -> bool:
        """Verifica se h√° campos cr√≠ticos faltando."""
        return len(self.get_missing_critical_fields()) > 0

    @property
    def critical_fields_complete(self) -> bool:
        """Retorna True se todos os campos cr√≠ticos est√£o preenchidos."""
        return not self.has_missing_critical_fields()

    # Helper opcional para preencher a partir do WTForm
    def fill_from_form(self, form) -> None:
        for field in (
            "cnj", "tipo_processo", "numero_processo", "numero_processo_antigo",
            "sistema_eletronico", "area_direito", "sub_area_direito", "estado",
            "comarca", "numero_orgao", "origem", "orgao", "vara", "celula", "foro",
            "instancia", "assunto", "npc", "objeto", "sub_objeto", "audiencia_inicial",
            "cliente_parte", "advogado_autor", "advogado_reu", "prazo",
            "tipo_notificacao", "resultado_audiencia", "prazos_derivados_audiencia",
            "decisao_tipo", "decisao_resultado", "decisao_fundamentacao_resumida",
            "id_interno_hilo", "data_hora_cadastro_manual", "estrategia",
            "indice_atualizacao", "posicao_parte_interessada", "parte_interessada",
            "parte_adversa_tipo", "parte_adversa_nome", "escritorio_parte_adversa",
            "uf_oab_advogado_adverso", "cpf_cnpj_parte_adversa", "telefone_parte_adversa",
            "email_parte_adversa", "endereco_parte_adversa", "data_distribuicao",
            "data_citacao", "risco", "valor_causa", "rito", "observacao",
            "cliente", "outra_reclamada_cliente", "parte",
            # Dados trabalhistas
            "data_admissao", "data_demissao", "salario", "cargo_funcao", "empregador",
            "pis", "ctps", "local_trabalho", "motivo_demissao",
        ):
            if hasattr(form, field):
                setattr(self, field, getattr(form, field).data)

        if hasattr(form, "cadastrar_primeira_audiencia"):
            self.cadastrar_primeira_audiencia = (
                getattr(form, "cadastrar_primeira_audiencia").data == "Sim"
            )


# ---------------------------------------------------------------------
# Utilit√°rio opcional para ‚Äúseed‚Äù do admin no primeiro run
# ---------------------------------------------------------------------
def ensure_admin_user():
    """Cria um admin padr√£o (admin / admin123) caso n√£o exista."""
    if not User.query.filter_by(username="admin").first():
        u = User(username="admin", email="admin@local", is_admin=True)
        u.set_password("admin123")
        db.session.add(u)
        db.session.commit()


# ---------------------------------------------------------------------
# Eventos para preencher created_by / updated_by automaticamente
# ---------------------------------------------------------------------
@event.listens_for(Process, "before_insert")
def _set_created_by(mapper, connection, target: Process):
    # tenta o usu√°rio logado; se n√£o houver, use o owner_id
    try:
        uid = current_user.id if current_user and not current_user.is_anonymous else target.owner_id
    except Exception:
        uid = target.owner_id
    if not target.created_by:
        target.created_by = uid
    target.updated_by = uid  # opcional: iguala no insert


@event.listens_for(Process, "before_update")
def _set_updated_by(mapper, connection, target: Process):
    try:
        if current_user and not current_user.is_anonymous:
            target.updated_by = current_user.id
    except Exception:
        pass


# ---------------------------------------------------------------------
# Status do RPA (progresso em tempo real)
# ---------------------------------------------------------------------
class RPAStatus(db.Model):
    __tablename__ = "rpa_status"
    
    id = db.Column(db.Integer, primary_key=True)
    process_id = db.Column(db.Integer, db.ForeignKey("process.id", ondelete="CASCADE"), nullable=False, index=True)
    
    # Status geral: starting, running, completed, error
    status = db.Column(db.String(20), nullable=False, default="starting")
    
    # Etapa atual (ex: "login", "preenchendo_cnj", "salvando")
    current_step = db.Column(db.String(100))
    
    # Mensagem descritiva
    message = db.Column(db.Text)
    
    # Dados adicionais (JSON serializado)
    data_json = db.Column(db.Text)  # JSON com dados do campo preenchido
    
    # Hist√≥rico de steps (JSON serializado - array de {step, message, timestamp, data})
    history_json = db.Column(db.Text)
    
    # Timestamps
    created_at = db.Column(db.DateTime, server_default=func.now(), nullable=False)
    updated_at = db.Column(db.DateTime, server_default=func.now(), onupdate=func.now(), nullable=False)
    
    # Relacionamento com processo
    process = db.relationship("Process", backref=db.backref("rpa_statuses", cascade="all, delete-orphan"))
    
    def __repr__(self) -> str:
        return f"<RPAStatus process_id={self.process_id} status={self.status!r} step={self.current_step!r}>"


# ---------------------------------------------------------------------
# Batch Upload (processamento em lote)
# ---------------------------------------------------------------------
class BatchUpload(db.Model):
    __tablename__ = "batch_upload"
    
    id = db.Column(db.Integer, primary_key=True)
    owner_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False, index=True)
    
    # Status: pending, extracting, ready, running, completed, partial_completed, error
    status = db.Column(db.String(20), nullable=False, default="pending", index=True)
    
    # Contadores
    total_count = db.Column(db.Integer, nullable=False, default=0)
    processed_count = db.Column(db.Integer, nullable=False, default=0)
    
    # Lock para processamento (task ID do Celery)
    lock_owner = db.Column(db.String(100), nullable=True)
    
    # Timestamps
    created_at = db.Column(db.DateTime, server_default=func.now(), nullable=False)
    started_at = db.Column(db.DateTime, nullable=True)
    finished_at = db.Column(db.DateTime, nullable=True)
    
    # Relacionamentos
    owner = db.relationship("User", foreign_keys=[owner_id])
    items = db.relationship("BatchItem", back_populates="batch", cascade="all, delete-orphan", lazy="dynamic")
    
    def __repr__(self) -> str:
        return f"<BatchUpload id={self.id} status={self.status!r} {self.processed_count}/{self.total_count}>"


class BatchItem(db.Model):
    __tablename__ = "batch_item"
    
    id = db.Column(db.Integer, primary_key=True)
    batch_id = db.Column(db.Integer, db.ForeignKey("batch_upload.id", ondelete="CASCADE"), nullable=False, index=True)
    process_id = db.Column(db.Integer, db.ForeignKey("process.id", ondelete="SET NULL"), nullable=True, index=True)
    
    # Arquivo fonte
    source_filename = db.Column(db.String(255), nullable=False)
    upload_path = db.Column(db.String(500), nullable=False)
    
    # Status: pending, extracting, ready, running, success, error
    status = db.Column(db.String(20), nullable=False, default="pending", index=True)
    
    # Controle de retry
    attempt_count = db.Column(db.Integer, nullable=False, default=0)
    last_error = db.Column(db.Text, nullable=True)
    
    # Timestamps
    created_at = db.Column(db.DateTime, server_default=func.now(), nullable=False)
    updated_at = db.Column(db.DateTime, server_default=func.now(), onupdate=func.now(), nullable=False)
    
    # Relacionamentos (especificar foreign_keys para evitar ambiguidade)
    batch = db.relationship("BatchUpload", back_populates="items")
    process = db.relationship("Process", foreign_keys=[process_id])
    
    def __repr__(self) -> str:
        return f"<BatchItem id={self.id} batch_id={self.batch_id} status={self.status!r}>"



================================================================================
FILE: forms.py
================================================================================
from __future__ import annotations

from flask_wtf import FlaskForm
from wtforms import (
    StringField,
    PasswordField,
    SubmitField,
    TextAreaField,
    SelectField,
    RadioField,
)
from wtforms.validators import DataRequired, Email, Length, Optional, EqualTo

__all__ = ["LoginForm", "CreateUserForm", "ProcessForm", "SearchForm"]

# =========================
# Autentica√ß√£o
# =========================
class LoginForm(FlaskForm):
    username = StringField("Usu√°rio ou E-mail", validators=[DataRequired(), Length(max=255)])
    password = PasswordField("Senha", validators=[DataRequired(), Length(max=255)])
    submit = SubmitField("Entrar")


class CreateUserForm(FlaskForm):
    name = StringField("Nome", validators=[DataRequired(), Length(max=255)])
    email = StringField("E-mail", validators=[DataRequired(), Email(), Length(max=255)])
    password = PasswordField("Senha", validators=[DataRequired(), Length(min=6, max=255)])
    confirm_password = PasswordField(
        "Confirmar Senha",
        validators=[DataRequired(), EqualTo("password", message="As senhas devem coincidir.")]
    )
    role = SelectField(
        "Papel",
        choices=[("user", "Usu√°rio"), ("admin", "Administrador")],
        validators=[Optional()]
    )
    submit = SubmitField("Criar Usu√°rio")


# =========================
# Processos
# =========================
_UF_CHOICES = [
    ("", ""),
    ("AC", "AC"), ("AL", "AL"), ("AP", "AP"), ("AM", "AM"), ("BA", "BA"),
    ("CE", "CE"), ("DF", "DF"), ("ES", "ES"), ("GO", "GO"), ("MA", "MA"),
    ("MT", "MT"), ("MS", "MS"), ("MG", "MG"), ("PA", "PA"), ("PB", "PB"),
    ("PR", "PR"), ("PE", "PE"), ("PI", "PI"), ("RJ", "RJ"), ("RN", "RN"),
    ("RS", "RS"), ("RO", "RO"), ("RR", "RR"), ("SC", "SC"), ("SP", "SP"),
    ("SE", "SE"), ("TO", "TO"),
]

_AREA_CHOICES = [
    ("", ""),
    ("Trabalhista", "Trabalhista"),
    ("C√≠vel", "C√≠vel"),
    ("Criminal", "Criminal"),
    ("Previdenci√°rio", "Previdenci√°rio"),
    ("Administrativo", "Administrativo"),
    ("Tribut√°rio", "Tribut√°rio"),
    ("Outros", "Outros"),
]

_INSTANCIA_CHOICES = [
    ("", ""),
    ("Primeira Inst√¢ncia", "Primeira Inst√¢ncia"),
    ("Segunda Inst√¢ncia", "Segunda Inst√¢ncia"),
    ("Superior", "Superior"),
]

_RISCO_CHOICES = [("", ""), ("Baixo", "Baixo"), ("M√©dio", "M√©dio"), ("Alto", "Alto")]
_RITO_CHOICES = [("", ""), ("Ordin√°rio", "Ordin√°rio"), ("Sumar√≠ssimo", "Sumar√≠ssimo"), ("Sum√°rio", "Sum√°rio")]
_INDICE_CHOICES = [("", ""), ("IPCA-E", "IPCA-E"), ("TR", "TR"), ("SELIC", "SELIC")]
_ESTRATEGIA_CHOICES = [("", ""), ("Defensiva", "Defensiva"), ("Negocial", "Negocial"), ("Ativa", "Ativa")]
_POSICAO_CHOICES = [("", ""), ("AUTOR", "AUTOR / RECLAMANTE"), ("REU", "R√âU / RECLAMADO")]


class ProcessForm(FlaskForm):
    # Campos principais
    cnj = RadioField(
        "CNJ",
        choices=[("Sim", "Sim"), ("N√£o", "N√£o")],
        default="Sim",
        validators=[DataRequired()]
    )
    tipo_processo = RadioField(
        "Tipo de Processo",
        choices=[("Eletr√¥nico", "Eletr√¥nico"), ("F√≠sico", "F√≠sico")],
        default="Eletr√¥nico",
        validators=[DataRequired()]
    )

    numero_processo = StringField("N√∫mero do Processo", validators=[Optional(), Length(max=50)])
    numero_processo_antigo = StringField("N√∫mero do Processo (Antigo)", validators=[Optional(), Length(max=50)])
    sistema_eletronico = StringField("Sistema Eletr√¥nico", validators=[Optional(), Length(max=60)])

    area_direito = SelectField("√Årea do Direito", choices=_AREA_CHOICES, validators=[Optional()])
    sub_area_direito = StringField("Sub-√°rea do Direito", validators=[Optional(), Length(max=120)])

    estado = SelectField("Estado", choices=_UF_CHOICES, validators=[Optional()])
    comarca = StringField("Comarca", validators=[Optional(), Length(max=120)])
    numero_orgao = StringField("N√∫mero do √ìrg√£o/Unidade", validators=[Optional(), Length(max=20)])
    origem = StringField("Origem (ex.: TRT, TJ, JF)", validators=[Optional(), Length(max=60)])
    orgao = StringField("√ìrg√£o (ex.: Vara do Trabalho, Vara C√≠vel)", validators=[Optional(), Length(max=160)])
    vara = StringField("Vara", validators=[Optional(), Length(max=160)])
    celula = StringField("C√©lula (se aplic√°vel)", validators=[Optional(), Length(max=160)])
    foro = StringField("Foro", validators=[Optional(), Length(max=160)])
    instancia = SelectField("Inst√¢ncia", choices=_INSTANCIA_CHOICES, validators=[Optional()])

    assunto = StringField("Assunto", validators=[Optional(), Length(max=255)])
    npc = StringField("NPC", validators=[Optional(), Length(max=60)])
    objeto = TextAreaField("Objeto", validators=[Optional(), Length(max=4000)])
    sub_objeto = TextAreaField("Sub-objeto", validators=[Optional(), Length(max=4000)])

    audiencia_inicial = StringField(
        "Audi√™ncia Inicial",
        validators=[Optional(), Length(max=25)],
        render_kw={"placeholder": "YYYY-MM-DD HH:MM:SS"}
    )

    # Complementares (RAG)
    cliente_parte = TextAreaField("Cliente/Parte (JSON)", validators=[Optional()])
    advogado_autor = StringField("Advogado(a) do Autor", validators=[Optional(), Length(max=255)])
    advogado_reu = StringField("Advogado(a) do R√©u", validators=[Optional(), Length(max=255)])
    prazo = StringField("Prazo", validators=[Optional(), Length(max=120)])
    tipo_notificacao = StringField("Tipo de Notifica√ß√£o", validators=[Optional(), Length(max=255)])
    resultado_audiencia = TextAreaField("Resultado da Audi√™ncia", validators=[Optional()])
    prazos_derivados_audiencia = TextAreaField("Prazos Derivados da Audi√™ncia", validators=[Optional()])
    decisao_tipo = StringField("Tipo da Decis√£o", validators=[Optional(), Length(max=255)])
    decisao_resultado = StringField("Resultado da Decis√£o", validators=[Optional(), Length(max=255)])
    decisao_fundamentacao_resumida = TextAreaField("Fundamenta√ß√£o Resumida", validators=[Optional()])

    id_interno_hilo = StringField("ID Interno Hilo", validators=[Optional(), Length(max=120)])
    data_hora_cadastro_manual = StringField(
        "Data/Hora Cadastro Manual",
        validators=[Optional(), Length(max=25)],
        render_kw={"placeholder": "YYYY-MM-DD HH:MM:SS"}
    )

    # Estrat√©gia / √çndice
    estrategia = SelectField("Estrat√©gia", choices=_ESTRATEGIA_CHOICES, validators=[Optional()])
    indice_atualizacao = SelectField("√çndice Atualiza√ß√£o Monet√°ria", choices=_INDICE_CHOICES, validators=[Optional()])

    # Dados do Cliente e Parte Adversa
    posicao_parte_interessada = SelectField(
        "Posi√ß√£o Parte Interessada*",
        choices=_POSICAO_CHOICES,
        validators=[Optional()]
    )
    parte_interessada = StringField("Parte Interessada*", validators=[Optional(), Length(max=200)])

    parte_adversa_tipo = RadioField(
        "Parte Adversa (Tipo)*",
        choices=[("FISICA", "F√≠sica"), ("JURIDICA", "Jur√≠dica")],
        validators=[Optional()]
    )
    parte_adversa_nome = StringField("Parte Adversa (Nome)*", validators=[Optional(), Length(max=200)])
    escritorio_parte_adversa = StringField("Escrit√≥rio parte adversa", validators=[Optional(), Length(max=200)])
    uf_oab_advogado_adverso = SelectField("UF OAB Advogado Adverso", choices=_UF_CHOICES, validators=[Optional()])
    cpf_cnpj_parte_adversa = StringField("CPF/CNPJ - Parte Adversa", validators=[Optional(), Length(max=25)])
    telefone_parte_adversa = StringField("Telefone - Parte Adversa", validators=[Optional(), Length(max=30)])
    email_parte_adversa = StringField("Email Parte Adversa", validators=[Optional(), Email(), Length(max=120)])
    endereco_parte_adversa = StringField("Endere√ßo - Parte Adversa", validators=[Optional(), Length(max=300)])

    # Outras Informa√ß√µes
    data_distribuicao = StringField("Data de Distribui√ß√£o", validators=[Optional(), Length(max=10)])
    data_citacao = StringField("Data da Cita√ß√£o", validators=[Optional(), Length(max=10)])
    risco = SelectField("Risco", choices=_RISCO_CHOICES, validators=[Optional()])
    valor_causa = StringField("Valor da Causa*", validators=[Optional(), Length(max=30)])
    rito = SelectField("Rito", choices=_RITO_CHOICES, validators=[Optional()])
    observacao = TextAreaField("Observa√ß√£o (Breve Relato)", validators=[Optional(), Length(max=300)])
    cadastrar_primeira_audiencia = RadioField(
        "Deseja cadastrar a primeira Audi√™ncia?",
        choices=[("Sim", "Sim"), ("N√£o", "N√£o")],
        default="N√£o",
        validators=[Optional()]
    )

    submit = SubmitField("Salvar")


# =========================
# Busca
# =========================
class SearchForm(FlaskForm):
    q = StringField("Buscar", validators=[Optional(), Length(max=255)])
    submit = SubmitField("Pesquisar")



================================================================================
FILE: extensions.py
================================================================================
# extensions.py
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager

db = SQLAlchemy()
login_manager = LoginManager()
login_manager.login_view = "core.login"



================================================================================
FILE: routes.py
================================================================================
# routes.py
from __future__ import annotations

import io
import os
import re
import sys
import json
import logging
import subprocess
import time
from pathlib import Path
from datetime import datetime
from collections import Counter

logger = logging.getLogger(__name__)

# Integra√ß√£o com monitor remoto
try:
    from monitor_integration import log_info, log_error
    MONITOR_AVAILABLE = True
except ImportError:
    MONITOR_AVAILABLE = False
    def log_info(msg, region=""): pass
    def log_error(msg, exc=None, region=""): pass

from flask import (
    Blueprint, render_template, render_template_string, request, redirect,
    url_for, flash, session, current_app, send_from_directory, abort, jsonify
)
from flask_login import login_required, login_user, logout_user, current_user
from jinja2 import TemplateNotFound
from werkzeug.security import check_password_hash

from sqlalchemy.exc import SQLAlchemyError

from models import db, User, Process
from forms import LoginForm  # <-- usa seu forms.py
from extractors import (
    extract_text_from_pdf,
    run_extraction_from_text,
    run_extraction_from_file,
)
# Se voc√™ usa o parser direto aqui tamb√©m:
from extractors.cadastro import parse_pdf_text

bp = Blueprint("core", __name__)


def _reset_process_sequence_if_empty():
    """
    Reseta a sequ√™ncia de IDs da tabela process se ela estiver vazia.
    Isso permite que os IDs comecem novamente do 1.
    """
    from sqlalchemy import text
    
    try:
        result = db.session.execute(text("SELECT COUNT(*) FROM process"))
        count = result.scalar()
        
        if count == 0:
            db.session.execute(text("ALTER SEQUENCE process_id_seq RESTART WITH 1"))
            db.session.commit()
            logger.info("[RESET_SEQ] ‚úÖ Sequ√™ncia process_id_seq resetada para 1")
            return True
    except Exception as e:
        logger.warning(f"[RESET_SEQ] N√£o foi poss√≠vel resetar sequ√™ncia de process: {e}")
        db.session.rollback()
    
    return False

# ============================================================
# Rotas p√∫blicas / auth
# ============================================================

@bp.route("/")
def index():
    if current_user.is_authenticated:
        return redirect(url_for("core.dashboard"))
    return redirect(url_for("core.login"))


@bp.route("/login", methods=["GET", "POST"])
def login():
    if current_user.is_authenticated:
        return redirect(url_for("core.dashboard"))

    next_url = request.args.get("next") or url_for("core.dashboard")
    form = LoginForm()

    if request.method == "POST":
        import logging
        logger = logging.getLogger(__name__)
        logger.info(f"[LOGIN] POST recebido")
        logger.info(f"[LOGIN] Form valid: {form.validate_on_submit()}")
        logger.info(f"[LOGIN] Form errors: {form.errors}")
        
        if form.validate_on_submit():
            username_or_email = (form.username.data or "").strip()
            password = form.password.data or ""
            
            logger.info(f"[LOGIN] Username/email: {username_or_email}")
            logger.info(f"[LOGIN] Password length: {len(password)}")

            user = (
                User.query.filter_by(username=username_or_email).first()
                or User.query.filter_by(email=username_or_email).first()
            )
            
            logger.info(f"[LOGIN] User found: {user is not None}")

            ok = False
            if user:
                # tenta m√©todos comuns; se n√£o houver, usa hash simples
                if hasattr(user, "check_password"):
                    ok = user.check_password(password)
                    logger.info(f"[LOGIN] check_password result: {ok}")
                elif hasattr(user, "verify_password"):
                    ok = user.verify_password(password)
                    logger.info(f"[LOGIN] verify_password result: {ok}")
                else:
                    ok = check_password_hash(getattr(user, "password_hash", ""), password)
                    logger.info(f"[LOGIN] check_password_hash result: {ok}")

            if not user or not ok:
                logger.warning(f"[LOGIN] Login failed - user: {user is not None}, ok: {ok}")
                flash("Credenciais inv√°lidas.", "danger")
                # mant√©m o form para exibir erros/CSRF corretamente
                return render_template("login.html", form=form, next_url=next_url)

            login_user(user)
            logger.info(f"[LOGIN] Login successful for user: {user.username}")
            flash("Login efetuado com sucesso.", "success")
            return redirect(next_url)

    return render_template("login.html", form=form, next_url=next_url)


@bp.route("/logout")
@login_required
def logout():
    logout_user()
    flash("Voc√™ saiu da sess√£o.", "success")
    return redirect(url_for("core.login"))


@bp.route("/uploads/<filename>")
@login_required
def uploaded_file(filename):
    """Serve PDF files from uploads directory"""
    uploads_dir = Path(__file__).parent / "uploads"
    return send_from_directory(uploads_dir, filename)


# ============================================================
# Dashboard
# ============================================================

@bp.route("/dashboard")
@login_required
def dashboard():
    total_processes = Process.query.count()
    user_processes = Process.query.filter_by(owner_id=current_user.id).count()
    recent_processes = Process.query.order_by(Process.created_at.desc()).limit(10).all()
    return render_template(
        "dashboard.html",
        total_processes=total_processes,
        user_processes=user_processes,
        recent_processes=recent_processes,
    )

# ============================================================
# Processos
# ============================================================

@bp.route("/processos")
@login_required
def process_list():
    page = request.args.get('page', 1, type=int)
    search = request.args.get('search', '', type=str)
    
    query = Process.query
    if search:
        query = query.filter(
            (Process.cnj.ilike(f'%{search}%')) |
            (Process.numero_processo.ilike(f'%{search}%')) |
            (Process.assunto.ilike(f'%{search}%')) |
            (Process.objeto.ilike(f'%{search}%'))
        )
    
    processes = query.order_by(Process.created_at.desc()).paginate(
        page=page, per_page=20, error_out=False
    )
    return render_template("processes/list.html", processes=processes, search=search)


@bp.route("/processos/<int:id>")
@login_required
def process_view(id: int):
    proc = Process.query.get_or_404(id)
    batch_id = request.args.get('batch_id', type=int)
    return render_template("processes/view.html", process=proc, batch_id=batch_id)


@bp.route("/processos/<int:id>/screenshot")
@login_required
def process_screenshot(id: int):
    """Serve o screenshot PNG do formul√°rio eLaw preenchido (DEPRECATED - usar /screenshot/before ou /screenshot/after)"""
    proc = Process.query.get_or_404(id)
    
    # Verificar ownership
    if proc.owner_id != current_user.id:
        abort(403)
    
    # Verificar se screenshot existe
    if not proc.elaw_screenshot_path:
        abort(404)
    
    # Servir arquivo do diret√≥rio rpa_screenshots (N√ÉO static!)
    screenshot_filename = Path(proc.elaw_screenshot_path).name
    screenshot_dir = Path('/home/runner/workspace/rpa_screenshots')
    
    return send_from_directory(
        directory=str(screenshot_dir),
        path=screenshot_filename,
        as_attachment=False
    )


@bp.route("/rpa_screenshots/<path:filename>")
@login_required
def serve_rpa_screenshot(filename):
    """Serve screenshots do RPA (before/after) - procura em ambos diret√≥rios"""
    # Normalizar filename: remover prefixo 'rpa_screenshots/' se presente (legado)
    # Isso garante compatibilidade com paths salvos como "rpa_screenshots/file.png" e "file.png"
    clean_filename = Path(filename).name
    
    # Tentar primeiro o novo diret√≥rio (static/rpa_screenshots)
    screenshot_dir_new = Path('static') / 'rpa_screenshots'
    full_path_new = screenshot_dir_new / clean_filename
    
    if full_path_new.exists() and full_path_new.is_file():
        return send_from_directory(
            directory=str(screenshot_dir_new),
            path=clean_filename,
            as_attachment=False
        )
    
    # Fallback para diret√≥rio legado (screenshots de erro, login, etc)
    screenshot_dir_legacy = Path('/home/runner/workspace/rpa_screenshots')
    full_path_legacy = screenshot_dir_legacy / clean_filename
    
    if full_path_legacy.exists() and full_path_legacy.is_file():
        return send_from_directory(
            directory=str(screenshot_dir_legacy),
            path=clean_filename,
            as_attachment=False
        )
    
    # Arquivo n√£o encontrado em nenhum diret√≥rio
    abort(404)


@bp.route("/processos/<int:id>/update-field", methods=["POST"])
@login_required
def process_update_field(id: int):
    """Atualiza um campo individual do processo via AJAX (para edi√ß√£o inline)."""
    proc = Process.query.get_or_404(id)
    
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'Dados inv√°lidos'}), 400
        
        field_name = data.get('field')
        field_value = data.get('value', '').strip()
        
        # Campos protegidos que n√£o podem ser editados
        protected_fields = ['id', 'created_at', 'updated_at', 'owner_id', 'created_by', 
                           'elaw_status', 'elaw_filled_at', 'elaw_error_message',
                           'elaw_screenshot_before_path', 'elaw_screenshot_after_path',
                           'elaw_screenshot_path', 'elaw_detail_url', 
                           'elaw_screenshot_reclamadas_path', 'elaw_screenshot_pedidos_path']
        
        if not field_name:
            return jsonify({'success': False, 'error': 'Nome do campo n√£o informado'}), 400
        
        if field_name in protected_fields:
            return jsonify({'success': False, 'error': 'Campo protegido'}), 403
        
        if not hasattr(proc, field_name):
            return jsonify({'success': False, 'error': f'Campo {field_name} n√£o existe'}), 400
        
        # Atualizar o campo
        setattr(proc, field_name, field_value if field_value else None)
        proc.updated_by = current_user.id
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'field': field_name, 
            'value': field_value,
            'message': f'Campo {field_name} atualizado com sucesso'
        })
        
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@bp.route("/processos/<int:id>/editar", methods=["GET", "POST"])
@login_required
def process_edit(id: int):
    proc = Process.query.get_or_404(id)
    batch_id = request.args.get('batch_id', type=int)
    
    if request.method == "POST":
        form_data = request.form.to_dict(flat=True)
        
        # Atualizar todos os campos do processo
        for field, value in form_data.items():
            if hasattr(proc, field) and field not in ['id', 'created_at', 'updated_at', 'owner_id', 'created_by']:
                setattr(proc, field, value if value else None)
        
        # Atualizar campos booleanos (checkbox envia "on" quando marcado)
        proc.cadastrar_primeira_audiencia = form_data.get('cadastrar_primeira_audiencia') in ['on', 'Sim', '1', 'true']
        
        # Atualizar updated_by
        proc.updated_by = current_user.id
        
        try:
            db.session.commit()
            flash(f"Processo #{proc.id} atualizado com sucesso!", "success")
            # Redirecionar de volta ao batch se veio de l√°
            if batch_id:
                return redirect(url_for("core.process_view", id=proc.id, batch_id=batch_id))
            else:
                return redirect(url_for("core.process_view", id=proc.id))
        except SQLAlchemyError as e:
            db.session.rollback()
            flash(f"Erro ao atualizar processo: {e}", "danger")
    
    # GET: preparar dados para o formul√°rio (mesma estrutura do confirm_extracted)
    data = {
        'cnj': proc.cnj,
        'tipo_processo': proc.tipo_processo,
        'numero_processo': proc.numero_processo,
        'numero_processo_antigo': proc.numero_processo_antigo,
        'sistema_eletronico': proc.sistema_eletronico,
        'area_direito': proc.area_direito,
        'sub_area_direito': proc.sub_area_direito,
        'estado': proc.estado,
        'comarca': proc.comarca,
        'numero_orgao': proc.numero_orgao,
        'origem': proc.origem,
        'orgao': proc.orgao,
        'vara': proc.vara,
        'celula': proc.celula,
        'foro': proc.foro,
        'instancia': proc.instancia,
        'assunto': proc.assunto,
        'npc': proc.npc,
        'objeto': proc.objeto,
        'sub_objeto': proc.sub_objeto,
        'cliente': proc.cliente,
        'parte': proc.parte,
        'cliente_parte': proc.cliente_parte,
        'advogado_autor': proc.advogado_autor,
        'advogado_reu': proc.advogado_reu,
        'audiencia_inicial': proc.audiencia_inicial,
        'prazo': proc.prazo,
        'tipo_notificacao': proc.tipo_notificacao,
        'resultado_audiencia': proc.resultado_audiencia,
        'prazos_derivados_audiencia': proc.prazos_derivados_audiencia,
        'decisao_tipo': proc.decisao_tipo,
        'decisao_resultado': proc.decisao_resultado,
        'decisao_fundamentacao_resumida': proc.decisao_fundamentacao_resumida,
        'id_interno_hilo': proc.id_interno_hilo,
        'estrategia': proc.estrategia,
        'indice_atualizacao': proc.indice_atualizacao,
        'posicao_parte_interessada': proc.posicao_parte_interessada,
        'parte_interessada': proc.parte_interessada,
        'parte_adversa_tipo': proc.parte_adversa_tipo,
        'parte_adversa_nome': proc.parte_adversa_nome,
        'escritorio_parte_adversa': proc.escritorio_parte_adversa,
        'uf_oab_advogado_adverso': proc.uf_oab_advogado_adverso,
        'cpf_cnpj_parte_adversa': proc.cpf_cnpj_parte_adversa,
        'telefone_parte_adversa': proc.telefone_parte_adversa,
        'email_parte_adversa': proc.email_parte_adversa,
        'endereco_parte_adversa': proc.endereco_parte_adversa,
        'data_distribuicao': proc.data_distribuicao,
        'data_citacao': proc.data_citacao,
        'risco': proc.risco,
        'valor_causa': proc.valor_causa,
        'rito': proc.rito,
        'observacao': proc.observacao,
        'cadastrar_primeira_audiencia': 'Sim' if proc.cadastrar_primeira_audiencia else 'N√£o',
        # Campos trabalhistas (RPA)
        'data_admissao': proc.data_admissao,
        'data_demissao': proc.data_demissao,
        'motivo_demissao': proc.motivo_demissao,
        'salario': proc.salario,
        'cargo_funcao': proc.cargo_funcao,
        'cargo': proc.cargo,
        'empregador': proc.empregador,
        'local_trabalho': proc.local_trabalho,
        'pis': proc.pis,
        'ctps': proc.ctps,
        # Campos de audi√™ncia (RPA)
        'link_audiencia': proc.link_audiencia,
        'subtipo_audiencia': proc.subtipo_audiencia,
        'envolvido_audiencia': proc.envolvido_audiencia,
    }
    return render_template("processes/edit.html", data=data, process_id=id, batch_id=batch_id)



def _launch_rpa_thread(process_id: int) -> None:
    """Dispara RPA em thread background (mesma abordagem do batch)."""
    import threading
    import rpa
    from main import app  # Import DENTRO da fun√ß√£o (evita circular)
    
    def run_rpa_in_background(proc_id: int):
        try:
            with app.app_context():
                logger.info(f"[SINGLE RPA] Iniciando RPA para processo {proc_id}")
                rpa.execute_rpa(proc_id)
                logger.info(f"[SINGLE RPA] ‚úÖ Processo {proc_id} conclu√≠do")
        except Exception as e:
            logger.error(f"[SINGLE RPA] ‚ùå Erro: {e}", exc_info=True)
            try:
                from main import app as app_err
                with app_err.app_context():
                    proc = Process.query.get(proc_id)
                    if proc:
                        proc.elaw_status = 'error'
                        proc.elaw_error_message = str(e)
                        db.session.commit()
            except Exception as db_err:
                logger.error(f"[SINGLE RPA] Erro ao marcar erro: {db_err}")
    
    thread = threading.Thread(
        target=run_rpa_in_background,
        args=(process_id,),
        daemon=True,
        name=f"RPA-Single-{process_id}"
    )
    thread.start()
    logger.info(f"[SINGLE RPA] Thread iniciada para processo {process_id}")

@bp.route("/processos/<int:id>/preencher-elaw", methods=["POST"])
@login_required
def process_fill_elaw(id: int):
    import rpa
    from main import app as main_app
    
    proc = Process.query.get_or_404(id)
    batch_id = request.args.get('batch_id', type=int)
    
    # ‚úÖ CRITICAL: Configurar flask_app globalmente ANTES de lan√ßar thread
    rpa.flask_app = main_app._get_current_object() if hasattr(main_app, '_get_current_object') else main_app
    logger.info(f"[SINGLE RPA] Flask app configurado para processo {proc.id}")
    
    # Atualizar status para 'running'
    proc.elaw_status = 'running'
    proc.elaw_error_message = None
    db.session.commit()
    
    try:
        _launch_rpa_thread(process_id=proc.id)
        flash(f"Iniciando preenchimento autom√°tico no eLaw para o processo #{proc.id}...", "info")
        if batch_id:
            return redirect(url_for("core.rpa_progress", process_id=proc.id, batch_id=batch_id))
        else:
            return redirect(url_for("core.rpa_progress", process_id=proc.id))
    except Exception as e:
        proc.elaw_status = 'error'
        proc.elaw_error_message = str(e)
        db.session.commit()
        flash(f"N√£o foi poss√≠vel iniciar o RPA: {e}", "danger")
        if batch_id:
            return redirect(url_for("core.process_view", id=proc.id, batch_id=batch_id))
        else:
            return redirect(url_for("core.process_view", id=proc.id))


@bp.route("/processos/<int:id>/deletar", methods=["POST"])
@login_required
def process_delete(id: int):
    proc = Process.query.get_or_404(id)
    
    # Verifica√ß√£o de autoriza√ß√£o: apenas o dono ou admin pode deletar
    if proc.owner_id != current_user.id and not current_user.is_admin:
        flash("Voc√™ n√£o tem permiss√£o para deletar este processo.", "danger")
        return redirect(url_for("core.process_list"))
    
    try:
        cnj = proc.cnj or f"#{proc.id}"
        db.session.delete(proc)
        db.session.commit()
        
        # Resetar sequ√™ncia se tabela ficou vazia
        _reset_process_sequence_if_empty()
        
        flash(f"Processo {cnj} deletado com sucesso!", "success")
    except SQLAlchemyError as e:
        db.session.rollback()
        flash(f"Erro ao deletar processo: {e}", "danger")
    
    return redirect(url_for("core.process_list"))


@bp.route("/processos/deletar-multiplos", methods=["POST"])
@login_required
def process_delete_multiple():
    """Deletar m√∫ltiplos processos de uma vez"""
    from flask import jsonify
    
    try:
        data = request.get_json()
        process_ids = data.get('process_ids', [])
        
        if not process_ids or not isinstance(process_ids, list):
            return jsonify({'success': False, 'error': 'Lista de IDs inv√°lida'}), 400
        
        # Converter IDs para inteiros
        try:
            process_ids = [int(pid) for pid in process_ids]
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': 'IDs devem ser n√∫meros'}), 400
        
        # Buscar processos e verificar permiss√µes
        processes = Process.query.filter(Process.id.in_(process_ids)).all()
        
        # Verificar se todos os processos existem
        if len(processes) != len(process_ids):
            return jsonify({'success': False, 'error': 'Alguns processos n√£o foram encontrados'}), 404
        
        # Verificar permiss√µes - apenas dono ou admin pode deletar
        unauthorized = []
        for proc in processes:
            if proc.owner_id != current_user.id and not current_user.is_admin:
                unauthorized.append(proc.id)
        
        if unauthorized:
            return jsonify({
                'success': False, 
                'error': f'Voc√™ n√£o tem permiss√£o para deletar {len(unauthorized)} processo(s)'
            }), 403
        
        # Deletar todos os processos
        deleted_count = 0
        for proc in processes:
            try:
                db.session.delete(proc)
                deleted_count += 1
            except Exception as e:
                logger.error(f"Erro ao deletar processo {proc.id}: {e}")
        
        db.session.commit()
        
        # Resetar sequ√™ncia se tabela ficou vazia
        _reset_process_sequence_if_empty()
        
        return jsonify({
            'success': True,
            'message': f'{deleted_count} processo(s) deletado(s) com sucesso!'
        })
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Erro ao deletar processos m√∫ltiplos: {e}", exc_info=True)
        return jsonify({'success': False, 'error': f'Erro ao deletar processos: {str(e)}'}), 500


@bp.route("/processos/criar", methods=["GET", "POST"])
@login_required
def process_create():
    if request.method == "POST":
        form = request.form.to_dict(flat=True)

        # checkbox ‚Üí bool
        form["cadastrar_primeira_audiencia"] = (
            form.get("cadastrar_primeira_audiencia") in ["on", "true", "True", "1", 1, True]
        )

        allowed = {
            "cnj_sim", "tipo_processo", "numero_processo", "numero_processo_antigo",
            "sistema_eletronico", "area_direito", "sub_area_direito", "estado",
            "comarca", "numero_orgao", "origem", "orgao", "vara", "celula", "foro",
            "instancia", "assunto", "npc", "objeto", "sub_objeto",
            "audiencia_inicial", "data_hora_cadastro_manual", "cliente",
            "parte", "advogado_autor", "advogado_reu",
            "posicao_parte_interessada", "parte_interessada",
            "parte_adversa_tipo", "parte_adversa_nome",
            "uf_oab_adv_adverso", "cpf_cnpj_parte_adversa", "telefone_parte_adversa",
            "email_parte_adversa", "endereco_parte_adversa",
            "data_distribuicao", "valor_causa", "rito",
            "tipo_notificacao", "resultado_decisao", "fundamentacao_resumida",
            "estrategia", "indice_atualizacao", "id_interno_hilo",
            "observacao", "cadastrar_primeira_audiencia"
        }
        payload = {k: v for k, v in form.items() if k in allowed}
        payload["owner_id"] = current_user.id

        proc = Process(**payload)
        db.session.add(proc)
        db.session.commit()

        session.pop("extracted_data", None)
        flash("Processo criado com sucesso.", "success")
        return redirect(url_for("core.process_view", id=proc.id))

    return render_template("processes/create.html")

# ============================================================
# Extra√ß√£o por PDF ‚Üí confirma√ß√£o
# ============================================================

def _extract_text_from_pdf(file_storage) -> str:
    """
    Extrai texto de um PDF de forma resiliente:
      1) pdfminer.six  2) PyPDF2  3) decode() como √∫ltimo recurso
    """
    file_storage.stream.seek(0)
    raw = file_storage.read()
    text = ""

    # 1) pdfminer.six
    try:
        from pdfminer.high_level import extract_text  # type: ignore
        text = extract_text(io.BytesIO(raw)) or ""
    except Exception:
        text = ""

    # 2) PyPDF2 (fallback)
    if not text.strip():
        try:
            import PyPDF2  # type: ignore
            reader = PyPDF2.PdfReader(io.BytesIO(raw))
            pages = []
            for p in reader.pages:
                try:
                    pages.append(p.extract_text() or "")
                except Exception:
                    pass
            text = "\n".join(pages)
        except Exception:
            text = ""

    # 3) √∫ltimo recurso: tentativa de decodifica√ß√£o
    if not text.strip():
        try:
            text = raw.decode("utf-8", errors="ignore")
        except Exception:
            text = ""

    return text or ""


@bp.route("/processos/extrair-pdf", methods=["GET", "POST"])
@login_required
def extract_from_pdf():
    if request.method == "POST":
        file = request.files.get("pdf_file")
        if not file or file.filename == "":
            flash("Selecione um PDF v√°lido.", "danger")
            return redirect(url_for("core.extract_from_pdf"))

        try:
            # CR√çTICO: Salvar o PDF no diret√≥rio uploads/ para vincula√ß√£o ao processo
            import uuid
            from werkzeug.utils import secure_filename
            
            upload_dir = os.path.join(current_app.root_path, "uploads")
            os.makedirs(upload_dir, exist_ok=True)
            
            # Nome √∫nico: timestamp_uuid_filename
            original_name = secure_filename(file.filename or "documento.pdf")
            unique_filename = f"{int(time.time())}_{uuid.uuid4().hex[:8]}_{original_name}"
            pdf_path = os.path.join(upload_dir, unique_filename)
            
            # Salvar arquivo fisicamente
            file.save(pdf_path)
            logger.info(f"[UPLOAD_PDF] PDF salvo: {unique_filename}")
            
            # ‚úÖ MUDAN√áA: Usar run_extraction_from_file que j√° tem OCR/LLM integrado
            # Passa o caminho do PDF salvo para habilitar OCR quando necess√°rio
            extracted = run_extraction_from_file(
                path=pdf_path,
                brand_map_path=None,  # Usa database JSON padr√£o
                filename=file.filename
            )
            # Blindagem caso o extrator n√£o tenha setado
            extracted.setdefault("cnj", "Sim" if extracted.get("cnj_sim") else "N√£o")
            extracted.setdefault("tipo_processo", "Eletr√¥nico")
            extracted.setdefault("sistema_eletronico", "PJE")
            extracted.setdefault("area_direito", "Trabalhista")

            # CR√çTICO: Guardar filename do PDF na sess√£o para vincular ao processo
            session["uploaded_pdf_filename"] = unique_filename
            session["extracted_data"] = extracted or {}
            session.modified = True
            current_app.logger.debug("Dados extra√≠dos (pipeline): %s", extracted)
            logger.info(f"[UPLOAD_PDF] PDF '{unique_filename}' vinculado √† sess√£o")

            flash("Extra√ß√£o conclu√≠da! Revise os dados abaixo antes de salvar.", "success")
            return redirect(url_for("core.confirm_extracted"))

        except Exception as e:
            current_app.logger.exception("Erro ao processar PDF: %s", e)
            flash(f"Erro ao processar PDF: {e}", "danger")
            return redirect(url_for("core.extract_from_pdf"))

    # GET -> renderiza a tela de upload
    return render_template("processes/extract_from_pdf.html")


def _launch_rpa(process_id: int | None = None) -> int:
    """
    Dispara o RPA em background passando RPA_PROCESS_ID no ambiente.
    Retorna o PID do processo filho (√∫til para log/diagn√≥stico).
    """
    project_root = Path(current_app.root_path)
    rpa_script = project_root / "rpa.py"  # ajuste se estiver em outra pasta
    if not rpa_script.exists():
        raise RuntimeError(f"Arquivo RPA n√£o encontrado: {rpa_script}")

    env = os.environ.copy()
    if process_id is not None:
        env["RPA_PROCESS_ID"] = str(process_id)

    # Pode deixar o .env decidir; forcei defaults ‚Äúvisuais‚Äù:
    env["RPA_HEADLESS"] = "true"  # For√ßa headless para rodar em backend (Linux)
    env.setdefault("RPA_KEEP_OPEN_AFTER_LOGIN_SECONDS", "10")

    logs_dir = project_root / "logs"
    logs_dir.mkdir(exist_ok=True)
    log_path = logs_dir / f"rpa_{process_id or 'latest'}.log"

    cmd = [sys.executable, "-u", str(rpa_script)]

    creationflags = 0
    if os.name == "nt":
        # use CREATE_NEW_CONSOLE se quiser ver o console do RPA
        creationflags = subprocess.CREATE_NO_WINDOW

    log_file = open(log_path, "a", encoding="utf-8")

    try:
        proc = subprocess.Popen(
            cmd,
            cwd=str(project_root),
            env=env,
            stdout=log_file,
            stderr=log_file,
            creationflags=creationflags,
            close_fds=(os.name != "nt"),
            shell=False,
        )
        return proc.pid
    except Exception:
        try:
            log_file.close()
        except Exception:
            pass
        raise


def _truthy(v):
    s = str(v).strip().lower()
    if s in {"1", "true", "t", "sim", "s", "yes", "on"}:
        return True
    if s in {"0", "false", "f", "nao", "n√£o", "n", "no", "off"}:
        return False
    return None


def _pick_uf(data: dict) -> str:
    """
    Pega UF de v√°rias fontes: 'estado', 'uf', dentro de 'comarca' (ex: 'Maca√© - RJ'),
    ou de qualquer string do payload (√∫ltimo recurso).
    """
    cand = (data.get("estado") or data.get("uf") or "").strip()
    m = re.fullmatch(r"[A-Za-z]{2}", cand)
    if m:
        return cand.upper()

    # tenta na comarca (ex.: 'Maca√© - RJ' ou 'S√£o Paulo/SP')
    for k in ("comarca", "foro", "orgao", "vara"):
        txt = (data.get(k) or "").upper()
        m = re.search(r"[-/\s]([A-Z]{2})(?:\b|$)", txt)
        if m:
            return m.group(1)

    # varre todo payload por um padr√£o de UF
    blob = " ".join(str(v) for v in data.values()).upper()
    m = re.search(r"\b([A-Z]{2})\b", blob)
    if m:
        return m.group(1)

    # √∫ltimo recurso ‚Äì escolha algo v√°lido pro seu caso
    return "RJ"


@bp.route("/processos/confirmar-extracao", methods=["GET", "POST"])
@login_required
def confirm_extracted():
    if request.method == "POST":
        # 1) mescla os dados extra√≠dos (sess√£o) com o que veio do form
        base = session.get("extracted_data", {}) or {}
        form = request.form.to_dict(flat=True)
        data = {**base, **form}

        # 2) CNJ (booleano/Sim|N√£o, conforme tipo da coluna)
        cnj_src = data.get("cnj") or data.get("cnj_sim") or data.get("is_judicial")
        cnj_bool = _truthy(cnj_src)
        if cnj_bool is None:
            cnj_bool = True if data.get("numero_processo") else False

        is_bool_cnj = False
        try:
            is_bool_cnj = (Process.__table__.c.cnj.type.python_type is bool)
        except Exception:
            pass
        cnj_db_value = cnj_bool if is_bool_cnj else ("Sim" if cnj_bool else "N√£o")

        # 3) Campos NOT NULL com fallback
        estado = _pick_uf(data)
        celula = (data.get("celula") or data.get("escritorio") or
                  data.get("cliente") or "Em Segredo").strip()

        # 4) Monte SOMENTE colunas que existem no modelo
        kwargs = {
            "owner_id": current_user.id,        # ‚úÖ sempre preencha
            "created_by": current_user.id,      # ‚úÖ exigido pelo seu schema
            "updated_by": current_user.id,      # ‚úÖ se a coluna existir

            "cnj": cnj_db_value,
            "tipo_processo": (data.get("tipo_processo") or "Eletr√¥nico").strip(),
            "numero_processo": (data.get("numero_processo") or "").strip(),
            "numero_processo_antigo": (data.get("numero_processo_antigo") or None),
            "sistema_eletronico": (data.get("sistema_eletronico") or "PJE").strip(),
            "area_direito": (data.get("area_direito") or "C√≠vel").strip(),
            "sub_area_direito": (data.get("sub_area_direito") or None),
            "estado": estado,
            "comarca": (data.get("comarca") or None),
            "numero_orgao": (data.get("numero_orgao") or "01"),
            "origem": (data.get("origem") or None),
            "orgao": (data.get("orgao") or None),
            "vara": (data.get("vara") or None),
            "celula": celula,
            "foro": (data.get("foro") or None),
            "instancia": (data.get("instancia") or "Primeira Inst√¢ncia"),
            "assunto": (data.get("assunto") or None),
            "npc": (data.get("npc") or None),
            "objeto": (data.get("objeto") or None),
            "sub_objeto": (data.get("sub_objeto") or None),
            "audiencia_inicial": (data.get("audiencia_inicial") or None),
            "link_audiencia": (data.get("link_audiencia") or None),
            "subtipo_audiencia": (data.get("subtipo_audiencia") or None),
            "envolvido_audiencia": (data.get("envolvido_audiencia") or None),
            "data_hora_cadastro_manual": (data.get("data_hora_cadastro_manual") or None),
            "cliente_parte": (data.get("cliente_parte") or None),
            "advogado_autor": (data.get("advogado_autor") or None),
            "advogado_reu": (data.get("advogado_reu") or None),
            "prazo": (data.get("prazo") or None),
            "tipo_notificacao": (data.get("tipo_notificacao") or None),
            "resultado_audiencia": (data.get("resultado_audiencia") or None),
            "prazos_derivados_audiencia": (data.get("prazos_derivados_audiencia") or None),
            "decisao_tipo": (data.get("decisao_tipo") or None),
            "decisao_resultado": (data.get("decisao_resultado") or None),
            "decisao_fundamentacao_resumida": (data.get("decisao_fundamentacao_resumida") or None),
            "id_interno_hilo": (data.get("id_interno_hilo") or None),
            "estrategia": (data.get("estrategia") or None),
            "indice_atualizacao": (data.get("indice_atualizacao") or None),
            "posicao_parte_interessada": (data.get("posicao_parte_interessada") or None),
            "parte_interessada": (data.get("parte_interessada") or None),
            "parte_adversa_tipo": (data.get("parte_adversa_tipo") or None),
            "parte_adversa_nome": (data.get("parte_adversa_nome") or None),
            "escritorio_parte_adversa": (data.get("escritorio_parte_adversa") or None),
            "uf_oab_advogado_adverso": (data.get("uf_oab_advogado_adverso") or None),
            "cpf_cnpj_parte_adversa": (data.get("cpf_cnpj_parte_adversa") or None),
            "telefone_parte_adversa": (data.get("telefone_parte_adversa") or None),
            "email_parte_adversa": (data.get("email_parte_adversa") or None),
            "endereco_parte_adversa": (data.get("endereco_parte_adversa") or None),
            "data_distribuicao": (data.get("data_distribuicao") or None),
            "data_citacao": (data.get("data_citacao") or None),
            "risco": (data.get("risco") or None),
            "valor_causa": (data.get("valor_causa") or None),
            "rito": (data.get("rito") or None),
            "observacao": (data.get("observacao") or None),
            "cadastrar_primeira_audiencia": bool(_truthy(data.get("cadastrar_primeira_audiencia") or False))
                if hasattr(Process, "cadastrar_primeira_audiencia") else None,
            
            # üîß Campos Trabalhistas
            "data_admissao": (data.get("data_admissao") or None),
            "data_demissao": (data.get("data_demissao") or None),
            "motivo_demissao": (data.get("motivo_demissao") or None),
            "salario": (data.get("salario") or None),
            "cargo_funcao": (data.get("cargo_funcao") or None),
            "cargo": (data.get("cargo") or None),
            "empregador": (data.get("empregador") or None),
            "local_trabalho": (data.get("local_trabalho") or None),
            "pis": (data.get("pis") or None),
            "ctps": (data.get("ctps") or None),
        }

        # Remove chaves que n√£o existem no modelo (evita TypeError)
        kwargs = {k: v for k, v in kwargs.items() if hasattr(Process, k)}

        # Adicionar campos adicionais
        if hasattr(Process, 'cliente'):
            kwargs['cliente'] = data.get('cliente') or None
        if hasattr(Process, 'parte'):
            kwargs['parte'] = data.get('parte') or None
        
        # CR√çTICO: Vincular PDF ao processo para evitar confus√£o de dados no RPA
        uploaded_pdf = session.get('uploaded_pdf_filename')
        if hasattr(Process, 'pdf_filename'):
            if uploaded_pdf:
                kwargs['pdf_filename'] = uploaded_pdf
                logger.info(f"[CREATE_PROCESS] PDF vinculado ao processo: {uploaded_pdf}")
            else:
                kwargs['pdf_filename'] = None
                logger.warning("[CREATE_PROCESS] Processo criado sem PDF vinculado (entrada manual)")
        
        if hasattr(Process, 'elaw_status'):
            kwargs['elaw_status'] = 'pending'

        try:
            proc = Process(**kwargs)
            db.session.add(proc)
            db.session.commit()
            
            # Limpar sess√£o ap√≥s salvar com sucesso
            if uploaded_pdf:
                session.pop('uploaded_pdf_filename', None)
                logger.info(f"[CREATE_PROCESS] Sess√£o limpa ap√≥s vincular PDF ao processo #{proc.id}")
            
            flash(f"Processo #{proc.id} salvo com sucesso!", "success")
            return redirect(url_for("core.process_view", id=proc.id))

        except SQLAlchemyError as e:
            db.session.rollback()
            flash(f"Falha ao salvar processo: {e.__class__.__name__}: {e}", "danger")

        return redirect(url_for("core.process_list"))

    # GET: exibe tela com os dados extra√≠dos
    data = session.get("extracted_data", {}) or {}
    return render_template("processes/confirm_extracted.html", data=data)

# ============================================================
# Admin
# ============================================================

def _admin_required():
    if not current_user.is_authenticated or not getattr(current_user, "is_admin", False):
        flash("Acesso permitido apenas para administradores.", "danger")
        return False
    return True


@bp.route("/admin")
@login_required
def admin_index():
    if not _admin_required():
        return redirect(url_for("core.dashboard"))
    return redirect(url_for("core.admin_users"))


@bp.route("/admin/usuarios")
@login_required
def admin_users():
    if not _admin_required():
        return redirect(url_for("core.dashboard"))
    users = User.query.order_by(User.created_at.desc()).all()
    try:
        return render_template("admin/users.html", users=users)
    except TemplateNotFound:
        rows = "".join(
            f"<tr><td>{u.id}</td><td>{u.username}</td><td>{u.email}</td><td>{'Sim' if u.is_admin else 'N√£o'}</td></tr>"
            for u in users
        )
        html = f"""
        <div class="container py-4">
          <h1>Usu√°rios</h1>
          <a class="btn btn-primary mb-3" href="{url_for('core.admin_create_user')}">Novo usu√°rio</a>
          <table class="table table-striped">
            <thead><tr><th>ID</th><th>Usu√°rio</th><th>E-mail</th><th>Admin</th></tr></thead>
            <tbody>{rows}</tbody>
          </table>
          <a class="btn btn-secondary" href="{url_for('core.dashboard')}">Voltar</a>
        </div>
        """
        return render_template_string(html)


@bp.route("/admin/usuarios/novo", methods=["GET", "POST"])
@login_required
def admin_create_user():
    if not _admin_required():
        return redirect(url_for("core.dashboard"))

    form_obj = None
    try:
        from forms import CreateUserForm
        form_obj = CreateUserForm()
    except Exception:
        form_obj = None

    if request.method == "POST":
        if form_obj and hasattr(form_obj, "validate_on_submit") and form_obj.validate_on_submit():
            username = form_obj.name.data.strip()      # seu CreateUserForm tem 'name' e 'email'
            email = form_obj.email.data.strip()
            password = form_obj.password.data
            is_admin_flag = (form_obj.role.data == "admin")
        else:
            username = (request.form.get("username") or "").strip()
            email = (request.form.get("email") or "").strip()
            password = request.form.get("password") or ""
            is_admin_flag = request.form.get("is_admin") in ["on", "true", "True", "1", 1, True]

        if not username or not email or not password:
            flash("Preencha usu√°rio, e-mail e senha.", "danger")
            try:
                return render_template("admin/create_user.html", form=form_obj)
            except TemplateNotFound:
                pass

        user = User(username=username, email=email, is_admin=is_admin_flag)
        if hasattr(user, "set_password"):
            user.set_password(password)
        else:
            from werkzeug.security import generate_password_hash
            user.password_hash = generate_password_hash(password)

        db.session.add(user)
        db.session.commit()
        flash("Usu√°rio criado com sucesso.", "success")
        return redirect(url_for("core.admin_users"))

    try:
        return render_template("admin/create_user.html", form=form_obj)
    except TemplateNotFound:
        html = f"""
        <div class="container py-4">
          <h1>Novo Usu√°rio</h1>
          <form method="POST">
            <div class="mb-3">
              <label class="form-label">Usu√°rio</label>
              <input class="form-control" name="username" required>
            </div>
            <div class="mb-3">
              <label class="form-label">E-mail</label>
              <input type="email" class="form-control" name="email" required>
            </div>
            <div class="mb-3">
              <label class="form-label">Senha</label>
              <input type="password" class="form-control" name="password" required>
            </div>
            <div class="form-check mb-3">
              <input class="form-check-input" type="checkbox" id="is_admin" name="is_admin">
              <label class="form-check-label" for="is_admin">Administrador</label>
            </div>
            <button class="btn btn-primary" type="submit">Criar</button>
            <a class="btn btn-secondary ms-2" href="{url_for('core.admin_users')}">Cancelar</a>
          </form>
        </div>
        """
        return render_template_string(html)


@bp.route("/admin/configuracoes")
@login_required
def admin_settings():
    if not _admin_required():
        return redirect(url_for("core.dashboard"))
    try:
        return render_template("admin/settings.html")
    except TemplateNotFound:
        return render_template_string(
            f'<div class="container py-4"><h1>Configura√ß√µes</h1><p>Template admin/settings.html n√£o encontrado.</p>'
            f'<a class="btn btn-secondary" href="{url_for("core.dashboard")}">Voltar</a></div>'
        )


@bp.route("/admin/auditoria")
@login_required
def admin_audit():
    if not _admin_required():
        return redirect(url_for("core.dashboard"))
    try:
        return render_template("admin/audit.html")
    except TemplateNotFound:
        return render_template_string(
            f'<div class="container py-4"><h1>Auditoria</h1><p>Template admin/audit.html n√£o encontrado.</p>'
            f'<a class="btn btn-secondary" href="{url_for("core.dashboard")}">Voltar</a></div>'
        )


# ============================================================
# Endpoints RPA - Status em Tempo Real
# ============================================================

@bp.route("/api/rpa-status/<int:process_id>")
@login_required
def api_rpa_status(process_id):
    """Endpoint REST que retorna status do RPA em JSON para polling"""
    from rpa_status import get_rpa_status
    
    # üîß 2025-11-27: FOR√áAR dados frescos do banco (evitar cache de sess√£o SQLAlchemy)
    db.session.expire_all()
    
    # Verifica se o usu√°rio tem permiss√£o para ver este processo
    process = Process.query.get_or_404(process_id)
    if process.owner_id != current_user.id and not current_user.is_admin:
        return jsonify({"error": "Acesso negado"}), 403
    
    status = get_rpa_status(process_id)
    
    if not status:
        return jsonify({
            "process_id": process_id,
            "status": "not_started",
            "message": "RPA ainda n√£o iniciado"
        })
    
    return jsonify(status)


@bp.route("/api/process/<int:process_id>/details")
@login_required
def api_process_details(process_id):
    """Endpoint REST que retorna dados completos do processo incluindo screenshots"""
    # Buscar processo
    process = Process.query.get_or_404(process_id)
    
    # Verifica permiss√£o
    if process.owner_id != current_user.id and not current_user.is_admin:
        return jsonify({"error": "Acesso negado"}), 403
    
    # Retornar dados incluindo screenshots
    return jsonify({
        "id": process.id,
        "numero_processo": process.numero_processo,
        "elaw_status": process.elaw_status,
        "elaw_error_message": process.elaw_error_message,
        "elaw_screenshot_before_path": process.elaw_screenshot_before_path,
        "elaw_screenshot_after_path": process.elaw_screenshot_after_path,
        "elaw_filled_at": process.elaw_filled_at.isoformat() if process.elaw_filled_at else None
    })


@bp.route("/processos/<int:process_id>/rpa-progress")
@login_required
def rpa_progress(process_id):
    """Tela de loading din√¢mica mostrando progresso do RPA em tempo real"""
    process = Process.query.get_or_404(process_id)
    batch_id = request.args.get('batch_id', type=int)
    
    # Verifica permiss√£o
    if process.owner_id != current_user.id and not current_user.is_admin:
        flash("Acesso negado.", "danger")
        return redirect(url_for("core.process_list"))
    
    try:
        return render_template(
            "processes/rpa_progress.html",
            process=process,
            process_id=process_id,
            batch_id=batch_id
        )
    except TemplateNotFound:
        # Fallback inline se template n√£o existir ainda
        return render_template_string("""
            <!DOCTYPE html>
            <html>
            <head>
                <title>Processando RPA...</title>
                <meta charset="utf-8">
                <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
                <style>
                    .spinner { animation: spin 1s linear infinite; }
                    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
                    .progress-item { padding: 0.5rem; border-left: 3px solid #dee2e6; margin-bottom: 0.5rem; }
                    .progress-item.active { border-left-color: #0d6efd; background-color: #e7f1ff; }
                    .progress-item.completed { border-left-color: #198754; }
                    .progress-item.error { border-left-color: #dc3545; }
                </style>
            </head>
            <body class="bg-light">
                <div class="container py-5">
                    <div class="card shadow">
                        <div class="card-header bg-primary text-white">
                            <h4 class="mb-0">
                                <span class="spinner me-2">‚è≥</span> Processo {{ process_id }}
                            </h4>
                        </div>
                        <div class="card-body">
                            <div id="status-message" class="alert alert-info">
                                <strong>Iniciando RPA...</strong>
                            </div>
                            <div id="progress-history" class="mt-3"></div>
                        </div>
                    </div>
                </div>
                
                <script>
                    const processId = {{ process_id }};
                    const pollInterval = 1500; // 1.5 segundos
                    const maxDuration = 300000; // 5 minutos timeout
                    let startTime = Date.now();
                    
                    async function checkStatus() {
                        try {
                            const response = await fetch(`/api/rpa-status/${processId}`);
                            const data = await response.json();
                            
                            // Atualiza mensagem principal
                            const statusMsg = document.getElementById('status-message');
                            statusMsg.className = `alert alert-${getAlertClass(data.status)}`;
                            statusMsg.innerHTML = `<strong>${data.current_step || 'Processando'}</strong><br>${data.message || ''}`;
                            
                            // Atualiza hist√≥rico
                            if (data.history && data.history.length > 0) {
                                updateHistory(data.history);
                            }
                            
                            // Verifica se terminou
                            if (data.status === 'completed') {
                                statusMsg.innerHTML += '<br><br><div class="spinner-border spinner-border-sm me-2"></div>Redirecionando...';
                                setTimeout(() => {
                                    window.location.href = '/processos';
                                }, 2000);
                                return;
                            } else if (data.status === 'error') {
                                statusMsg.innerHTML += '<br><a href="/processos" class="btn btn-sm btn-secondary mt-2">Voltar para lista</a>';
                                return;
                            }
                            
                            // Continua polling
                            if (Date.now() - startTime < maxDuration) {
                                setTimeout(checkStatus, pollInterval);
                            } else {
                                statusMsg.className = 'alert alert-warning';
                                statusMsg.innerHTML = '<strong>Timeout</strong><br>O RPA est√° demorando mais do que o esperado. <a href="/processos">Voltar</a>';
                            }
                        } catch (error) {
                            console.error('Erro ao verificar status:', error);
                            setTimeout(checkStatus, pollInterval * 2);
                        }
                    }
                    
                    function getAlertClass(status) {
                        switch(status) {
                            case 'completed': return 'success';
                            case 'error': return 'danger';
                            case 'running': return 'info';
                            default: return 'secondary';
                        }
                    }
                    
                    function updateHistory(history) {
                        const container = document.getElementById('progress-history');
                        container.innerHTML = '<h6 class="text-muted mb-3">Hist√≥rico:</h6>';
                        history.forEach((item, index) => {
                            const div = document.createElement('div');
                            div.className = 'progress-item' + (index === history.length - 1 ? ' active' : ' completed');
                            const time = new Date(item.timestamp).toLocaleTimeString('pt-BR');
                            const dataStr = item.data && Object.keys(item.data).length > 0 ? 
                                ` - ${JSON.stringify(item.data)}` : '';
                            div.innerHTML = `<small class="text-muted">${time}</small><br><strong>${item.step}</strong>: ${item.message}${dataStr}`;
                            container.appendChild(div);
                        });
                    }
                    
                    // Inicia polling
                    checkStatus();
                </script>
            </body>
            </html>
        """, process=process, process_id=process_id)



================================================================================
FILE: routes_batch.py
================================================================================
"""
Rotas para processamento em lote de PDFs
"""
import os
import json
import logging
from datetime import datetime
from pathlib import Path
from werkzeug.utils import secure_filename
from flask import Blueprint, request, render_template, redirect, url_for, flash, jsonify, send_from_directory
from flask_login import login_required, current_user
from extensions import db
from models import BatchUpload, BatchItem, Process

logger = logging.getLogger(__name__)

# Integra√ß√£o com monitor remoto
try:
    from monitor_integration import log_info, log_error
    MONITOR_AVAILABLE = True
except ImportError:
    MONITOR_AVAILABLE = False
    def log_info(msg, region=""): pass
    def log_error(msg, exc=None, region=""): pass

batch_bp = Blueprint("batch", __name__, url_prefix="/processos/batch")

# Configura√ß√µes
ALLOWED_EXTENSIONS = {'pdf'}
MAX_FILE_SIZE = 16 * 1024 * 1024  # 16MB por arquivo
MAX_FILES_PER_BATCH = 20  # M√°ximo de PDFs por batch


# =============================================================================
# Fun√ß√£o de Limpeza de Processos Travados
# =============================================================================
def cleanup_stuck_processes():
    """
    Detecta e cancela processos batch que est√£o travados h√° mais de 10 minutos.
    Chamada automaticamente durante opera√ß√µes batch ou manualmente via endpoint.
    
    Returns:
        int: N√∫mero de processos cancelados
    """
    from datetime import timedelta
    
    try:
        timeout_threshold = datetime.utcnow() - timedelta(minutes=10)
        
        # Buscar items travados
        stuck_items = BatchItem.query.filter(
            BatchItem.status == 'running',
            BatchItem.updated_at < timeout_threshold
        ).all()
        
        if not stuck_items:
            return 0
        
        logger.warning(f"[CLEANUP] Detectados {len(stuck_items)} processos travados")
        
        for item in stuck_items:
            logger.warning(f"[CLEANUP] Cancelando item #{item.id} (batch #{item.batch_id}) travado desde {item.updated_at}")
            
            # Resetar item
            item.status = 'error'
            item.last_error = f'Processo travado (timeout > 10min). √öltima atualiza√ß√£o: {item.updated_at}'
            
            # Resetar processo associado
            if item.process_id:
                process = Process.query.get(item.process_id)
                if process and process.elaw_status == 'running':
                    process.elaw_status = 'error'
                    process.elaw_error_message = 'RPA travado (timeout > 10min)'
        
        db.session.commit()
        logger.info(f"[CLEANUP] ‚úÖ {len(stuck_items)} processos travados foram cancelados")
        return len(stuck_items)
        
    except Exception as e:
        logger.error(f"[CLEANUP] Erro ao limpar processos travados: {e}", exc_info=True)
        db.session.rollback()
        return 0

def reset_sequence_if_empty(table_name: str):
    """
    Reseta a sequ√™ncia de IDs de uma tabela se ela estiver vazia.
    Isso permite que os IDs comecem novamente do 1.
    
    Args:
        table_name: Nome da tabela ('batch_upload', 'process', 'batch_item')
    """
    from sqlalchemy import text
    
    try:
        result = db.session.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
        count = result.scalar()
        
        if count == 0:
            sequence_name = f"{table_name}_id_seq"
            db.session.execute(text(f"ALTER SEQUENCE {sequence_name} RESTART WITH 1"))
            db.session.commit()
            logger.info(f"[RESET_SEQ] ‚úÖ Sequ√™ncia {sequence_name} resetada para 1")
            return True
    except Exception as e:
        logger.warning(f"[RESET_SEQ] N√£o foi poss√≠vel resetar sequ√™ncia de {table_name}: {e}")
        db.session.rollback()
    
    return False


def reset_all_sequences_if_empty():
    """
    Verifica e reseta sequ√™ncias de todas as tabelas principais se estiverem vazias.
    Chamada ap√≥s dele√ß√µes em massa.
    """
    reset_sequence_if_empty('batch_upload')
    reset_sequence_if_empty('batch_item')
    reset_sequence_if_empty('process')


def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


def _create_process_from_data(data, user_id):
    """Helper para criar Process a partir de dados extra√≠dos"""
    from models import Process
    from datetime import datetime
    
    # Debug logging
    logger.debug(f"[CREATE_PROCESS] data type: {type(data)}, user_id: {user_id}")
    if not data:
        logger.error("[CREATE_PROCESS] ‚ùå data √© None ou vazio!")
        raise ValueError("Dados extra√≠dos s√£o None ou vazios")
    if not user_id:
        logger.error("[CREATE_PROCESS] ‚ùå user_id √© None!")
        raise ValueError("user_id n√£o pode ser None")
    
    # CNJ - ‚úÖ CORRIGIDO: campo cnj √© String(3) para "Sim"/"N√£o", n√∫mero vai para numero_processo
    cnj_sim_nao = "Sim" if data.get("numero_processo") else "N√£o"
    numero_processo_value = data.get("numero_processo", "").strip()
    
    # Estado
    estado = data.get("estado", "").strip() or "SP"
    
    # C√©lula
    celula = (data.get("celula") or data.get("escritorio") or 
             data.get("cliente") or "Em Segredo").strip()
    
    logger.debug(f"[CREATE_PROCESS] Criando processo para user_id={user_id}, numero={numero_processo_value}")
    
    # Criar processo
    proc = Process(
        owner_id=user_id,
        created_by=user_id,
        updated_by=user_id,
        cnj=cnj_sim_nao,
        tipo_processo=(data.get("tipo_processo") or "Eletr√¥nico").strip(),
        numero_processo=numero_processo_value,
        sistema_eletronico=(data.get("sistema_eletronico") or "PJE").strip(),
        area_direito=(data.get("area_direito") or "Trabalhista").strip(),
        sub_area_direito=data.get("sub_area_direito"),
        estado=estado,
        comarca=data.get("comarca"),
        numero_orgao=data.get("numero_orgao", "01"),
        origem=data.get("origem"),
        orgao=data.get("orgao"),
        vara=data.get("vara"),
        celula=celula,
        foro=data.get("foro"),
        instancia=data.get("instancia", "Primeira Inst√¢ncia"),
        assunto=data.get("assunto"),
        objeto=data.get("objeto"),
        sub_objeto=data.get("sub_objeto"),
        cliente=data.get("cliente"),
        parte=data.get("parte"),
        valor_causa=data.get("valor_causa"),
        data_distribuicao=data.get("data_distribuicao"),
        audiencia_inicial=data.get("audiencia_inicial"),
        cadastrar_primeira_audiencia=data.get("cadastrar_primeira_audiencia", False),
        link_audiencia=data.get("link_audiencia"),
        subtipo_audiencia=data.get("subtipo_audiencia"),
        envolvido_audiencia=data.get("envolvido_audiencia"),
        outra_reclamada_cliente=data.get("outra_reclamada_cliente"),
        parte_interessada=data.get("parte_interessada"),
        posicao_parte_interessada=data.get("posicao_parte_interessada"),
        parte_adversa_nome=data.get("parte_adversa_nome"),
        parte_adversa_tipo=data.get("parte_adversa_tipo"),
        cpf_cnpj_parte_adversa=data.get("cpf_cnpj_parte_adversa"),
        data_admissao=data.get("data_admissao"),
        data_demissao=data.get("data_demissao"),
        motivo_demissao=data.get("motivo_demissao"),
        salario=data.get("salario"),
        cargo_funcao=data.get("cargo_funcao") or data.get("cargo"),
        empregador=data.get("empregador"),
        local_trabalho=data.get("local_trabalho"),
        pis=data.get("pis"),
        ctps=data.get("ctps"),
        pdf_filename=data.get("pdf_filename"),
        pedidos_json=json.dumps(data.get("pedidos", [])) if data.get("pedidos") else None
    )
    db.session.add(proc)
    db.session.flush()
    
    logger.debug(f"[CREATE_PROCESS] ‚úÖ Processo criado com ID: {proc.id}")
    return proc.id


# =============================================================================
# Configura√ß√£o de Processamento Paralelo
# =============================================================================
MAX_EXTRACTION_WORKERS = 5  # üîß Balanceado: 5 workers para estabilidade
# 2025-12-03: Reduzido para 3 workers em produ√ß√£o para evitar falta de recursos
# Em desenvolvimento pode usar 5, mas produ√ß√£o Replit tem recursos limitados
_DEFAULT_RPA_WORKERS = 3 if os.getenv("REPL_DEPLOYMENT") else 5
MAX_RPA_WORKERS = int(os.getenv("MAX_RPA_WORKERS", str(_DEFAULT_RPA_WORKERS)))


def _extract_single_item(item_id: int, upload_path: str, source_filename: str, user_id: int) -> dict:
    """
    Extrai dados de um √∫nico PDF de forma thread-safe.
    
    Cada thread tem sua pr√≥pria sess√£o do banco de dados para evitar conflitos.
    
    Args:
        item_id: ID do BatchItem
        upload_path: Caminho do arquivo PDF
        source_filename: Nome original do arquivo
        user_id: ID do usu√°rio dono do batch
        
    Returns:
        dict com resultado: {'item_id': int, 'success': bool, 'process_id': int|None, 'error': str|None}
    """
    from main import app
    from extractors.pipeline import run_extraction_from_file
    
    result = {
        'item_id': item_id,
        'success': False,
        'process_id': None,
        'error': None
    }
    
    try:
        logger.info(f"[EXTRACT][THREAD] Iniciando extra√ß√£o do item {item_id}: {source_filename}")
        
        # ‚úÖ CR√çTICO: Cada thread precisa de seu pr√≥prio app_context para sess√£o DB isolada
        with app.app_context():
            # Atualizar status para 'extracting'
            item = BatchItem.query.get(item_id)
            if not item:
                result['error'] = f'Item {item_id} n√£o encontrado'
                logger.error(f"[EXTRACT][THREAD] {result['error']}")
                return result
            
            item.status = 'extracting'
            item.updated_at = datetime.utcnow()
            db.session.commit()
            
            # Extrair dados do PDF
            extracted_data = run_extraction_from_file(
                path=upload_path,
                filename=source_filename
            )
            
            if extracted_data:
                # ‚úÖ CR√çTICO: Incluir pdf_filename para permitir extra√ß√£o de reclamadas no RPA
                extracted_data["pdf_filename"] = upload_path
                
                # Criar processo no banco
                process_id = _create_process_from_data(extracted_data, user_id)
                
                # Atualizar item com sucesso
                item.process_id = process_id
                item.status = 'ready'
                item.updated_at = datetime.utcnow()
                db.session.commit()
                
                result['success'] = True
                result['process_id'] = process_id
                logger.info(f"[EXTRACT][THREAD] ‚úÖ Item {item_id} processado! Process ID: {process_id}")
            else:
                item.status = 'error'
                item.last_error = 'Falha na extra√ß√£o de dados'
                item.updated_at = datetime.utcnow()
                db.session.commit()
                
                result['error'] = 'Falha na extra√ß√£o de dados'
                logger.warning(f"[EXTRACT][THREAD] ‚ùå Erro na extra√ß√£o do item {item_id}")
                
    except Exception as ex:
        import traceback
        tb = traceback.format_exc()
        logger.error(f"[EXTRACT][THREAD] ‚ùå Exce√ß√£o ao processar item {item_id}: {ex}")
        logger.error(f"[EXTRACT][THREAD][TRACEBACK] {tb}")
        
        result['error'] = str(ex)[:500]
        
        # Tentar atualizar status no banco
        try:
            with app.app_context():
                item = BatchItem.query.get(item_id)
                if item:
                    item.status = 'error'
                    item.last_error = result['error']
                    item.updated_at = datetime.utcnow()
                    db.session.commit()
        except Exception as db_ex:
            logger.error(f"[EXTRACT][THREAD] Erro ao atualizar status do item {item_id}: {db_ex}")
    
    return result


def process_batch_async(batch_id, user_id):
    """
    Processa batch em thread separada com extra√ß√£o PARALELA de PDFs.
    
    Usa ThreadPoolExecutor para processar m√∫ltiplos PDFs simultaneamente,
    melhorando significativamente o tempo de processamento de batches grandes.
    """
    from main import app
    from concurrent.futures import ThreadPoolExecutor, as_completed
    import threading
    
    with app.app_context():
        batch = BatchUpload.query.get(batch_id)
        if not batch:
            logger.error(f"Batch {batch_id} n√£o encontrado!")
            return
        
        logger.info(f"[BATCH] Iniciando processamento PARALELO do batch {batch_id}")
        batch.status = 'processing'
        db.session.commit()
        
        # Coletar itens pendentes
        pending_items = BatchItem.query.filter_by(batch_id=batch_id, status='pending').all()
        total_items = len(pending_items)
        logger.info(f"[BATCH] {total_items} itens pendentes para processar em paralelo (max {MAX_EXTRACTION_WORKERS} workers)")
        
        if total_items == 0:
            batch.status = 'ready'
            batch.finished_at = datetime.utcnow()
            db.session.commit()
            logger.info(f"[BATCH] Batch {batch_id} sem itens pendentes")
            return
        
        # Preparar dados para processamento paralelo (evitar passar objetos SQLAlchemy entre threads)
        items_data = [
            {
                'item_id': item.id,
                'upload_path': item.upload_path,
                'source_filename': item.source_filename
            }
            for item in pending_items
        ]
        
        processed = 0
        errors = 0
        
        # ‚úÖ Processar em paralelo usando ThreadPoolExecutor
        with ThreadPoolExecutor(max_workers=MAX_EXTRACTION_WORKERS) as executor:
            # Submeter todas as tarefas
            future_to_item = {
                executor.submit(
                    _extract_single_item,
                    item_data['item_id'],
                    item_data['upload_path'],
                    item_data['source_filename'],
                    user_id
                ): item_data
                for item_data in items_data
            }
            
            logger.info(f"[BATCH] {len(future_to_item)} tarefas submetidas ao executor")
            
            # üöÄ PLANO BATMAN: Timeout de 45s por PDF para evitar travamentos (aumentado para PDFs grandes)
            EXTRACTION_TIMEOUT = 45  # segundos
            
            # üÜï Usar as_completed com timeout global para detectar travamentos
            import time
            start_time = time.time()
            MAX_BATCH_TIME = 300  # 5 minutos m√°ximo para todo o batch
            
            # Processar resultados √† medida que ficam prontos
            for future in as_completed(future_to_item, timeout=MAX_BATCH_TIME):
                item_data = future_to_item[future]
                
                try:
                    result = future.result(timeout=EXTRACTION_TIMEOUT)
                    
                    if result['success']:
                        processed += 1
                        logger.info(f"[BATCH] ‚úÖ Conclu√≠do: item {result['item_id']} -> process {result['process_id']}")
                    else:
                        errors += 1
                        logger.warning(f"[BATCH] ‚ùå Falhou: item {result['item_id']} -> {result['error']}")
                    
                    # Atualizar progresso do batch em tempo real
                    batch.processed_count = processed + errors
                    db.session.commit()
                    
                    logger.info(f"[BATCH] Progresso: {processed + errors}/{total_items} ({processed} sucesso, {errors} erros)")
                
                except (TimeoutError, Exception) as ex:
                    errors += 1
                    error_type = "TIMEOUT" if "Timeout" in str(type(ex).__name__) else "ERRO"
                    logger.error(f"[BATCH] ‚è±Ô∏è {error_type}: item {item_data['item_id']} - {ex}")
                    
                    # Marcar item como erro
                    try:
                        timeout_item = BatchItem.query.get(item_data['item_id'])
                        if timeout_item and timeout_item.status == 'extracting':
                            timeout_item.status = 'error'
                            timeout_item.last_error = f'{error_type}: {str(ex)[:200]}'
                            db.session.commit()
                    except Exception:
                        pass
            
            # üÜï Verificar se h√° itens ainda em 'extracting' (travados) e marcar como erro
            stuck_items = BatchItem.query.filter_by(batch_id=batch_id, status='extracting').all()
            for stuck in stuck_items:
                stuck.status = 'error'
                stuck.last_error = 'Travou durante processamento'
                errors += 1
                logger.error(f"[BATCH] ‚ö†Ô∏è Item {stuck.id} estava travado em 'extracting' - marcado como erro")
            if stuck_items:
                db.session.commit()
        
        # Finalizar batch com status correto para permitir RPA
        # ready = todos extra√≠dos com sucesso
        # partial_ready = alguns extra√≠dos, alguns erros (ainda pode iniciar RPA)
        # error = todos falharam
        if errors == 0:
            batch.status = 'ready'
        elif processed > 0:
            batch.status = 'partial_ready'  # Permite iniciar RPA para os que funcionaram
        else:
            batch.status = 'error'
        
        batch.processed_count = processed + errors
        batch.finished_at = datetime.utcnow()
        db.session.commit()
        
        logger.info(f"[BATCH] ‚úÖ Batch {batch_id} finalizado: status={batch.status}, {processed} sucesso(s), {errors} erro(s) em {total_items} itens")


@batch_bp.route("/new", methods=["GET", "POST"])
@login_required
def batch_new():
    """Upload de m√∫ltiplos PDFs"""
    if request.method == "POST":
        files = request.files.getlist('pdfs')
        
        if not files or len(files) == 0:
            flash("Nenhum arquivo selecionado.", "danger")
            return redirect(request.url)
        
        if len(files) > MAX_FILES_PER_BATCH:
            flash(f"M√°ximo de {MAX_FILES_PER_BATCH} arquivos por vez.", "danger")
            return redirect(request.url)
        
        # Validar arquivos
        valid_files = []
        total_size = 0
        MAX_TOTAL_SIZE = 350 * 1024 * 1024  # 350MB total
        
        for file in files:
            if file.filename == '':
                continue
            
            if not allowed_file(file.filename):
                flash(f"Arquivo '{file.filename}' n√£o √© um PDF v√°lido.", "danger")
                return redirect(request.url)
            
            # Verificar tamanho (aproximado)
            file.seek(0, os.SEEK_END)
            size = file.tell()
            file.seek(0)
            
            if size > MAX_FILE_SIZE:
                flash(f"Arquivo '{file.filename}' excede {MAX_FILE_SIZE // (1024*1024)}MB.", "danger")
                return redirect(request.url)
            
            total_size += size
            valid_files.append(file)
        
        # Verificar limite total
        if total_size > MAX_TOTAL_SIZE:
            total_mb = total_size / (1024 * 1024)
            flash(f"Tamanho total dos arquivos ({total_mb:.1f}MB) excede o limite de 350MB.", "danger")
            return redirect(request.url)
        
        if not valid_files:
            flash("Nenhum arquivo v√°lido para processar.", "danger")
            return redirect(request.url)
        
        try:
            # üöÄ PLANO BATMAN: Ler arquivos para mem√≥ria PRIMEIRO (inevit√°vel com Flask)
            # Depois redirecionar IMEDIATAMENTE e processar em background
            file_data = []
            for file in valid_files:
                filename = secure_filename(file.filename)
                content = file.read()  # L√™ para mem√≥ria (necess√°rio antes do redirect)
                file_data.append((filename, content))
            
            # Criar batch
            batch = BatchUpload(
                owner_id=current_user.id,
                status='uploading',
                total_count=len(file_data)
            )
            db.session.add(batch)
            db.session.flush()  # Obter batch.id
            
            # Criar diret√≥rio para este batch
            batch_dir = Path('uploads') / 'batch' / str(batch.id)
            batch_dir.mkdir(parents=True, exist_ok=True)
            
            # Criar BatchItems ANTES de salvar (para mostrar na tela)
            for filename, _ in file_data:
                item = BatchItem(
                    batch_id=batch.id,
                    source_filename=filename,
                    upload_path=str(batch_dir / filename),
                    status='uploading'
                )
                db.session.add(item)
            
            batch.status = 'pending'
            db.session.commit()
            
            # üöÄ TUDO EM BACKGROUND: Salvar arquivos + extrair
            import threading
            
            def save_and_process(batch_id, user_id, file_data_list, batch_dir_str):
                """Salva arquivos e processa tudo em background"""
                from main import app
                from concurrent.futures import ThreadPoolExecutor
                
                with app.app_context():
                    try:
                        batch_dir_path = Path(batch_dir_str)
                        
                        # Salvar arquivos em paralelo
                        def save_file(args):
                            fname, content = args
                            fpath = batch_dir_path / fname
                            with open(str(fpath), 'wb') as f:
                                f.write(content)
                            return fname, str(fpath)
                        
                        with ThreadPoolExecutor(max_workers=5) as executor:
                            list(executor.map(save_file, file_data_list))
                        
                        logger.info(f"[BATCH] {len(file_data_list)} arquivos salvos em disco")
                        
                        # Atualizar status dos items para 'pending'
                        items = BatchItem.query.filter_by(batch_id=batch_id).all()
                        for item in items:
                            item.status = 'pending'
                        db.session.commit()
                        
                        # Agora processar extra√ß√£o
                        process_batch_async(batch_id, user_id)
                        
                    except Exception as e:
                        logger.error(f"[BATCH] Erro no background: {e}")
            
            thread = threading.Thread(
                target=save_and_process, 
                args=(batch.id, current_user.id, file_data, str(batch_dir))
            )
            thread.daemon = True
            thread.start()
            logger.info(f"[BATCH] Thread de upload+processamento iniciada para batch {batch.id}")
            
            # Toast de sucesso
            flash(f"Batch criado! {len(file_data)} arquivo(s) sendo enviados e processados.", "success")
            
            # Redirecionar IMEDIATAMENTE para tela de progresso
            return redirect(url_for('batch.batch_progress', id=batch.id))
        
        except Exception as e:
            db.session.rollback()
            logger.error(f"Erro ao criar batch: {e}")
            flash(f"Erro ao processar arquivos: {str(e)}", "danger")
            return redirect(request.url)
    
    return render_template("processes/batch_upload.html")


@batch_bp.route("/list")
@login_required
def batch_list():
    """Lista todos os batches do usu√°rio"""
    batches = BatchUpload.query.filter_by(owner_id=current_user.id).order_by(BatchUpload.created_at.desc()).all()
    return render_template("processes/batch_list.html", batches=batches)


@batch_bp.route("/<int:id>")
@login_required
def batch_detail(id):
    """Detalhes de um batch"""
    from models import Process
    batch = BatchUpload.query.get_or_404(id)
    
    # Verificar permiss√£o
    if batch.owner_id != current_user.id:
        flash("Voc√™ n√£o tem permiss√£o para acessar este batch.", "danger")
        return redirect(url_for('batch.batch_list'))
    
    # Carregar items com eager loading dos processos - ordenar por process_id para exibi√ß√£o sequencial
    items = BatchItem.query.filter_by(batch_id=id).order_by(BatchItem.process_id.asc().nullslast()).all()
    
    # Carregar processos para cada item (eager loading manual)
    for item in items:
        if item.process_id:
            item.process = Process.query.get(item.process_id)
        else:
            item.process = None
    
    return render_template("processes/batch_detail.html", batch=batch, items=items)


@batch_bp.route("/<int:id>/progress")
@login_required
def batch_progress(id):
    """Tela de progresso do processamento em lote"""
    batch = BatchUpload.query.get_or_404(id)
    
    # Verificar permiss√£o
    if batch.owner_id != current_user.id:
        flash("Voc√™ n√£o tem permiss√£o para acessar este batch.", "danger")
        return redirect(url_for('batch.batch_list'))
    
    return render_template("processes/batch_progress.html", batch_id=batch.id)


@batch_bp.route("/<int:id>/progress-status")
@login_required
def batch_progress_status(id):
    """Retorna status do progresso (JSON para polling)"""
    # üîß 2025-11-27: FOR√áAR dados frescos do banco (evitar cache de sess√£o SQLAlchemy)
    db.session.expire_all()
    
    batch = BatchUpload.query.get_or_404(id)
    
    # Verificar permiss√£o
    if batch.owner_id != current_user.id:
        return jsonify({'error': 'Permiss√£o negada'}), 403
    
    items = BatchItem.query.filter_by(batch_id=id).order_by(BatchItem.process_id.asc().nullslast()).all()
    
    # Encontrar arquivo sendo processado atualmente
    current_file = None
    for item in items:
        if item.status == 'extracting':
            current_file = item.source_filename
            break
    
    return jsonify({
        'batch_id': batch.id,
        'status': batch.status,
        'total_count': batch.total_count,
        'processed_count': sum(1 for item in items if item.status in ['ready', 'success', 'error']),
        'current_file': current_file,
        'items': [
            {
                'id': item.id,
                'filename': item.source_filename,
                'status': item.status,
                'process_id': item.process_id,
                'last_error': item.last_error
            }
            for item in items
        ]
    })


def _execute_single_rpa(item_id: int, process_id: int, worker_id: int = 0) -> dict:
    """
    Executa RPA para um √∫nico processo de forma thread-safe.
    
    üÜï 2025-11-27: Usa a nova fun√ß√£o execute_rpa_parallel() que:
    - Usa contextvars (thread-local) em vez de globals
    - Permite execu√ß√µes paralelas via sem√°foro
    - Cada worker tem seu pr√≥prio browser isolado
    
    Args:
        item_id: ID do BatchItem
        process_id: ID do Process a ser processado
        worker_id: ID do worker no ThreadPoolExecutor
        
    Returns:
        dict com resultado: {'item_id': int, 'process_id': int, 'success': bool, 'error': str|None}
    """
    from main import app
    import rpa
    
    # ‚úÖ CR√çTICO: Garantir que flask_app est√° dispon√≠vel para verifica√ß√£o de status
    if not rpa.flask_app:
        rpa.flask_app = app._get_current_object() if hasattr(app, '_get_current_object') else app
    
    result = {
        'item_id': item_id,
        'process_id': process_id,
        'worker_id': worker_id,
        'success': False,
        'error': None
    }
    
    try:
        logger.info(f"[RPA][WORKER-{worker_id}] Iniciando RPA para item {item_id}, processo {process_id}")
        
        # ‚úÖ CR√çTICO: Cada thread precisa de seu pr√≥prio app_context para sess√£o DB isolada
        with app.app_context():
            # Atualizar status para 'running'
            item = BatchItem.query.get(item_id)
            if not item:
                result['error'] = f'Item {item_id} n√£o encontrado'
                logger.error(f"[RPA][WORKER-{worker_id}] {result['error']}")
                return result
            
            item.status = 'running'
            item.attempt_count += 1
            item.updated_at = datetime.utcnow()
            db.session.commit()
            
            # ‚úÖ CR√çTICO: Limpar sess√£o ANTES de chamar RPA para evitar conflitos
            db.session.remove()
        
        # üÜï Executar RPA PARALELO (fora do app_context, usa seu pr√≥prio contexto interno)
        logger.info(f"[RPA][WORKER-{worker_id}] Executando execute_rpa_parallel({process_id}, worker_id={worker_id})")
        rpa_result = rpa.execute_rpa_parallel(process_id, worker_id=worker_id)
        logger.info(f"[RPA][WORKER-{worker_id}] execute_rpa_parallel retornou: {rpa_result}")
        
        # Atualizar BatchItem com resultado (nova sess√£o limpa)
        with app.app_context():
            item = BatchItem.query.get(item_id)
            if item:
                if rpa_result.get('status') == 'success':
                    item.status = 'success'
                    item.last_error = None
                    result['success'] = True
                    logger.info(f"[RPA][WORKER-{worker_id}] ‚úÖ Item {item_id} processado com sucesso!")
                else:
                    item.status = 'error'
                    item.last_error = rpa_result.get('error', rpa_result.get('message', 'Erro desconhecido'))[:500]
                    result['error'] = item.last_error
                    logger.warning(f"[RPA][WORKER-{worker_id}] ‚ùå Item {item_id} com erro: {item.last_error}")
                
                item.updated_at = datetime.utcnow()
                db.session.commit()
            
            # ‚úÖ CR√çTICO: Limpar sess√£o ap√≥s uso
            db.session.remove()
                
    except Exception as ex:
        import traceback
        tb = traceback.format_exc()
        logger.error(f"[RPA][WORKER-{worker_id}] ‚ùå Exce√ß√£o ao processar item {item_id}: {ex}")
        logger.error(f"[RPA][WORKER-{worker_id}][TRACEBACK] {tb}")
        
        result['error'] = str(ex)[:500]
        
        # Tentar atualizar status no banco
        try:
            with app.app_context():
                item = BatchItem.query.get(item_id)
                if item:
                    item.status = 'error'
                    item.last_error = result['error']
                    item.updated_at = datetime.utcnow()
                    db.session.commit()
                db.session.remove()
        except Exception as db_ex:
            logger.error(f"[RPA][WORKER-{worker_id}] Erro ao atualizar status do item {item_id}: {db_ex}")
    
    return result


@batch_bp.route("/<int:id>/start", methods=["POST"])
@login_required
def batch_start(id):
    """Inicia processamento RPA do batch com execu√ß√£o PARALELA"""
    try:
        # üîß Limpeza autom√°tica de processos travados antes de iniciar
        cleaned = cleanup_stuck_processes()
        if cleaned > 0:
            logger.info(f"[BATCH START] Limpou {cleaned} processos travados antes de iniciar")
        
        batch = BatchUpload.query.get(id)
        if not batch:
            return jsonify({'success': False, 'error': 'Batch n√£o encontrado'}), 404
        
        # Verificar permiss√£o
        if batch.owner_id != current_user.id:
            return jsonify({'success': False, 'error': 'Permiss√£o negada'}), 403
        
        # Verificar se batch est√° pronto (permite reprocessar batches com erro que t√™m itens ready)
        if batch.status not in ['ready', 'partial_ready', 'partial_completed', 'completed', 'error']:
            return jsonify({'success': False, 'error': f'Batch n√£o est√° pronto (status: {batch.status})'}), 400
        
        # Se batch est√° em error, verificar se h√° itens prontos para processar
        if batch.status == 'error':
            ready_items = BatchItem.query.filter_by(batch_id=id, status='ready').count()
            if ready_items == 0:
                return jsonify({'success': False, 'error': 'Batch com erro n√£o possui itens prontos para reprocessar'}), 400
            logger.info(f"[BATCH START] Batch {id} em erro ser√° reprocessado ({ready_items} itens ready)")
        
        # Verificar se j√° est√° rodando
        if batch.lock_owner:
            return jsonify({'success': False, 'error': 'Batch j√° est√° sendo processado'}), 409
    
    except Exception as e:
        logger.error(f"Erro ao validar batch {id}: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500
    
    try:
        # Executar RPA em thread separada (n√£o bloqueante)
        import threading
        from main import app
        import rpa
        from concurrent.futures import ThreadPoolExecutor, as_completed
        
        # ‚úÖ CRITICAL: Definir flask_app ANTES da thread para garantir disponibilidade no RPA
        rpa.flask_app = app._get_current_object() if hasattr(app, '_get_current_object') else app
        logger.info(f"[BATCH RPA] Flask app configurado globalmente para RPA")
        
        def execute_batch_rpa_parallel():
            """Executa RPA batch em PARALELO com ThreadPoolExecutor"""
            logger.info(f"[BATCH RPA][PARALLEL] Thread principal iniciada para batch {id}")
            
            try:
                with app.app_context():
                    try:
                        logger.info(f"[BATCH RPA] Iniciando processamento PARALELO em thread background")
                        
                        batch_reload = BatchUpload.query.get(id)
                        if not batch_reload:
                            logger.error(f"Batch {id} n√£o encontrado no background")
                            return
                        
                        batch_reload.status = 'running'
                        batch_reload.started_at = datetime.utcnow()
                        batch_reload.processed_count = 0
                        db.session.commit()
                        
                        # Coletar itens prontos
                        items = BatchItem.query.filter_by(batch_id=id, status='ready').all()
                        total_items = len(items)
                        
                        logger.info(f"[BATCH RPA] {total_items} itens prontos para processar em paralelo (max {MAX_RPA_WORKERS} workers)")
                        
                        if total_items == 0:
                            batch_reload.status = 'completed'
                            batch_reload.finished_at = datetime.utcnow()
                            db.session.commit()
                            logger.info(f"[BATCH RPA] Batch {id} sem itens pendentes")
                            return
                        
                        # Preparar dados para processamento paralelo (evitar passar objetos SQLAlchemy entre threads)
                        items_data = []
                        for item in items:
                            if not item.process_id:
                                # Marcar itens sem process_id como erro antes do paralelo
                                item.status = 'error'
                                item.last_error = 'Processo n√£o encontrado no banco de dados'
                                item.updated_at = datetime.utcnow()
                                logger.warning(f"[BATCH RPA] Item {item.id} sem process_id - marcado como erro")
                            else:
                                items_data.append({
                                    'item_id': item.id,
                                    'process_id': item.process_id
                                })
                        db.session.commit()
                        
                        success_count = 0
                        error_count = len(items) - len(items_data)  # Contar erros de itens sem process_id
                        
                        if not items_data:
                            batch_reload.status = 'partial_completed'
                            batch_reload.processed_count = error_count
                            batch_reload.finished_at = datetime.utcnow()
                            db.session.commit()
                            logger.info(f"[BATCH RPA] Batch {id} - todos os itens tinham erros")
                            return
                        
                        # ‚úÖ Processar em paralelo usando ThreadPoolExecutor
                        logger.info(f"[BATCH RPA] Iniciando ThreadPoolExecutor com {MAX_RPA_WORKERS} workers para {len(items_data)} itens")
                        
                        with ThreadPoolExecutor(max_workers=MAX_RPA_WORKERS) as executor:
                            # Submeter todas as tarefas com worker_id √∫nico para cada uma
                            future_to_item = {}
                            for idx, item_data in enumerate(items_data):
                                worker_id = idx % MAX_RPA_WORKERS  # Cicla entre 0 e MAX_RPA_WORKERS-1
                                future = executor.submit(
                                    _execute_single_rpa,
                                    item_data['item_id'],
                                    item_data['process_id'],
                                    worker_id
                                )
                                future_to_item[future] = {**item_data, 'worker_id': worker_id}
                            
                            logger.info(f"[BATCH RPA] {len(future_to_item)} tarefas RPA submetidas ao executor")
                            
                            # Processar resultados √† medida que ficam prontos
                            for future in as_completed(future_to_item):
                                item_data = future_to_item[future]
                                
                                try:
                                    result = future.result()
                                    
                                    if result['success']:
                                        success_count += 1
                                        logger.info(f"[BATCH RPA] ‚úÖ Conclu√≠do: item {result['item_id']} -> processo {result['process_id']}")
                                    else:
                                        error_count += 1
                                        logger.warning(f"[BATCH RPA] ‚ùå Falhou: item {result['item_id']} -> {result['error']}")
                                    
                                    # Atualizar progresso do batch em tempo real
                                    batch_reload.processed_count = success_count + error_count
                                    db.session.commit()
                                    
                                    logger.info(f"[BATCH RPA] Progresso: {success_count + error_count}/{total_items} ({success_count} sucesso, {error_count} erros)")
                                    
                                except Exception as ex:
                                    error_count += 1
                                    logger.error(f"[BATCH RPA] ‚ùå Exce√ß√£o no future do item {item_data['item_id']}: {ex}")
                        
                        # Finalizar batch
                        batch_reload.status = 'completed' if error_count == 0 else 'partial_completed'
                        batch_reload.processed_count = success_count + error_count
                        batch_reload.finished_at = datetime.utcnow()
                        db.session.commit()
                        
                        logger.info(f"[BATCH RPA] ‚úÖ Batch {id} finalizado: {success_count} sucesso(s), {error_count} erro(s) em {total_items} itens")
                        
                    except Exception as e:
                        import traceback
                        tb = traceback.format_exc()
                        logger.error(f"[BATCH RPA] ‚ùå Erro fatal ao processar batch {id}: {e}")
                        logger.error(f"[BATCH RPA][TRACEBACK] {tb}")
                        try:
                            batch_reload = BatchUpload.query.get(id)
                            if batch_reload:
                                batch_reload.status = 'error'
                                batch_reload.finished_at = datetime.utcnow()
                                db.session.commit()
                        except:
                            pass
            
            except Exception as outer_ex:
                import traceback
                tb = traceback.format_exc()
                logger.error(f"[BATCH RPA][PARALLEL] ‚ùå Exce√ß√£o FORA do app_context: {outer_ex}")
                logger.error(f"[BATCH RPA][PARALLEL][TRACEBACK] {tb}")
            
            finally:
                logger.info(f"[BATCH RPA][PARALLEL] Thread principal finalizada para batch {id}")
            
        # Iniciar thread principal
        thread = threading.Thread(target=execute_batch_rpa_parallel, daemon=True)
        thread.start()
        logger.info(f"[BATCH RPA] Thread de processamento PARALELO iniciada para batch {id}")
        
        # Retornar imediatamente
        return jsonify({
            'success': True,
            'message': f'Processamento RPA em lote iniciado com {MAX_RPA_WORKERS} processos simult√¢neos! Acompanhe o progresso na lista.'
        })
    
    except Exception as e:
        logger.error(f"Erro ao iniciar batch {id}: {e}", exc_info=True)
        try:
            batch.status = 'error'
            db.session.commit()
        except:
            pass
        return jsonify({'success': False, 'error': str(e)}), 500


@batch_bp.route("/<int:id>/status")
@login_required
def batch_status(id):
    """Retorna status atual do batch (JSON para polling)"""
    try:
        # üîß 2025-11-27: FOR√áAR dados frescos do banco (evitar cache de sess√£o SQLAlchemy)
        db.session.expire_all()
        
        batch = BatchUpload.query.get(id)
        if not batch:
            return jsonify({'success': False, 'error': 'Batch n√£o encontrado'}), 404
        
        # Verificar permiss√£o
        if batch.owner_id != current_user.id:
            return jsonify({'success': False, 'error': 'Permiss√£o negada'}), 403
        
        items = BatchItem.query.filter_by(batch_id=id).order_by(BatchItem.process_id.asc().nullslast()).all()
        
        # üîß FIX: Carregar dados do processo para incluir screenshots
        from models import Process
        items_data = []
        rpa_completed_count = 0  # Contar processos com RPA finalizado
        needs_commit = False
        
        for item in items:
            # ‚úÖ SYNC FIX: Sincronizar batch_item.status com process.elaw_status
            # Corrige casos onde a thread morreu antes de atualizar o status
            if item.status == 'running' and item.process_id:
                proc = Process.query.get(item.process_id)
                if proc and proc.elaw_status in ('success', 'error'):
                    # Processo terminou mas item n√£o foi atualizado
                    item.status = 'success' if proc.elaw_status == 'success' else 'error'
                    item.updated_at = datetime.utcnow()
                    needs_commit = True
                    logger.info(f"[BATCH STATUS SYNC] Item {item.id} sincronizado: running -> {item.status}")
        
        # Commit sincroniza√ß√£o se necess√°rio
        if needs_commit:
            try:
                db.session.commit()
                # Tamb√©m verificar se o batch precisa ser atualizado
                all_done = all(i.status in ('success', 'error') for i in items)
                if all_done and batch.status == 'running':
                    success_count = sum(1 for i in items if i.status == 'success')
                    error_count = sum(1 for i in items if i.status == 'error')
                    batch.status = 'completed' if error_count == 0 else 'partial_completed'
                    batch.processed_count = success_count + error_count
                    batch.finished_at = datetime.utcnow()
                    db.session.commit()
                    logger.info(f"[BATCH STATUS SYNC] Batch {id} sincronizado: running -> {batch.status}")
            except Exception as sync_ex:
                logger.error(f"[BATCH STATUS SYNC] Erro: {sync_ex}")
                db.session.rollback()
        
        for item in items:
            item_dict = {
                'id': item.id,
                'filename': item.source_filename,
                'status': item.status,
                'process_id': item.process_id,
                'attempt_count': item.attempt_count,
                'last_error': item.last_error
            }
            
            # Adicionar dados do processo se existir
            if item.process_id:
                proc = Process.query.get(item.process_id)
                if proc:
                    item_dict['process'] = {
                        'id': proc.id,
                        'elaw_status': proc.elaw_status,
                        'elaw_screenshot_before_path': proc.elaw_screenshot_before_path,
                        'elaw_screenshot_after_path': proc.elaw_screenshot_after_path,
                        'elaw_screenshot_reclamadas_path': proc.elaw_screenshot_reclamadas_path,
                        'elaw_screenshot_pedidos_path': proc.elaw_screenshot_pedidos_path
                    }
                    
                    # üîß 2025-11-27: Adicionar status detalhado do RPA para tempo real
                    from models import RPAStatus
                    rpa_status = RPAStatus.query.filter_by(process_id=item.process_id).first()
                    if rpa_status:
                        item_dict['rpa_status'] = {
                            'current_step': rpa_status.current_step,
                            'message': rpa_status.message,
                            'status': rpa_status.status,
                            'updated_at': rpa_status.updated_at.isoformat() if rpa_status.updated_at else None
                        }
                    
                    # Contar apenas processos com RPA finalizado (success ou error)
                    if proc.elaw_status in ('success', 'error'):
                        rpa_completed_count += 1
            
            items_data.append(item_dict)
        
        # Durante RPA, usar contagem de processos finalizados; caso contr√°rio usar processed_count do batch
        if batch.status == 'running':
            actual_processed = rpa_completed_count
        else:
            actual_processed = batch.processed_count
        
        return jsonify({
            'success': True,
            'batch_id': batch.id,
            'status': batch.status,
            'total_count': batch.total_count,
            'processed_count': actual_processed,
            'progress_percent': int((actual_processed / batch.total_count * 100)) if batch.total_count > 0 else 0,
            'started_at': batch.started_at.isoformat() if batch.started_at else None,
            'finished_at': batch.finished_at.isoformat() if batch.finished_at else None,
            'items': items_data
        })
    except Exception as e:
        logger.error(f"Erro ao obter status do batch {id}: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@batch_bp.route("/item/<int:id>/retry", methods=["POST"])
@login_required
def batch_item_retry(id):
    """Reenfileira item com erro para reprocessamento E executa RPA automaticamente"""
    item = BatchItem.query.get_or_404(id)
    batch = item.batch
    
    # Verificar permiss√£o
    if batch.owner_id != current_user.id:
        flash("Permiss√£o negada", "danger")
        return redirect(url_for('batch.batch_detail', id=batch.id))
    
    # Verificar se item pode ser reprocessado (error ou ready sem RPA)
    if item.status not in ['error', 'ready']:
        flash(f"Item n√£o pode ser reprocessado (status: {item.status})", "warning")
        return redirect(url_for('batch.batch_detail', id=batch.id))
    
    # Verificar se j√° est√° em processamento (previne cliques duplicados)
    if item.status == 'running':
        flash(f"Item '{item.source_filename}' j√° est√° em processamento.", "info")
        return redirect(url_for('batch.batch_detail', id=batch.id))
    
    # Verificar se tem processo associado
    if not item.process_id:
        flash(f"Item '{item.source_filename}' n√£o tem processo associado. Refa√ßa a extra√ß√£o.", "warning")
        return redirect(url_for('batch.batch_detail', id=batch.id))
    
    # Verificar quantos RPAs est√£o rodando no momento
    running_count = BatchItem.query.filter_by(batch_id=batch.id, status='running').count()
    if running_count >= MAX_RPA_WORKERS:
        flash(f"Limite de {MAX_RPA_WORKERS} RPAs simult√¢neos atingido. Aguarde uma vaga.", "warning")
        return redirect(url_for('batch.batch_detail', id=batch.id))
    
    try:
        # Resetar status para running
        item.status = 'running'
        item.last_error = None
        item.attempt_count += 1
        item.updated_at = datetime.utcnow()
        db.session.commit()
        
        # Capturar IDs antes de iniciar thread
        item_id = item.id
        process_id = item.process_id
        batch_id = batch.id
        filename = item.source_filename
        
        # Executar RPA em thread separada para n√£o bloquear a UI
        def run_rpa_async():
            logger.info(f"[RETRY RPA] ‚ñ∂Ô∏è INICIANDO RPA para item {item_id}, processo {process_id}")
            result = _execute_single_rpa(item_id, process_id, worker_id=99)
            if result.get('success'):
                logger.info(f"[RETRY RPA] ‚úÖ SUCESSO: item {item_id} processado!")
            else:
                logger.warning(f"[RETRY RPA] ‚ùå ERRO: item {item_id} - {result.get('error')}")
        
        import threading
        thread = threading.Thread(target=run_rpa_async, daemon=True)
        thread.start()
        
        logger.info(f"[RETRY RPA] Thread iniciada para item {item_id} (total running: {running_count + 1})")
        flash(f"RPA iniciado para '{filename}'! Acompanhe o progresso na tela.", "success")
        return redirect(url_for('batch.batch_detail', id=batch_id))
    
    except Exception as e:
        db.session.rollback()
        logger.error(f"Erro ao iniciar retry para item {id}: {e}")
        flash(f"Erro ao reprocessar: {str(e)}", "danger")
        return redirect(url_for('batch.batch_detail', id=batch.id))


@batch_bp.route("/item/<int:id>/pdf")
@login_required
def batch_item_pdf(id):
    """Visualizar PDF original do item"""
    item = BatchItem.query.get_or_404(id)
    batch = item.batch
    
    # Verificar permiss√£o
    if batch.owner_id != current_user.id:
        flash("Voc√™ n√£o tem permiss√£o para acessar este arquivo.", "danger")
        return redirect(url_for('batch.batch_list'))
    
    # Servir o PDF
    filepath = Path(item.upload_path)
    return send_from_directory(filepath.parent, filepath.name, as_attachment=False)


@batch_bp.route("/item/<int:id>/delete", methods=["POST"])
@login_required
def batch_item_delete(id):
    """Deletar um item do batch"""
    item = BatchItem.query.get_or_404(id)
    batch = item.batch
    
    # Verificar permiss√£o
    if batch.owner_id != current_user.id:
        flash("Voc√™ n√£o tem permiss√£o para deletar este item.", "danger")
        return redirect(url_for('batch.batch_list'))
    
    try:
        batch_id = batch.id
        
        # Deletar arquivo f√≠sico
        if os.path.exists(item.upload_path):
            os.remove(item.upload_path)
        
        # Deletar do banco
        db.session.delete(item)
        
        # Atualizar contagem do batch
        batch.total_count = max(0, batch.total_count - 1)
        db.session.commit()
        
        flash(f"Item '{item.source_filename}' deletado com sucesso!", "success")
        return redirect(url_for('batch.batch_detail', id=batch_id))
    
    except Exception as e:
        db.session.rollback()
        logger.error(f"Erro ao deletar item {id}: {e}")
        flash(f"Erro ao deletar item: {str(e)}", "danger")
        return redirect(url_for('batch.batch_detail', id=batch.id))


@batch_bp.route("/<int:id>/cleanup", methods=["POST"])
@login_required
def batch_cleanup(id):
    """Endpoint manual para limpar processos travados de um batch espec√≠fico"""
    batch = BatchUpload.query.get_or_404(id)
    
    # Verificar permiss√£o
    if batch.owner_id != current_user.id:
        return jsonify({'success': False, 'error': 'Permiss√£o negada'}), 403
    
    try:
        cleaned = cleanup_stuck_processes()
        return jsonify({
            'success': True,
            'cleaned': cleaned,
            'message': f'{cleaned} processo(s) travado(s) foram cancelados' if cleaned > 0 else 'Nenhum processo travado detectado'
        })
    except Exception as e:
        logger.error(f"Erro ao limpar processos: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@batch_bp.route("/<int:id>/reprocess", methods=["POST"])
@login_required
def batch_reprocess(id):
    """Reprocessar TODOS os processos do batch, resetando status e executando RPA novamente"""
    import threading
    from main import app
    from models import Process
    
    batch = BatchUpload.query.get_or_404(id)
    
    # Verificar permiss√£o
    if batch.owner_id != current_user.id:
        flash("Voc√™ n√£o tem permiss√£o para reprocessar este batch.", "danger")
        return redirect(url_for('batch.batch_list'))
    
    try:
        # 1. Limpeza autom√°tica de processos travados
        cleaned = cleanup_stuck_processes()
        if cleaned > 0:
            logger.info(f"[REPROCESS] Limpou {cleaned} processos travados")
        
        # 2. Cancelar processos travados espec√≠ficos deste batch (redund√¢ncia)
        from datetime import datetime, timedelta
        timeout_threshold = datetime.utcnow() - timedelta(minutes=10)
        
        stuck_items = BatchItem.query.filter(
            BatchItem.batch_id == id,
            BatchItem.status == 'running',
            BatchItem.updated_at < timeout_threshold
        ).all()
        
        for item in stuck_items:
            logger.warning(f"[REPROCESS] Cancelando item travado {item.id} (travado desde {item.updated_at})")
            item.status = 'ready'
            if item.process_id:
                process = Process.query.get(item.process_id)
                if process and process.elaw_status == 'running':
                    process.elaw_status = 'pending'
                    process.elaw_error_message = 'Cancelado por timeout (travado > 10min)'
        
        # 3. Resetar TODOS os items para 'ready' e limpar status RPA
        items_to_reprocess = BatchItem.query.filter_by(batch_id=id).all()
        
        logger.info(f"[REPROCESS] Resetando {len(items_to_reprocess)} itens do batch {id}")
        logger.info(f"[REPROCESS] Cancelados {len(stuck_items)} processos travados espec√≠ficos do batch")
        
        for item in items_to_reprocess:
            # Resetar item para pending
            old_status = item.status
            item.status = 'pending'
            item.last_error = None
            item.attempt_count = 0  # Resetar contador de tentativas
            
            # Resetar status RPA do processo associado
            if item.process_id:
                process = Process.query.get(item.process_id)
                if process:
                    process.elaw_status = 'pending'
                    process.elaw_error_message = None
                    process.elaw_filled_at = None
                    # N√£o apagar screenshots - manter hist√≥rico
                    logger.info(f"[REPROCESS] Item {item.id}: {old_status} ‚Üí pending (Processo #{process.id} resetado)")
        
        # Atualizar status do batch
        batch.status = 'pending'
        batch.processed_count = 0
        batch.started_at = None
        batch.finished_at = None
        db.session.commit()
        
        logger.info(f"[REPROCESS] Batch {id} resetado completamente. Iniciando RPA...")
        
        # Iniciar thread de processamento (replicando l√≥gica do batch_start)
        import threading
        from main import app as flask_app_main
        import rpa
        
        # ‚úÖ FIX: Capturar user_id ANTES da thread (current_user n√£o existe em thread)
        user_id = current_user.id
        
        def execute_batch_reprocess_background():
            """Executa reprocessamento completo: EXTRA√á√ÉO PARALELA + RPA"""
            with flask_app_main.app_context():
                try:
                    # ‚úÖ FIX: Garantir que rpa.py usa o flask_app correto
                    rpa.flask_app = flask_app_main
                    logger.info(f"[BATCH REPROCESS] Flask app context configurado (user_id={user_id})")
                    
                    batch_reload = BatchUpload.query.get(id)
                    if not batch_reload:
                        logger.error(f"Batch {id} n√£o encontrado no background")
                        return
                    
                    # FASE 1: EXTRA√á√ÉO PARALELA DOS PDFs
                    logger.info(f"[BATCH REPROCESS] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FASE 1: EXTRA√á√ÉO PARALELA ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                    batch_reload.status = 'processing'
                    batch_reload.started_at = datetime.utcnow()
                    db.session.commit()
                    
                    pending_items = BatchItem.query.filter_by(batch_id=id, status='pending').all()
                    logger.info(f"[BATCH REPROCESS] {len(pending_items)} itens para extrair em PARALELO ({MAX_EXTRACTION_WORKERS} workers)")
                    
                    # ‚úÖ PROCESSAMENTO PARALELO usando ThreadPoolExecutor
                    from concurrent.futures import ThreadPoolExecutor, as_completed
                    
                    # Preparar dados dos itens (snapshot para evitar problemas de sess√£o)
                    items_data = [(item.id, item.upload_path, item.source_filename) for item in pending_items]
                    
                    extracted_count = 0
                    extraction_errors = 0
                    
                    with ThreadPoolExecutor(max_workers=MAX_EXTRACTION_WORKERS) as executor:
                        # Submeter todas as tarefas de extra√ß√£o
                        future_to_item = {
                            executor.submit(
                                _extract_single_item,
                                item_id, upload_path, source_filename, user_id
                            ): item_id
                            for item_id, upload_path, source_filename in items_data
                        }
                        
                        # Processar conforme completam
                        for future in as_completed(future_to_item):
                            item_id = future_to_item[future]
                            try:
                                result = future.result()
                                if result.get('success'):
                                    extracted_count += 1
                                    logger.info(f"[BATCH REPROCESS] ‚úÖ Item {item_id} extra√≠do! Process ID: {result.get('process_id')}")
                                else:
                                    extraction_errors += 1
                                    logger.warning(f"[BATCH REPROCESS] ‚ùå Item {item_id} falhou: {result.get('error')}")
                            except Exception as ex:
                                extraction_errors += 1
                                logger.error(f"[BATCH REPROCESS] Erro no future do item {item_id}: {ex}")
                    
                    logger.info(f"[BATCH REPROCESS] Extra√ß√£o PARALELA finalizada: {extracted_count} sucesso(s), {extraction_errors} erro(s)")
                    
                    # Marcar batch como 'ready' (extra√ß√£o completa, aguardando usu√°rio iniciar RPA)
                    batch_reload.status = 'ready' if extraction_errors == 0 else 'partial_ready'
                    batch_reload.processed_count = extracted_count + extraction_errors
                    batch_reload.finished_at = datetime.utcnow()
                    db.session.commit()
                    
                    logger.info(f"[BATCH REPROCESS] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê EXTRA√á√ÉO FINALIZADA ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                    logger.info(f"[BATCH REPROCESS] {extracted_count} processos extra√≠dos e prontos")
                    logger.info(f"[BATCH REPROCESS] Usu√°rio pode iniciar preenchimento eLaw em batch")
                    
                except Exception as e:
                    logger.error(f"[BATCH REPROCESS] Erro fatal ao processar batch {id}: {e}", exc_info=True)
                    try:
                        batch_reload = BatchUpload.query.get(id)
                        if batch_reload:
                            batch_reload.status = 'error'
                            db.session.commit()
                    except:
                        pass
        
        thread = threading.Thread(target=execute_batch_reprocess_background, daemon=True)
        thread.start()
        logger.info(f"[BATCH REPROCESS] Thread de reprocessamento iniciada para batch {id}")
        
        flash(f"Reprocessamento iniciado! {len(items_to_reprocess)} itens ser√£o processados novamente.", "success")
        return redirect(url_for('batch.batch_progress', id=id))
    
    except Exception as e:
        db.session.rollback()
        logger.error(f"Erro ao reprocessar batch {id}: {e}", exc_info=True)
        flash(f"Erro ao reprocessar: {str(e)}", "danger")
        return redirect(url_for('batch.batch_detail', id=id))


@batch_bp.route("/<int:id>/delete", methods=["POST"])
@login_required
def batch_delete(id):
    """Deletar batch e todos os processos associados"""
    try:
        batch = BatchUpload.query.get(id)
        
        # Se batch n√£o existe (j√° foi deletado), apenas redirecionar
        if not batch:
            logger.info(f"[BATCH DELETE] Batch #{id} j√° foi deletado (ignorando)")
            return redirect(url_for('batch.batch_list'))
        
        # Verificar propriedade
        if batch.owner_id != current_user.id:
            flash("Voc√™ n√£o tem permiss√£o para deletar este batch.", "danger")
            return redirect(url_for('batch.batch_list'))
        
        # Coletar process_ids dos itens
        items = BatchItem.query.filter_by(batch_id=id).all()
        process_ids = [item.process_id for item in items if item.process_id]
        
        # Deletar processos associados
        if process_ids:
            Process.query.filter(Process.id.in_(process_ids)).delete(synchronize_session=False)
            logger.info(f"[BATCH DELETE] Deletados {len(process_ids)} processos do batch #{id}")
        
        # Deletar batch (BatchItems ser√£o deletados por CASCADE)
        db.session.delete(batch)
        db.session.commit()
        
        # Resetar sequ√™ncias se tabelas ficaram vazias
        reset_all_sequences_if_empty()
        
        flash(f"Batch #{id} e {len(process_ids)} processo(s) deletados com sucesso!", "success")
        logger.info(f"[BATCH DELETE] Batch #{id} deletado pelo usu√°rio #{current_user.id}")
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Erro ao deletar batch {id}: {e}", exc_info=True)
        flash(f"Erro ao deletar batch: {str(e)}", "danger")
    
    return redirect(url_for('batch.batch_list'))


@batch_bp.route("/delete-multiple", methods=["POST"])
@login_required
def batch_delete_multiple():
    """Deletar m√∫ltiplos batches e seus processos"""
    try:
        batch_ids = request.form.getlist('batch_ids')
        
        if not batch_ids:
            flash("Nenhum batch selecionado.", "warning")
            return redirect(url_for('batch.batch_list'))
        
        # Converter para inteiros
        batch_ids = [int(bid) for bid in batch_ids]
        
        # Buscar batches do usu√°rio
        batches = BatchUpload.query.filter(
            BatchUpload.id.in_(batch_ids),
            BatchUpload.owner_id == current_user.id
        ).all()
        
        if not batches:
            flash("Nenhum batch v√°lido encontrado.", "warning")
            return redirect(url_for('batch.batch_list'))
        
        total_processes = 0
        
        for batch in batches:
            # Coletar process_ids dos itens
            items = BatchItem.query.filter_by(batch_id=batch.id).all()
            process_ids = [item.process_id for item in items if item.process_id]
            
            # Deletar processos associados
            if process_ids:
                Process.query.filter(Process.id.in_(process_ids)).delete(synchronize_session=False)
                total_processes += len(process_ids)
            
            # Deletar batch
            db.session.delete(batch)
        
        db.session.commit()
        
        # Resetar sequ√™ncias se tabelas ficaram vazias
        reset_all_sequences_if_empty()
        
        flash(f"{len(batches)} batch(es) e {total_processes} processo(s) deletados com sucesso!", "success")
        logger.info(f"[BATCH DELETE MULTIPLE] {len(batches)} batches deletados pelo usu√°rio #{current_user.id}")
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Erro ao deletar batches m√∫ltiplos: {e}", exc_info=True)
        flash(f"Erro ao deletar batches: {str(e)}", "danger")
    
    return redirect(url_for('batch.batch_list'))


# =============================================================================
# RE-EXTRA√á√ÉO OCR SELETIVA (FALLBACK PARA CAMPOS CR√çTICOS VAZIOS)
# =============================================================================
@batch_bp.route("/reextract-ocr", methods=["GET", "POST"])
@login_required
def reextract_ocr():
    """
    P√°gina de Re-extra√ß√£o OCR para campos cr√≠ticos vazios.
    
    Permite ao usu√°rio:
    1. Ver estat√≠sticas de campos vazios (sal√°rio, PIS, CTPS)
    2. Iniciar re-extra√ß√£o OCR seletiva em lote
    3. Acompanhar progresso
    """
    from sqlalchemy import or_
    
    # Estat√≠sticas de campos vazios
    stats = {
        'total': Process.query.filter_by(user_id=current_user.id).count(),
        'sem_salario': Process.query.filter(
            Process.user_id == current_user.id,
            or_(Process.salario.is_(None), Process.salario == "")
        ).count(),
        'sem_pis': Process.query.filter(
            Process.user_id == current_user.id,
            or_(Process.pis.is_(None), Process.pis == "")
        ).count(),
        'sem_ctps': Process.query.filter(
            Process.user_id == current_user.id,
            or_(Process.ctps.is_(None), Process.ctps == "")
        ).count()
    }
    
    if request.method == "POST":
        # Iniciar re-extra√ß√£o em lote
        fields = request.form.getlist('fields') or ['salario', 'pis', 'ctps']
        limit = int(request.form.get('limit', 20))
        
        try:
            from extractors.reextract import batch_reextract_missing
            
            # Pasta de uploads
            upload_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
            
            result = batch_reextract_missing(
                session=db.session,
                ProcessModel=Process,
                upload_folder=upload_folder,
                limit=limit,
                fields=fields,
                user_id=current_user.id
            )
            
            if result.get('error'):
                flash(f"Erro: {result['error']}", "danger")
            else:
                flash(
                    f"Re-extra√ß√£o conclu√≠da! "
                    f"Processados: {result['total_processados']}, "
                    f"Campos recuperados: {result['campos_recuperados']}, "
                    f"Erros: {result['erros']}",
                    "success"
                )
            
            return redirect(url_for('batch.reextract_ocr'))
            
        except Exception as e:
            logger.error(f"[REEXTRACT] Erro: {e}", exc_info=True)
            flash(f"Erro na re-extra√ß√£o: {str(e)}", "danger")
    
    return render_template('processes/reextract_ocr.html', stats=stats)


@batch_bp.route("/reextract-single/<int:process_id>", methods=["POST"])
@login_required
def reextract_single(process_id):
    """Re-extrai campos de um processo espec√≠fico via OCR"""
    from extractors.reextract import reextract_missing_fields, get_missing_critical_fields, find_pdf_path
    
    process = Process.query.get_or_404(process_id)
    
    if process.user_id != current_user.id:
        return jsonify({"error": "Acesso negado"}), 403
    
    upload_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    pdf_path = find_pdf_path(process, upload_folder)
    
    if not pdf_path or not Path(pdf_path).exists():
        return jsonify({"error": "PDF n√£o encontrado"}), 404
    
    existing_data = {
        'salario': process.salario or "",
        'pis': process.pis or "",
        'ctps': process.ctps or ""
    }
    
    missing = get_missing_critical_fields(existing_data)
    if not missing:
        return jsonify({"message": "Todos campos cr√≠ticos j√° preenchidos", "extracted": {}})
    
    try:
        extracted = reextract_missing_fields(
            process_id=process.id,
            pdf_path=pdf_path,
            existing_data=existing_data,
            fields_to_extract=missing
        )
        
        if extracted:
            for field, value in extracted.items():
                setattr(process, field, value)
            db.session.commit()
        
        return jsonify({
            "message": f"Re-extra√ß√£o conclu√≠da: {len(extracted)} campos recuperados",
            "extracted": extracted
        })
        
    except Exception as e:
        logger.error(f"[REEXTRACT_SINGLE] Erro: {e}", exc_info=True)
        db.session.rollback()
        return jsonify({"error": str(e)}), 500



================================================================================
FILE: rpa.py
================================================================================
# rpa.py ‚Äî eLaw RPA (Playwright)
# ---------------------------------------------------------------------------
# Preenche "Novo Processo" com robustez (bootstrap-select + nativo),
# usa PDF/endpoint para infer√™ncias e segue a ordem pedida
# (Cliente ‚Üí Parte Adversa (Tipo) ‚Üí Posi√ß√£o ‚Üí Parte Adversa (Nome) ‚Üí
#  Parte Interessada ‚Üí Valor da Causa).
# Corrigido: norm(), fluxo da Inst√¢ncia/Tipo de A√ß√£o/Valor da Causa, imports
# opcionais e helpers unificados.
# ---------------------------------------------------------------------------

import os
import re
import json
import math
import sys
import asyncio
import logging
import unicodedata
import time
import threading
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any, Tuple
from contextlib import asynccontextmanager

import requests
from dotenv import load_dotenv
from PyPDF2 import PdfReader
from playwright.async_api import async_playwright, Page

# RPA Monitor - Monitoramento remoto via monitor_integration
try:
    from monitor_integration import init_monitor, log_info as monitor_log_info, log_error as monitor_log_error, send_screenshot as monitor_send_screenshot, is_initialized as monitor_is_initialized
    RPA_MONITOR_AVAILABLE = True
except ImportError:
    RPA_MONITOR_AVAILABLE = False
    def monitor_log_info(msg, region=""): pass
    def monitor_log_error(msg, exc=None, region=""): pass
    def monitor_send_screenshot(path, region=""): pass
    def monitor_is_initialized(): return False

# RPA Log - Acesso direto ao rpa_log para screenshots
try:
    sys.path.insert(0, '/home/runner/workspace/rpa_monitor_client/rpa_monitor_client')
    from rpa_monitor_client import rpa_log
    RPA_LOG_AVAILABLE = True
except ImportError:
    RPA_LOG_AVAILABLE = False
    rpa_log = None

# --- imports opcionais (ok se faltar python-docx) ----------------------------
try:
    from docx import Document as DocxDocument  # type: ignore
except Exception:  # linter e runtime safe
    DocxDocument = None  # type: ignore

# --- utils do seu projeto ----------------------------------------------------
from utils.cell_inference import (
    load_alias_rows,
    build_alias_index,
    guess_cell_from_pdf_text,
)
from utils.option_catalog import save_catalog
from utils.normalization import normalize_text

# Sistema de mapeamento de posi√ß√µes do eLaw
from extractors.posicao_mapping import (
    normalize_posicao,
    get_posicao_id,
    get_posicao_label,
)

# Sistema de status em tempo real
# IMPORTANTE: flask_app DEVE ser configurado pelo caller ANTES de executar RPA
# Exemplo: rpa.flask_app = app._get_current_object()
flask_app = None
STATUS_ENABLED = True

# =============================================================================
# SISTEMA DE CONTEXTO THREAD-LOCAL PARA RPA PARALELO
# =============================================================================
# 
# Arquitetura: Cada thread de RPA tem seu pr√≥prio contexto isolado usando
# contextvars (thread-safe e asyncio-safe). Isso permite execu√ß√£o paralela
# de m√∫ltiplos processos RPA sem conflitos de estado.
#
# Componentes:
# 1. RPAExecutionContext - Dataclass com dados do processo atual
# 2. _rpa_context - ContextVar que armazena o contexto por thread
# 3. Fun√ß√µes auxiliares para acessar o contexto de forma segura

import contextvars
from dataclasses import dataclass, field
from typing import Optional

@dataclass
class RPAExecutionContext:
    """
    Contexto de execu√ß√£o RPA isolado por thread/worker.
    
    Cada worker de RPA paralelo cria sua pr√≥pria inst√¢ncia deste contexto,
    garantindo isolamento total de estado entre execu√ß√µes simult√¢neas.
    """
    process_id: int
    worker_id: Optional[int] = None  # ID do worker no ThreadPoolExecutor
    screenshot_prefix: str = ""  # Prefixo √∫nico para screenshots
    started_at: Optional[datetime] = None
    
    def __post_init__(self):
        from datetime import datetime
        if self.started_at is None:
            self.started_at = datetime.utcnow()
        if not self.screenshot_prefix:
            self.screenshot_prefix = f"process_{self.process_id}"
        if self.worker_id is not None:
            self.screenshot_prefix = f"w{self.worker_id}_{self.screenshot_prefix}"

# ContextVar para armazenar contexto por thread (thread-safe + asyncio-safe)
_rpa_context: contextvars.ContextVar[Optional[RPAExecutionContext]] = contextvars.ContextVar(
    '_rpa_context', default=None
)

def get_current_context() -> Optional[RPAExecutionContext]:
    """Retorna o contexto RPA da thread/task atual (thread-safe)."""
    return _rpa_context.get()

def get_current_process_id() -> Optional[int]:
    """
    Retorna o process_id do contexto atual (thread-safe).
    
    2025-11-27: Prioridade: contextvar ‚Üí global
    - RPA paralelo: usa contextvar (isolado por thread)
    - RPA legado: fallback para global (compatibilidade)
    """
    ctx = _rpa_context.get()
    if ctx:
        return ctx.process_id
    # Fallback para global (necess√°rio para execute_rpa() legado)
    return _current_process_id

def set_rpa_context(ctx: RPAExecutionContext) -> contextvars.Token:
    """
    Define o contexto RPA para a thread/task atual.
    Retorna token para reset posterior.
    """
    return _rpa_context.set(ctx)

def reset_rpa_context(token: contextvars.Token) -> None:
    """Reseta o contexto RPA usando o token."""
    _rpa_context.reset(token)

# =============================================================================
# LOCKS E SEM√ÅFOROS PARA PARALELISMO CONTROLADO
# =============================================================================

# Configura√ß√£o de paralelismo
# 2025-12-03: Reduzido para 3 workers em produ√ß√£o para evitar falta de recursos
# Em desenvolvimento pode usar 5, mas produ√ß√£o Replit tem recursos limitados
_DEFAULT_WORKERS = "3" if os.getenv("REPL_DEPLOYMENT") else "5"
MAX_RPA_WORKERS = int(os.getenv("MAX_RPA_WORKERS", _DEFAULT_WORKERS))  # M√°ximo de RPAs paralelos

# Sem√°foro para controlar n√∫mero m√°ximo de execu√ß√µes RPA simult√¢neas
# Substitui o antigo _execute_rpa_lock (mutex) por sem√°foro (permite N simult√¢neos)
_execute_rpa_semaphore = threading.Semaphore(MAX_RPA_WORKERS)

# Lock para serializar lan√ßamentos do browser (evita picos de CPU/mem√≥ria)
# Mantido como Lock para garantir que apenas 1 browser inicia por vez
_browser_launch_lock = threading.Lock()

# LEGADO: Mantido para compatibilidade durante migra√ß√£o
# TODO: Remover ap√≥s migra√ß√£o completa para contextvars
_current_process_id: Optional[int] = None
_execute_rpa_lock = threading.Lock()  # LEGADO: Ser√° substitu√≠do por sem√°foro

try:
    from rpa_status import RPAStatusManager
except Exception as e:
    STATUS_ENABLED = False
    print(f"[WARN] rpa_status n√£o dispon√≠vel - status em tempo real desabilitado: {e}")

# =========================
# Config
# =========================
load_dotenv(override=True)

BASE_URL = os.getenv("ELAW_BASE_URL", "https://acburlamaquihm.elawio.com.br/").strip()
ELAW_USER = os.getenv("ELAW_USER", "").strip()
ELAW_PASS = os.getenv("ELAW_PASS", "").strip()

RPA_DATA_JSON = os.getenv("RPA_DATA_JSON", "instance/rpa_current.json").strip()
UPLOADS_DIR = Path(os.getenv("RPA_UPLOADS_DIR", "./uploads")).resolve()

HEADLESS = os.getenv("RPA_HEADLESS", "true").strip().lower() in {"1", "true", "yes"}  # Default TRUE para VM sem X server
SLOWMO_MS = int(os.getenv("RPA_SLOWMO_MS", "0"))
DEFAULT_TIMEOUT_MS = int(os.getenv("RPA_DEFAULT_TIMEOUT_MS", "30000"))  # 30s (seguro para opera√ß√µes gerais)
NAV_TIMEOUT_MS = int(os.getenv("RPA_NAV_TIMEOUT_MS", "180000"))  # 180s (3 min - aumentado para produ√ß√£o Replit)
BROWSER_LAUNCH_TIMEOUT_MS = int(os.getenv("RPA_BROWSER_LAUNCH_TIMEOUT_MS", "180000"))  # 180s (3 min - aumentado para produ√ß√£o Replit)
SHORT_TIMEOUT_MS = int(os.getenv("RPA_SHORT_TIMEOUT_MS", "1500"))
VERY_SHORT_TIMEOUT_MS = int(os.getenv("RPA_VERY_SHORT_TIMEOUT_MS", "700"))

TYPE_DELAY_MS = int(os.getenv("RPA_TYPE_DELAY_MS", "6"))
CLICK_AFTER_OPEN_MS = int(os.getenv("RPA_CLICK_AFTER_OPEN_MS", "25"))
SETTLE_NET_MS = int(os.getenv("RPA_SETTLE_NET_MS", "60"))  # 90‚Üí60ms (economia ~0.5s acumulado)
SETTLE_SLEEP_MS = int(os.getenv("RPA_SETTLE_SLEEP_MS", "10"))  # 15‚Üí10ms (economia ~0.1s acumulado)

NAV_RETRIES = int(os.getenv("RPA_NAV_RETRIES", "2"))
KEEP_OPEN_AFTER_LOGIN_SECONDS = float(os.getenv("RPA_KEEP_OPEN_AFTER_LOGIN_SECONDS", "25"))

SCREENSHOT_DIR = Path(os.getenv("RPA_SCREENSHOT_DIR", "./rpa_screenshots")).resolve()
SCREENSHOT_DIR.mkdir(parents=True, exist_ok=True)

def _get_screenshot_path(filename: str, process_id: Optional[int] = None) -> Path:
    """
    üîß 2025-11-27: Atualizado para suportar RPA paralelo via contextvars
    
    Retorna caminho √∫nico de screenshot por processo, agora thread-safe.
    Usa contextvars para obter process_id quando n√£o fornecido explicitamente.
    
    Args:
        filename: Nome base do arquivo (ex: 'elaw_flow_error.png')
        process_id: ID do processo (opcional - usa contexto thread-local se None)
    
    Returns:
        Path com nome √∫nico: 'process_123_elaw_flow_error.png'
        OU 'w2_process_123_elaw_flow_error.png' se worker_id dispon√≠vel
        OU path gen√©rico se process_id indispon√≠vel (graceful degradation)
    """
    # 1. Tentar process_id expl√≠cito
    pid = process_id
    prefix = None
    
    # 2. Se n√£o fornecido, tentar contexto thread-local (novo sistema paralelo)
    if pid is None:
        ctx = get_current_context()
        if ctx:
            pid = ctx.process_id
            prefix = ctx.screenshot_prefix  # J√° inclui worker_id se dispon√≠vel
    
    # 3. Fallback para global legado (compatibilidade)
    if pid is None:
        pid = _current_process_id
    
    # 4. Graceful degradation se nenhum ID dispon√≠vel
    if pid is None:
        log(f"[SCREENSHOT][WARN] _get_screenshot_path sem process_id - usando path gen√©rico (filename={filename})")
        return SCREENSHOT_DIR / filename
    
    # Preservar extens√£o do arquivo
    parts = filename.rsplit('.', 1)
    if len(parts) == 2:
        name, ext = parts
        if prefix:
            unique_filename = f"{prefix}_{name}.{ext}"
        else:
            unique_filename = f"process_{pid}_{name}.{ext}"
    else:
        if prefix:
            unique_filename = f"{prefix}_{filename}"
        else:
            unique_filename = f"process_{pid}_{filename}"
    
    return SCREENSHOT_DIR / unique_filename

VIEWPORT_MODE = os.getenv("RPA_VIEWPORT_MODE", "MAX").strip().upper()
VIEWPORT_WIDTH = int(os.getenv("RPA_VIEWPORT_WIDTH", "1400"))
VIEWPORT_HEIGHT = int(os.getenv("RPA_VIEWPORT_HEIGHT", "900"))
FORCE_DEVICE_SCALE = os.getenv("RPA_FORCE_DEVICE_SCALE", "1").strip()
ENFORCE_ZOOM_RESET = os.getenv("RPA_ENFORCE_ZOOM_RESET", "true").strip().lower() in {"1", "true", "yes"}

HEADER_OFFSET_MANUAL = int(os.getenv("RPA_HEADER_OFFSET_PX", "0"))
BLOCK_LIGHT_RESOURCES = os.getenv("RPA_BLOCK_LIGHT_RESOURCES", "0").strip().lower() in {"1", "true", "yes"}

ENV_PROCESS_ID = os.getenv("RPA_PROCESS_ID", "").strip()
INSTANCIA_SELECT_ID = os.getenv("RPA_INSTANCIA_SELECT_ID", "InstanciaId").strip()

LLM_ENABLED = os.getenv("RPA_LLM_ENABLED", "false").strip().lower() in {"1", "true", "yes"}
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini").strip()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()

PW_TRACING = os.getenv("RPA_TRACING", "0").strip().lower() in {"1", "true", "yes"}

RPA_EXPECT_CNJ = os.getenv("RPA_EXPECT_CNJ", "").strip()
RPA_DATA_TTL_SECONDS = int(os.getenv("RPA_DATA_TTL_SECONDS", "900"))

RPA_CELL_DOCX_PATHS = os.getenv(
    "RPA_CELL_DOCX_PATHS",
    "config/CLIENTE X C√âLULA.docx;config/CLIENTE X C√âLULA x PARTE INTERESSADA.docx;docs/CLIENTE X C√âLULA.docx",
).split(";")
RPA_CELL_JSON_PATH = os.getenv("RPA_CELL_JSON_PATH", "config/client_cell_map.json").strip()

RPA_DEBUG = os.getenv("RPA_DEBUG", "1").strip().lower() in {"1", "true", "yes"}

RPA_DISALLOW_CAUTELAR = os.getenv("RPA_DISALLOW_CAUTELAR", "true").strip().lower() in {"1", "true", "yes"}
RPA_PREVIEW_SECONDS = float(os.getenv("RPA_PREVIEW_SECONDS", "5"))
RPA_SKIP_SAVE = os.getenv("RPA_SKIP_SAVE", "0").strip().lower() in {"1", "true", "yes"}

# RPA Monitor - Configura√ß√µes de monitoramento remoto
RPA_MONITOR_ENABLED = os.getenv("RPA_MONITOR_ENABLED", "false").strip().lower() in {"1", "true", "yes"}
RPA_MONITOR_ID = os.getenv("RPA_MONITOR_ID", "").strip()
RPA_MONITOR_HOST = os.getenv("RPA_MONITOR_HOST", "").strip()
RPA_MONITOR_PORT = os.getenv("RPA_MONITOR_PORT", "").strip()
RPA_MONITOR_REGION = os.getenv("RPA_MONITOR_REGION", "CBD-eLaw").strip()
RPA_MONITOR_TRANSPORT = os.getenv("RPA_MONITOR_TRANSPORT", "ws").strip()
_monitor_initialized = False

# --- LOG ---
LOG = logging.getLogger("rpa")
if not LOG.handlers:
    LOG.setLevel(logging.INFO)
    fmt = logging.Formatter("[rpa] %(asctime)s %(message)s", "%Y-%m-%dT%H:%M:%S")
    try:
        sys.stdout.reconfigure(encoding="utf-8")
    except Exception:
        pass
    ch = logging.StreamHandler(sys.stdout)
    ch.setFormatter(fmt)
    ch.setLevel(logging.INFO)
    LOG.addHandler(ch)

def _init_rpa_monitor():
    """Inicializa o RPA Monitor Client se habilitado via monitor_integration"""
    global _monitor_initialized
    
    if _monitor_initialized or not RPA_MONITOR_ENABLED:
        return
    
    if not RPA_MONITOR_AVAILABLE:
        LOG.info("[MONITOR] monitor_integration n√£o dispon√≠vel - monitoramento desabilitado")
        return
    
    try:
        # Usar monitor_integration.init_monitor() para inicializar
        init_monitor(rpa_id=RPA_MONITOR_ID or "RPA-eLaw")
        _monitor_initialized = monitor_is_initialized()
        if _monitor_initialized:
            LOG.info(f"[MONITOR] ‚úÖ RPA Monitor conectado via monitor_integration")
    except Exception as e:
        LOG.warning(f"[MONITOR] Erro ao inicializar monitor: {e}")

def log(msg: str) -> None:
    """Log local + envio para RPA Monitor (se habilitado)"""
    LOG.info(msg)
    
    # Enviar para monitor remoto se dispon√≠vel
    if monitor_is_initialized():
        try:
            monitor_log_info(msg, region="RPA")
        except Exception:
            pass  # N√£o quebrar execu√ß√£o se monitor falhar

def dlog(msg: str) -> None:
    if RPA_DEBUG:
        LOG.info("[DEBUG] " + msg)

def send_screenshot_to_monitor(screenshot_path: Path, region: str = "RPA"):
    """Envia screenshot PNG para o RPA Monitor via monitor_integration"""
    if not monitor_is_initialized():
        return
    
    try:
        # Usar monitor_integration.send_screenshot()
        monitor_send_screenshot(screenshot_path, region=region)
        LOG.info(f"[MONITOR] üì∏ Screenshot enviado via monitor_integration: {screenshot_path.name}")
    except Exception as e:
        LOG.warning(f"[MONITOR] Erro ao enviar screenshot: {e}")

def log_error_to_monitor(error_msg: str, exc: Optional[Exception] = None):
    """Envia log de erro para o RPA Monitor via monitor_integration"""
    if not monitor_is_initialized():
        return
    
    try:
        monitor_log_error(error_msg, exc=exc, region="RPA")
    except Exception:
        pass  # N√£o quebrar execu√ß√£o se monitor falhar

def validate_env():
    if not ELAW_USER or not ELAW_PASS:
        raise RuntimeError("Defina ELAW_USER e ELAW_PASS no .env")

# =========================
# Sistema de Status em Tempo Real
# =========================
# 2025-11-21: ZERO SHARED STATE - Architect Review aprovado
# Vari√°veis globais ELIMINADAS - process_id SEMPRE passado explicitamente
# Cada fun√ß√£o EXIGE process_id como par√¢metro - sem fallbacks!

def _init_status(process_id: int):
    """
    Inicializa o gerenciador de status para o processo
    2025-11-21: ZERO shared state - apenas cria manager inicial, n√£o salva nada global
    
    Args:
        process_id: ID do processo (OBRIGAT√ìRIO)
    """
    if not process_id:
        log("[STATUS][WARN] _init_status chamado sem process_id - ignorando")
        return
    
    if STATUS_ENABLED and flask_app:
        try:
            with flask_app.app_context():
                manager = RPAStatusManager(process_id)
                manager.update("iniciando", "Sistema de automa√ß√£o iniciado", status="starting")
                log(f"[STATUS][#{process_id}] Status manager inicializado (ZERO shared state)")
        except Exception as e:
            log(f"[STATUS][#{process_id}][WARN] Erro ao inicializar status: {e}")

def update_status(step: str, message: str, status: str = "running", data: dict = None, process_id: Optional[int] = None):
    """
    Helper para atualizar status do RPA
    2025-11-27: Thread-safe - usa contextvar primeiro, global como √∫ltimo fallback
    
    Args:
        step: Identificador do passo
        message: Mensagem descritiva
        status: Status do processo (running, error, completed, etc)
        data: Dados adicionais (opcional)
        process_id: ID do processo (opcional - usa contextvar ou global se None)
    """
    global _current_process_id
    
    # üÜï Prioridade: par√¢metro expl√≠cito ‚Üí contextvar ‚Üí global
    pid = process_id
    if pid is None:
        pid = get_current_process_id()  # Tenta contextvar primeiro
    if pid is None:
        pid = _current_process_id  # Fallback para legado
    
    if pid is None:
        log(f"[STATUS][ERROR] update_status chamado sem process_id (contextvar e global=None) (step={step})")
        return
    
    if STATUS_ENABLED and flask_app:
        try:
            with flask_app.app_context():
                manager = RPAStatusManager(pid)
                manager.update(step, message, status, data)
        except Exception as e:
            log(f"[STATUS][#{pid}][WARN] Erro ao atualizar status: {e}")

def update_field_status(field_key: str, field_label: str, value: Any = None, process_id: Optional[int] = None):
    """
    Helper espec√≠fico para atualizar status de preenchimento de campo individual
    2025-11-27: Thread-safe - usa contextvar primeiro, global como √∫ltimo fallback
    
    Args:
        field_key: Chave do campo
        field_label: Label do campo
        value: Valor do campo (opcional)
        process_id: ID do processo (opcional - usa contextvar ou global se None)
    """
    global _current_process_id
    
    # üÜï Prioridade: par√¢metro expl√≠cito ‚Üí contextvar ‚Üí global
    pid = process_id
    if pid is None:
        pid = get_current_process_id()  # Tenta contextvar primeiro
    if pid is None:
        pid = _current_process_id  # Fallback para legado
    
    if pid is None:
        log(f"[STATUS][ERROR] update_field_status chamado sem process_id (contextvar e global=None) para campo {field_key}")
        return
        
    msg = f"{field_label}"
    if value and str(value).strip():
        msg += f": {str(value)[:80]}"  # Limita tamanho do valor mostrado
    msg += " ‚úì"
    update_status(f"campo_{field_key}", msg, process_id=pid)

# =========================
# Normaliza√ß√£o
# =========================
def norm(s: str) -> str:
    """normaliza para matching: sem acento, min√∫sculo, sem NBSP"""
    s = (s or "").replace("\xa0", " ").strip()
    s = unicodedata.normalize("NFD", s)
    s = "".join(ch for ch in s if unicodedata.category(ch) != "Mn")
    s = re.sub(r"\s+", " ", s).lower()
    return s.encode("utf-8", "ignore").decode("utf-8")

# manter compatibilidade com chamadas antigas
_norm = norm

# =========================
# Helpers gerais
# =========================
def tokens(s: str) -> List[str]:
    return [t for t in re.findall(r"[a-z0-9]+", norm(s)) if len(t) >= 2]

def jaccard(a: List[str], b: List[str]) -> float:
    sa, sb = set(a), set(b)
    if not sa and not sb:
        return 1.0
    inter = len(sa & sb)
    uni = len(sa | sb) or 1
    return inter / uni

def _detect_ordinal(text: str) -> Optional[int]:
    """
    Detecta se texto cont√©m ordinal (1¬™/primeira, 2¬™/segunda, etc).
    Retorna: 1 para primeira/1¬™/1¬∫, 2 para segunda/2¬™/2¬∫, None se n√£o detectar.
    
    ‚úÖ FIX: Inclui s√≠mbolos ordin√°rios (¬™/¬∫) que n√£o s√£o removidos pela normaliza√ß√£o.
    """
    tn = norm(text)
    # Primeira inst√¢ncia (inclui s√≠mbolos ordin√°rios ¬™/¬∫)
    if any(x in tn for x in ["1a", "1o", "1¬™", "1¬∫", "primeira", "primeiro"]):
        return 1
    # Segunda inst√¢ncia (inclui s√≠mbolos ordin√°rios ¬™/¬∫)
    if any(x in tn for x in ["2a", "2o", "2¬™", "2¬∫", "segunda", "segundo"]):
        return 2
    return None

def _best_match(options: List[str], wanted: str, prefer_words: Optional[List[str]] = None, threshold: int = 28) -> Optional[str]:
    """
    Fuzzy matching com desempate por Jaccard similarity.
    
    Bug corrigido (2025-11-12): Antes dava score 55 para qualquer op√ß√£o com token comum,
    causando empate entre "Reclama√ß√£o Trabalhista" e "Reclama√ß√£o Correicional".
    
    Bug corrigido (2025-11-14): Adicionada detec√ß√£o de ordinais para evitar invers√£o
    entre "1¬™ Inst√¢ncia" ‚Üî "Segunda Inst√¢ncia". Quando ambos t√™m ordinal, b√¥nus/penalidade
    garante que ordinais concordantes sempre ganhem.
    
    Nova l√≥gica: Jaccard score SEMPRE conta, exact match e substring d√£o b√¥nus ADITIVOS.
    """
    wn = norm(wanted)
    wt = tokens(wanted)
    best = None
    score_best = -1
    
    # Detecta ordinal no wanted (1¬™/primeira ou 2¬™/segunda)
    wanted_ordinal = _detect_ordinal(wanted)
    
    for opt in options:
        on = norm(opt)
        ot = tokens(opt)
        
        # Inicia com Jaccard similarity (0-70)
        jaccard_score = int(jaccard(wt, ot) * 70)
        score = jaccard_score
        
        # B√¥nus ADITIVO para exact match (+30)
        if on == wn and wn:
            score = 100  # Exact match sempre ganha
        # B√¥nus ADITIVO para substring (+15) - N√ÉO sobrescreve Jaccard
        elif wn and wn in on:
            score += 15
        
        # B√¥nus para palavras preferidas (+12)
        if prefer_words and any(norm(p) in on for p in prefer_words):
            score += 12
        
        # üîß NOVO: Detec√ß√£o de ordinais (cr√≠tico para inst√¢ncias, varas, etc)
        if wanted_ordinal is not None:
            opt_ordinal = _detect_ordinal(opt)
            if opt_ordinal is not None:
                if wanted_ordinal == opt_ordinal:
                    # Ordinais concordam: B√îNUS massivo (+50)
                    score += 50
                    dlog(f"[ORDINAL] ‚úÖ Match: {wanted} ({wanted_ordinal}) ‚Üî {opt} ({opt_ordinal}) ‚Üí +50 bonus")
                else:
                    # Ordinais DISCORDAM: PENALIDADE massiva (-100)
                    score -= 100
                    dlog(f"[ORDINAL] ‚ùå Mismatch: {wanted} ({wanted_ordinal}) ‚â† {opt} ({opt_ordinal}) ‚Üí -100 penalty")
        
        # Atualiza melhor match (s√≥ se score for ESTRITAMENTE MAIOR)
        if score > score_best:
            best, score_best = opt, score
    
    return best if score_best >= threshold else None

async def short_sleep_ms(ms: int):
    await asyncio.sleep(ms / 1000.0)

async def wait_network_quiet(page, timeout_ms: int):
    try:
        await page.wait_for_load_state("networkidle", timeout=timeout_ms)
    except Exception:
        pass

def _fmt_ptbr(n: float | int | str) -> str:
    """Formata n√∫mero como moeda pt-BR (sem s√≠mbolo R$)."""
    if isinstance(n, str):
        return n.strip()
    s = f"{float(n):,.2f}"
    return s.replace(",", "X").replace(".", ",").replace("X", ".")

# =========================
# PDF utils
# =========================
def _read_all_pdfs_text(base_dir: Path, limit: int = 4) -> str:
    if not base_dir.exists():
        return ""
    pdfs = sorted(base_dir.glob("*.pdf"), key=lambda p: p.stat().st_mtime, reverse=True)[:limit]
    chunks = []
    for p in pdfs:
        try:
            reader = PdfReader(str(p))
            txt = []
            for pg in reader.pages:
                try:
                    txt.append(pg.extract_text() or "")
                except Exception:
                    continue
            if txt:
                chunks.append("\n".join(txt))
        except Exception:
            continue
    return "\n\n".join(chunks)

def read_pdf_api_all_text() -> str:
    """DEPRECATED: Use get_process_pdf_text() instead to avoid reading wrong PDF"""
    api = os.getenv("PDF_SCRAPE_API", "").strip()
    if api:
        try:
            r = requests.get(api, timeout=25)
            if r.status_code == 200:
                data = r.json() if r.headers.get("content-type", "").startswith("application/json") else {"text": r.text}
                return (data.get("text") or "").strip()
        except Exception:
            pass
    return _read_all_pdfs_text(UPLOADS_DIR)

def get_process_pdf_text(data: Dict[str, Any], process_id: Optional[int] = None) -> str:
    """
    Carrega o texto do PDF ESPEC√çFICO do processo, evitando mistura de dados.
    CR√çTICO: S√≥ usa fallback gen√©rico como √∫ltimo recurso (e lan√ßa exce√ß√£o).
    
    Args:
        data: Dicion√°rio com dados do processo (deve conter 'pdf_filename' se dispon√≠vel)
        process_id: ID do processo (opcional, para logging)
    
    Returns:
        Texto completo do PDF do processo
    
    Raises:
        ValueError: Se tiver que usar fallback gen√©rico (risco de mistura)
    """
    # Prioridade 1: PDF espec√≠fico do processo via filename do banco
    pdf_filename = (data.get("pdf_filename") or "").strip()
    
    if pdf_filename and UPLOADS_DIR.exists():
        # Corrigir caso onde pdf_filename j√° cont√©m "uploads/" no in√≠cio
        if pdf_filename.startswith("uploads/"):
            pdf_path = Path(pdf_filename)  # Usar caminho direto sem duplicar
        else:
            pdf_path = UPLOADS_DIR / pdf_filename
        
        if pdf_path.exists() and pdf_path.is_file():
            try:
                reader = PdfReader(str(pdf_path))
                txt = []
                for pg in reader.pages:
                    try:
                        txt.append(pg.extract_text() or "")
                    except Exception:
                        continue
                if txt:
                    text = "\n".join(txt)
                    log(f"[PDF] ‚úÖ PDF espec√≠fico carregado: {pdf_filename} ({len(text)} chars, process_id={process_id})")
                    return text
            except Exception as e:
                log(f"[PDF][WARN] Erro ao ler PDF espec√≠fico {pdf_filename}: {e}")
        else:
            log(f"[PDF][WARN] PDF vinculado n√£o encontrado: {pdf_filename}")
    
    # Prioridade 2: API externa (se configurada)
    api = os.getenv("PDF_SCRAPE_API", "").strip()
    if api:
        try:
            r = requests.get(api, timeout=25)
            if r.status_code == 200:
                api_data = r.json() if r.headers.get("content-type", "").startswith("application/json") else {"text": r.text}
                text = (api_data.get("text") or "").strip()
                if text:
                    log(f"[PDF] ‚úÖ Carregado via API externa ({len(text)} chars)")
                    return text
        except Exception as e:
            log(f"[PDF][WARN] Erro ao carregar PDF via API: {e}")
    
    # CR√çTICO: Fallback gen√©rico √© PERIGOSO - pode misturar processos!
    error_msg = f"Processo {process_id} sem PDF espec√≠fico vinculado. ABORTANDO para evitar mistura de dados!"
    log(f"[PDF][CRITICAL] {error_msg}")
    log(f"[PDF][CRITICAL] Dados do banco devem ser suficientes, ou processo precisa ter PDF vinculado.")
    raise ValueError(error_msg)

# =========================
# Browser
# =========================
@asynccontextmanager
async def launch_browser():
    async with async_playwright() as p:
        args = [
            "--disable-dev-shm-usage",
            "--no-default-browser-check",
            "--no-first-run",
            "--start-maximized",
            "--window-position=0,0",
            "--window-size=1920,1080",
            "--disable-gpu",
            "--no-sandbox",
            "--disable-setuid-sandbox",
            "--disable-software-rasterizer",
            "--disable-blink-features=AutomationControlled",
            "--disable-background-networking",
            "--disable-background-timer-throttling",
            "--disable-backgrounding-occluded-windows",
            "--disable-breakpad",
            "--disable-client-side-phishing-detection",
            "--disable-component-extensions-with-background-pages",
            "--disable-default-apps",
            "--disable-extensions",
            "--disable-features=TranslateUI",
            "--disable-hang-monitor",
            "--disable-ipc-flooding-protection",
            "--disable-popup-blocking",
            "--disable-prompt-on-repost",
            "--disable-renderer-backgrounding",
            "--disable-sync",
            "--metrics-recording-only",
            "--no-first-run",
            "--safebrowsing-disable-auto-update",
            "--enable-automation",
            "--password-store=basic",
            "--use-mock-keychain",
            "--ignore-certificate-errors",
            "--ignore-certificate-errors-spki-list",
        ]
        
        # Encontrar Chromium do sistema (Nix) com fallbacks robustos
        # NOTA: Chromium est√° configurado em .replit nix.packages, ent√£o estar√° dispon√≠vel
        # tanto em desenvolvimento quanto em produ√ß√£o (Reserved VM)
        import subprocess
        from glob import glob as glob_files
        
        def find_chromium_executable():
            """
            Busca o Chromium em m√∫ltiplos locais para garantir compatibilidade
            em desenvolvimento e produ√ß√£o (Replit deploy).
            
            Ordem de prioridade:
            1. Vari√°vel de ambiente CHROMIUM_PATH (configura√ß√£o expl√≠cita)
            2. which chromium (padr√£o no Replit/Nix - PRINCIPAL)
            3. which chromium-browser (alternativo em alguns sistemas)
            4. which google-chrome (fallback para Chrome)
            5. Busca direta no /nix/store (fallback extra)
            """
            # 1. Vari√°vel de ambiente expl√≠cita
            env_path = os.getenv("CHROMIUM_PATH", "").strip()
            if env_path and os.path.isfile(env_path) and os.access(env_path, os.X_OK):
                log(f"[BROWSER] ‚úÖ Chromium via CHROMIUM_PATH: {env_path}")
                return env_path
            
            # 2-4. Comandos which para diferentes nomes (PRINCIPAL - Nix Chromium)
            for cmd in ["chromium", "chromium-browser", "google-chrome"]:
                try:
                    path = subprocess.check_output(["which", cmd], text=True, stderr=subprocess.DEVNULL).strip()
                    if path and os.path.isfile(path):
                        log(f"[BROWSER] ‚úÖ Chromium via 'which {cmd}': {path}")
                        return path
                except Exception:
                    continue
            
            # 6. Busca direta no /nix/store (fallback extra para edge cases)
            try:
                nix_patterns = [
                    "/nix/store/*-chromium-*/bin/chromium",
                    "/nix/store/*chromium*/bin/chromium",
                ]
                for pattern in nix_patterns:
                    matches = sorted(glob_files(pattern), reverse=True)
                    for match in matches:
                        if os.path.isfile(match) and os.access(match, os.X_OK):
                            log(f"[BROWSER] ‚úÖ Chromium via Nix store: {match}")
                            return match
            except Exception as e:
                log(f"[BROWSER] Busca Nix store falhou (normal em alguns ambientes): {e}")
            
            return None
        
        executable_path = find_chromium_executable()
        
        if executable_path:
            log(f"[BROWSER] ‚úÖ Chromium selecionado: {executable_path}")
            # Chromium 138+ requer novo modo headless
            if HEADLESS:
                args.append("--headless")
        else:
            log("[BROWSER] ‚ùå ERRO CR√çTICO: Chromium N√ÉO encontrado em nenhum local!")
            log("[BROWSER] Tentados: CHROMIUM_PATH, which chromium/chromium-browser/google-chrome, /nix/store")
            raise RuntimeError(
                "Chromium n√£o encontrado. O RPA requer Chromium instalado no sistema. "
                "Em Replit, verifique se o m√≥dulo Nix 'chromium' est√° instalado. "
                "Ou defina CHROMIUM_PATH com o caminho do execut√°vel."
            )
        
        if os.getenv("RPA_FORCE_DEVICE_SCALE", "1").strip() in {"1", "true", "yes", "True"}:
            args.append("--force-device-scale-factor=1")

        log(f"[BROWSER] Iniciando Chromium (headless={HEADLESS}, exec={executable_path})...")
        log(f"[BROWSER] Timeout configurado: {BROWSER_LAUNCH_TIMEOUT_MS}ms")
        update_status("abrindo_navegador", "Lan√ßando processo do Chromium...")
        
        # CRITICAL: Usar threading.Lock para serializar lan√ßamentos entre threads do batch
        # (cada thread do batch cria seu pr√≥prio event loop, ent√£o asyncio.Lock n√£o funciona)
        log("[BROWSER] üîí Aguardando lock de thread para lan√ßamento serializado...")
        with _browser_launch_lock:
            log("[BROWSER] ‚úÖ Lock adquirido - thread tem permiss√£o para lan√ßar browser")
            
            # 2025-12-03: Retry com backoff exponencial para produ√ß√£o
            max_browser_retries = 3
            browser = None
            last_error = None
            
            for attempt in range(max_browser_retries):
                launch_start_time = time.time()
                try:
                    if attempt > 0:
                        backoff_seconds = 5 * (2 ** (attempt - 1))  # 5s, 10s
                        log(f"[BROWSER] ‚è≥ Tentativa {attempt + 1}/{max_browser_retries} ap√≥s aguardar {backoff_seconds}s...")
                        await asyncio.sleep(backoff_seconds)
                    
                    browser = await p.chromium.launch(
                        executable_path=executable_path,
                        headless=HEADLESS,  # CRITICAL: Deve ser True na VM (sem X server)
                        slow_mo=SLOWMO_MS, 
                        args=args, 
                        timeout=BROWSER_LAUNCH_TIMEOUT_MS
                    )
                    launch_duration = time.time() - launch_start_time
                    log(f"[BROWSER] ‚úÖ Chromium iniciado com sucesso em {launch_duration:.2f}s (tentativa {attempt + 1})!")
                    log(f"[BROWSER] üîì Liberando lock - pr√≥xima thread pode iniciar browser")
                    update_status("abrindo_navegador", "Configurando navegador...")
                    break  # Sucesso - sair do loop
                    
                except Exception as e:
                    launch_duration = time.time() - launch_start_time
                    last_error = e
                    log(f"[BROWSER] ‚ö†Ô∏è Tentativa {attempt + 1}/{max_browser_retries} falhou ap√≥s {launch_duration:.2f}s: {e}")
                    
                    if attempt == max_browser_retries - 1:
                        log(f"[BROWSER] ‚ùå ERRO CR√çTICO: Todas as {max_browser_retries} tentativas falharam")
                        log(f"[BROWSER] üîì Liberando lock ap√≥s falha total")
                        update_status("erro_navegador", f"Falha ao iniciar navegador ap√≥s {max_browser_retries} tentativas: {str(e)[:80]}", status="error")
                        raise RuntimeError(f"N√£o foi poss√≠vel iniciar o navegador Chromium ap√≥s {max_browser_retries} tentativas ({BROWSER_LAUNCH_TIMEOUT_MS}ms cada). √öltima tentativa: {launch_duration:.2f}s. Poss√≠vel falta de recursos no ambiente de produ√ß√£o.") from e
        
        ctx_kwargs: Dict[str, Any] = {"ignore_https_errors": True}
        if VIEWPORT_MODE == "MAX":
            ctx_kwargs["viewport"] = None
            ctx_kwargs["device_scale_factor"] = 1.0
        else:
            ctx_kwargs["viewport"] = {"width": VIEWPORT_WIDTH, "height": VIEWPORT_HEIGHT}
            ctx_kwargs["device_scale_factor"] = 1.0

        context = await browser.new_context(**ctx_kwargs)

        if BLOCK_LIGHT_RESOURCES:
            async def _route(r):
                if r.request.resource_type in {"image", "media", "font"}:
                    await r.abort()
                else:
                    await r.continue_()
            await context.route("**/*", _route)

        context.set_default_timeout(DEFAULT_TIMEOUT_MS)
        context.set_default_navigation_timeout(NAV_TIMEOUT_MS)

        page = await context.new_page()
        page.on("console", lambda m: LOG.info(f"[pw.console] {m.type.upper()}: {m.text}"))
        page.on("pageerror", lambda e: LOG.info(f"[pw.pageerror] {e}"))

        try:
            if PW_TRACING:
                Path("rpa_artifacts").mkdir(exist_ok=True)
                await context.tracing.start(screenshots=True, snapshots=True, sources=True)
                log("[TRACE] ON")
        except Exception:
            pass

        try:
            yield page
        finally:
            try:
                if PW_TRACING:
                    await context.tracing.stop(path="rpa_artifacts/trace.zip")
                    log("[TRACE] salvo em rpa_artifacts/trace.zip")
            except Exception:
                pass
            try:
                await context.close()
            except Exception:
                pass
            try:
                await browser.close()
            except Exception:
                pass

async def ensure_zoom_100(page, where: str):
    if not ENFORCE_ZOOM_RESET:
        return
    try:
        await page.bring_to_front()
        await page.keyboard.down("Control")
        await page.keyboard.press("Digit0")
        await page.keyboard.up("Control")
    except Exception:
        pass
    log(f"[ZOOM] reset 100% ({where})")

# =========================
# Navega√ß√£o / Login
# =========================
async def goto_with_retries(page, url: str, attempts: int, nav_timeout_ms: int):
    last = None
    for i in range(attempts):
        try:
            log(f"[NAV] {i+1}/{attempts}: {url}")
            await page.goto(url, wait_until="domcontentloaded", timeout=nav_timeout_ms)
            await short_sleep_ms(250)
            return
        except Exception as e:
            last = e
            await short_sleep_ms(700)
    raise RuntimeError(f"Falha ao navegar: {last}")

async def _check_login_success(page) -> bool:
    """Predicado composto: Toast sucesso (NOVO!) ou URL v√°lida + menu Processos"""
    try:
        # NOVA DETEC√á√ÉO: Toast verde de sucesso (eLaw mudou!)
        success_indicators = [
            ".toast-success",
            ".alert-success", 
            "[class*='success']:has-text('Sucesso')",
            ".swal2-success",  # SweetAlert2
            "[role='alert']:has-text('Sucesso')"
        ]
        
        for selector in success_indicators:
            try:
                toast = page.locator(selector).first
                if await toast.is_visible(timeout=500):
                    log("[LOGIN] ‚úÖ Toast de sucesso detectado - login aprovado!")
                    return True
            except:
                pass
        
        url = page.url
        # Rejeitar about:blank e URLs de login
        if "about:blank" in url or not "elawio.com" in url:
            return False
        if re.search(r"/Account/Login|/Login", url, re.I):
            return False
        
        # Verificar menu Processos (sinal de autentica√ß√£o)
        menu_visible = await page.locator("a:has-text('Processos'), nav a:has-text('Processos')").first.is_visible(timeout=2000)
        if menu_visible:
            return True
        
        return False
    except:
        return False

async def _check_login_failure(page) -> bool:
    """Detecta falha expl√≠cita: formul√°rio ainda vis√≠vel + mensagens de erro"""
    try:
        # Mensagens de valida√ß√£o/erro (verificar PRIMEIRO)
        error_selectors = [
            ".validation-summary-errors",
            ".alert-danger",
            ".alert-error",
            ".error-message",
            "[class*='error']",
            "[class*='validation']"
        ]
        
        for selector in error_selectors:
            error_msg = page.locator(selector).first
            try:
                if await error_msg.is_visible(timeout=500):
                    msg_text = await error_msg.text_content()
                    if msg_text and len(msg_text.strip()) > 0:
                        log(f"[LOGIN] ‚ùå Erro do eLaw: {msg_text.strip()[:200]}")
                        return True
            except:
                pass
        
        # REMOVIDO: "Formul√°rio vis√≠vel" n√£o √© mais indicador de falha!
        # eLaw agora mant√©m formul√°rio vis√≠vel com overlay "Processando..." durante sucesso
        
        return False  # Apenas retorna True se houver MENSAGEM DE ERRO expl√≠cita
    except:
        return False

async def login_elaw(page, user: str, password: str, url: str) -> bool:
    """Login com retry logic, waits robustos e detec√ß√£o precisa"""
    MAX_ATTEMPTS = 3
    
    for attempt in range(1, MAX_ATTEMPTS + 1):
        log(f"[LOGIN] Tentativa {attempt}/{MAX_ATTEMPTS}")
        
        # Verificar se j√° est√° logado
        if await _check_login_success(page):
            log("[LOGIN] ‚úÖ J√° autenticado!")
            return True
        
        # Navegar para p√°gina de login com timeout longo
        try:
            log(f"[LOGIN] Navegando para {url}")
            await page.goto(url, wait_until="domcontentloaded", timeout=180000)  # 3 minutos
            await short_sleep_ms(1000)
            log("[LOGIN] P√°gina carregada")
        except Exception as e:
            log(f"[LOGIN] ‚ö†Ô∏è Timeout na navega√ß√£o: {str(e)[:80]}")
            # Verificar se apesar do timeout, j√° est√° logado
            if await _check_login_success(page):
                log("[LOGIN] ‚úÖ Login j√° realizado (apesar do timeout)")
                return True
            
            # Backoff exponencial antes de retry
            if attempt < MAX_ATTEMPTS:
                wait_secs = 2 ** attempt
                log(f"[LOGIN] Aguardando {wait_secs}s antes de retry...")
                await short_sleep_ms(wait_secs * 1000)
                continue
            else:
                log("[LOGIN] ‚ùå Esgotadas tentativas de navega√ß√£o")
                return False
        
        await ensure_zoom_100(page, "login")
        
        # Aguardar formul√°rio aparecer
        try:
            email_loc = page.locator("input[type='email'], input#Email, input[name='Email']").first
            pwd_loc = page.locator("input[type='password'], input#Password, input[name='Password']").first
            
            await email_loc.wait_for(state="attached", timeout=20000)  # 20s - tolerante a eLaw lento
            log("[LOGIN] Formul√°rio de login detectado")
        except Exception as e:
            log(f"[LOGIN] ‚ö†Ô∏è Formul√°rio n√£o encontrado: {e}")
            # Pode j√° estar logado
            if await _check_login_success(page):
                log("[LOGIN] ‚úÖ J√° logado (sem formul√°rio)")
                return True
            continue
        
        # Preencher credenciais COM EVENTOS (cr√≠tico para valida√ß√£o ASP.NET do eLaw)
        try:
            # Email: focus + type + events
            await email_loc.click()
            await email_loc.fill("")  # Limpar primeiro
            await email_loc.type(user, delay=50)
            await email_loc.evaluate("""el => {
                el.dispatchEvent(new Event('input', {bubbles: true}));
                el.dispatchEvent(new Event('change', {bubbles: true}));
                el.dispatchEvent(new Event('blur', {bubbles: true}));
            }""")
            await short_sleep_ms(300)
            
            # Password: focus + type + events
            await pwd_loc.click()
            await pwd_loc.fill("")  # Limpar primeiro
            await pwd_loc.type(password, delay=50)
            await pwd_loc.evaluate("""el => {
                el.dispatchEvent(new Event('input', {bubbles: true}));
                el.dispatchEvent(new Event('change', {bubbles: true}));
                el.dispatchEvent(new Event('blur', {bubbles: true}));
            }""")
            await short_sleep_ms(300)
            
            # Verificar se campos foram preenchidos
            email_value = await email_loc.input_value()
            pwd_value = await pwd_loc.input_value()
            
            if email_value != user or pwd_value != password:
                log(f"[LOGIN] ‚ö†Ô∏è Valores n√£o correspondem! Email OK: {email_value == user}, Senha OK: {pwd_value == password}")
            else:
                log("[LOGIN] ‚úÖ Credenciais preenchidas e verificadas")
            
            # DIAGN√ìSTICO CR√çTICO: Verificar se h√° mensagens de erro ANTES do submit
            try:
                html_before = await page.content()
                if "inv√°lid" in html_before.lower() or "incorret" in html_before.lower():
                    log(f"[LOGIN] ‚ö†Ô∏è Erro pr√©-submit detectado no HTML!")
                    
                # Verificar se h√° campos ocultos obrigat√≥rios (CSRF, etc)
                hidden_inputs = await page.locator("input[type='hidden']").all()
                log(f"[LOGIN] Detectados {len(hidden_inputs)} campos ocultos no formul√°rio")
            except:
                pass
        except Exception as e:
            log(f"[LOGIN] ‚ùå Erro ao preencher: {e}")
            continue
        
        # Submit
        try:
            btn = page.locator("button[type='submit'], input[type='submit'], button:has-text('Entrar')").first
            await btn.click(timeout=5000)
            log("[LOGIN] Formul√°rio submetido")
        except Exception:
            try:
                await pwd_loc.press("Enter", timeout=3000)
                log("[LOGIN] Enter pressionado")
            except Exception as e:
                log(f"[LOGIN] ‚ùå Erro no submit: {e}")
                continue
        
        # Aguardar resposta (sucesso ou falha)
        # eLaw mudou: agora mostra toast + overlay antes de redirecionar!
        await short_sleep_ms(2000)
        
        # Race: success vs failure (aumentado de 30s para 45s)
        for check_attempt in range(45):  # 45s de espera para redirect
            if await _check_login_success(page):
                log(f"[LOGIN] ‚úÖ Login bem-sucedido! (tentativa {attempt})")
                return True
            
            if await _check_login_failure(page):
                # Capturar screenshot da falha
                try:
                    screenshot_path = f"/home/runner/workspace/rpa_screenshots/login_falha_attempt{attempt}.png"
                    await page.screenshot(path=screenshot_path)
                    log(f"[LOGIN] Screenshot salvo: {screenshot_path}")
                    send_screenshot_to_monitor(Path(screenshot_path), region="LOGIN_FALHA")
                except:
                    pass
                
                log(f"[LOGIN] ‚ùå Falha detectada (tentativa {attempt})")
                break
            
            await short_sleep_ms(1000)
        else:
            # Timeout sem sucesso nem falha clara
            log(f"[LOGIN] ‚è±Ô∏è Timeout na verifica√ß√£o (tentativa {attempt})")
            if attempt < MAX_ATTEMPTS:
                wait_secs = 2 ** attempt
                log(f"[LOGIN] Aguardando {wait_secs}s antes de retry...")
                await short_sleep_ms(wait_secs * 1000)
    
    log("[LOGIN] ‚ùå FALHA DEFINITIVA ap√≥s todas as tentativas")
    return False

async def temporarily_disable_navbar(page, ms=800):
    try:
        await page.evaluate(
            """
        (ms)=>{
          const nav = document.querySelector('nav.navbar, .navbar, .navbar-fixed-top, header');
          if (!nav) return;
          const prev = nav.style.pointerEvents;
          nav.style.pointerEvents = 'none';
          setTimeout(()=>{ try{ nav.style.pointerEvents = prev }catch(e){} }, ms);
        }
        """,
            ms,
        )
        log("[NAVBAR] pointer-events:none (temp)")
    except Exception:
        pass

async def click_hard(locator, label=""):
    try:
        await locator.scroll_into_view_if_needed(timeout=600)
        await locator.click(timeout=1200)
        log(f"[CLICK] {label} OK")
        return True
    except Exception:
        pass
    try:
        await locator.click(timeout=1200, force=True)
        log(f"[CLICK] {label} force OK")
        return True
    except Exception:
        pass
    try:
        await locator.evaluate("el => { el.click(); el.dispatchEvent(new Event('click',{bubbles:true})); }")
        log(f"[CLICK] {label} js OK")
        return True
    except Exception:
        pass
    log(f"[CLICK] {label} FAIL")
    return False

async def open_menu_processos(page):
    MAX_TRIES = 6
    for _ in range(MAX_TRIES):
        for sel in [
            "nav a:has-text('Processos')",
            "a:has-text('Processos')",
            "xpath=//a[normalize-space()='Processos']",
        ]:
            loc = page.locator(sel).first
            if await loc.count():
                await temporarily_disable_navbar(page, 800)
                if await click_hard(loc, "Processos"):
                    await short_sleep_ms(250)
                    return
        await short_sleep_ms(250)

    target = BASE_URL.rstrip("/") + "/Processo/form"
    log(f"[FALLBACK] indo direto: {target}")
    await goto_with_retries(page, target, attempts=2, nav_timeout_ms=60000)  # 60s - aumentado para produ√ß√£o

async def click_novo_processo(page):
    for sel in ["a[href='/Processo/form']", "a:has-text('Novo Processo')", "xpath=//a[contains(., 'Novo Processo')]"]:
        loc = page.locator(sel).first
        if await loc.count():
            await temporarily_disable_navbar(page, 800)
            if await click_hard(loc, "Novo Processo"):
                break
    else:
        target = BASE_URL.rstrip("/") + "/Processo/form"
        await goto_with_retries(page, target, attempts=2, nav_timeout_ms=60000)  # 60s - aumentado para produ√ß√£o

    try:
        await page.wait_for_url(re.compile(r"/Processo/form"), timeout=4000)
    except Exception:
        pass
    try:
        png = _get_screenshot_path("novo_processo_aberto.png", process_id=process_id)  # 2025-11-21: Corrigido
        await page.screenshot(path=str(png), full_page=True)
        log(f"[SHOT] novo processo: {png}")
        send_screenshot_to_monitor(png, region="NOVO_PROCESSO_ABERTO")
    except Exception:
        pass
    await ensure_zoom_100(page, "form")

# =========================
# Helpers UI (bootstrap-select & friends)
# =========================
async def _header_offset(page) -> int:
    if HEADER_OFFSET_MANUAL > 0:
        return HEADER_OFFSET_MANUAL
    try:
        h = await page.evaluate(
            """
        () => {
          const el=document.querySelector('.navbar-fixed-top, nav.navbar-fixed-top, .navbar.navbar-fixed-top');
          return el? el.offsetHeight: 0;
        }"""
        )
        return int(h or 0) + 16
    except Exception:
        return 100

async def _scroll_into_view(locator):
    try:
        await locator.scroll_into_view_if_needed(timeout=800)
    except Exception:
        pass
    try:
        off = await _header_offset(locator.page)  # type: ignore
        await locator.evaluate(
            """(el,off)=>{
          const r=el.getBoundingClientRect();
          window.scrollBy({top:r.top - off, behavior:'instant'});
          el.focus({preventScroll:true});
        }""",
            off,
        )
    except Exception:
        pass

async def robust_click(desc: str, locator, timeout_ms: int = 1800) -> bool:
    try:
        await locator.wait_for(state="attached", timeout=timeout_ms)
    except Exception as e:
        log(f"{desc}: n√£o anexado ({e})")
        return False
    await _scroll_into_view(locator)
    for kw in ({"force": False}, {"force": True}):
        try:
            await locator.click(timeout=timeout_ms, **kw)
            log(f"{desc}: OK")
            return True
        except Exception:
            continue
    try:
        await locator.evaluate("el=>el.click()")
        log(f"{desc}: evaluate OK")
        return True
    except Exception as e:
        log(f"{desc}: falhou ({e})")
        return False

async def _open_bs_and_get_container(page, select_id: str):
    btn = page.locator(f"button.btn.dropdown-toggle[data-id='{select_id}']").first
    
    # üîß BATCH FIX: Aguardar que bot√£o esteja attached E VIS√çVEL (n√£o apenas attached)
    log(f"[BS_DROPDOWN] Aguardando bot√£o #{select_id} estar vis√≠vel...")
    await btn.wait_for(state="attached", timeout=max(SHORT_TIMEOUT_MS, 2000))
    await btn.wait_for(state="visible", timeout=max(SHORT_TIMEOUT_MS, 20000))  # 20s - tolerante a eLaw lento
    log(f"[BS_DROPDOWN] Bot√£o #{select_id} est√° vis√≠vel, prosseguindo...")
    
    for _ in range(2):
        caret = btn.locator(".bs-caret, .filter-option").first
        target = caret if (await caret.count()) > 0 else btn
        await _scroll_into_view(target)
        await target.click()
        await short_sleep_ms(max(CLICK_AFTER_OPEN_MS, 60))
        container = btn.locator("xpath=ancestor::*[contains(@class,'bootstrap-select')][1]")
        if await container.count() > 0:
            return btn, container
    return btn, None

async def _collect_options_from_container(container) -> List[str]:
    try:
        texts = await container.evaluate(
            """
        root => Array.from(
          root.querySelectorAll('.dropdown-menu li a span.text, .dropdown-menu li a span, .dropdown-menu li a')
        ).map(el => (el.textContent||'').trim()).filter(Boolean)
        """
        )
        return [t for t in texts if not re.search(r"selecion", t, re.I)]
    except Exception:
        return []

def _clean_choices(options: List[str]) -> List[str]:
    out = []
    seen = set()
    for o in options:
        t = (o or "").strip()
        if not t:
            continue
        if re.search(r"selecion", t, re.I):
            continue
        k = norm(t)
        if k in seen:
            continue
        seen.add(k)
        out.append(t)
    return out

async def nudge_change_event(page, select_id: str):
    try:
        await page.evaluate(
            """(sid)=>{
          const el=document.getElementById(sid); if(!el) return;
          for (const ev of ['input','change']) { try{ el.dispatchEvent(new Event(ev,{bubbles:true})) }catch(e){} }
          try{
            const $=window.jQuery||window.$;
            if ($ && $(el).selectpicker){ $(el).selectpicker('refresh').trigger('changed.bs.select'); }
          }catch(e){}
        }""",
            select_id,
        )
    except Exception:
        pass


async def force_select_bootstrap_by_text(page, select_id: str, wanted_text: str) -> bool:
    """
    For√ßa a sele√ß√£o em um dropdown bootstrap-select usando JavaScript puro.
    Mais robusto que set_select_fuzzy_any para campos problem√°ticos como Estado/Comarca.
    
    1. Busca op√ß√£o que melhor corresponde ao texto desejado
    2. Usa selectpicker('val') para definir o valor
    3. Dispara eventos changed.bs.select
    4. Verifica se a sele√ß√£o foi efetiva
    
    Returns:
        True se sele√ß√£o foi bem-sucedida, False caso contr√°rio
    """
    try:
        log(f"[FORCE_SELECT] Tentando selecionar '{wanted_text}' em #{select_id}...")
        
        # Passo 1: Buscar todas as op√ß√µes e encontrar a melhor correspond√™ncia
        result = await page.evaluate(
            """({sid, wanted})=>{
            const norm = s => (s||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().replace(/\\s+/g,' ').trim();
            const wNorm = norm(wanted);
            
            const el = document.getElementById(sid);
            if (!el || !el.options) return {success: false, error: 'Element not found'};
            
            // Encontrar melhor match
            let bestValue = null;
            let bestText = null;
            let bestScore = 0;
            
            for (const opt of el.options) {
                const text = (opt.textContent || '').trim();
                if (!text || /selecion/i.test(text)) continue;
                
                const tNorm = norm(text);
                let score = 0;
                
                if (tNorm === wNorm) score = 100;
                else if (tNorm.includes(wNorm)) score = 90;
                else if (wNorm.includes(tNorm)) score = 85;
                else {
                    // Fuzzy: contar palavras em comum
                    const wTokens = wNorm.split(' ').filter(Boolean);
                    const tTokens = tNorm.split(' ').filter(Boolean);
                    const common = wTokens.filter(w => tTokens.some(t => t.includes(w) || w.includes(t))).length;
                    score = Math.floor((common / Math.max(wTokens.length, 1)) * 70);
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestValue = opt.value;
                    bestText = text;
                }
            }
            
            if (!bestValue || bestScore < 40) {
                return {success: false, error: 'No matching option found', score: bestScore};
            }
            
            // Passo 2: Usar selectpicker para definir o valor
            try {
                const $ = window.jQuery || window.$;
                if ($ && $(el).selectpicker) {
                    $(el).selectpicker('val', bestValue);
                    $(el).selectpicker('refresh');
                    $(el).trigger('changed.bs.select').trigger('change');
                } else {
                    // Fallback: definir valor diretamente
                    el.value = bestValue;
                    el.dispatchEvent(new Event('change', {bubbles: true}));
                }
            } catch(e) {
                el.value = bestValue;
                el.dispatchEvent(new Event('change', {bubbles: true}));
            }
            
            // Passo 3: Verificar se foi selecionado
            const finalValue = el.value;
            const selected = finalValue === bestValue;
            
            return {
                success: selected, 
                selectedValue: finalValue, 
                selectedText: bestText,
                wantedValue: bestValue,
                score: bestScore
            };
        }""",
            {"sid": select_id, "wanted": wanted_text},
        )
        
        if result.get("success"):
            log(f"[FORCE_SELECT] ‚úÖ Selecionado: '{result.get('selectedText')}' (score: {result.get('score')})")
            # Aguardar eventos propagarem
            await page.wait_for_timeout(300)
            return True
        else:
            log(f"[FORCE_SELECT] ‚ùå Falha: {result.get('error', 'unknown')}")
            return False
            
    except Exception as e:
        log(f"[FORCE_SELECT] ‚ùå Erro: {e}")
        return False


async def select_estado_comarca_manual(page, cnj: str, data: dict, process_id: int = None) -> tuple:
    """
    Preenche Estado e Comarca manualmente quando o autofill do eLaw falha.
    Usa force_select_bootstrap_by_text para garantir sele√ß√£o efetiva.
    
    CADEIA DE DEPEND√äNCIAS:
    Estado ‚Üí libera Comarca ‚Üí libera Foro
    
    Se qualquer etapa falhar, as seguintes tamb√©m falham.
    
    Usa mapeamento centralizado TRT ‚Üí Estado do arquivo data/trt_map.json
    
    Returns:
        (estado, comarca) - strings com valores selecionados ou vazias se falhou
    """
    from rpa_status import update_status
    from extractors.regex_utils import (
        extract_trt_from_cnj, get_estado_variantes, 
        get_estado_from_trt, get_uf_from_trt,
        disambiguate_trt_uf, get_estado_alt_from_uf
    )
    
    estado = ""
    comarca = ""
    
    # === ESTADO ===
    log(f"[MANUAL] Preenchendo Estado manualmente...")
    update_status("preenchendo_estado_manual", "Preenchendo Estado manualmente...", process_id=process_id)
    
    # Determinar estado a partir do PDF ou CNJ usando mapeamento centralizado
    estado_nome = (data.get("estado") or data.get("uf") or "").strip()
    estado_uf = ""
    estado_variantes = []
    
    # Texto do PDF para desambigua√ß√£o de TRTs multi-estado
    pdf_text = data.get("pdf_text", "") or data.get("full_text", "") or ""
    
    # Extrair TRT do CNJ e usar mapeamento centralizado
    codigo_trt = ""
    if cnj:
        try:
            codigo_trt = extract_trt_from_cnj(cnj)
            if codigo_trt:
                # Para TRTs multi-estado (08, 10, 11, 14), usar desambigua√ß√£o
                estado_uf = disambiguate_trt_uf(codigo_trt, pdf_text)
                
                # Obter nome do estado correto baseado na UF desambiguada
                if estado_uf:
                    estado_nome_trt = get_estado_alt_from_uf(codigo_trt, estado_uf)
                    if estado_nome_trt:
                        estado_nome = estado_nome_trt
                
                # Usar mapeamento centralizado para obter variantes
                estado_variantes = get_estado_variantes(codigo_trt)
                
                log(f"[MANUAL] Estado do CNJ (TRT-{codigo_trt}): nome='{estado_nome}', UF='{estado_uf}' (desambiguado)")
                log(f"[MANUAL] Variantes do mapeamento: {estado_variantes[:5]}...")
        except Exception as e:
            log(f"[MANUAL] Erro extraindo TRT do CNJ: {e}")
    
    # Adicionar variantes do PDF/banco se n√£o vieram do mapeamento
    if estado_nome and estado_nome not in estado_variantes:
        estado_variantes.insert(0, estado_nome)
    if estado_uf and estado_uf not in estado_variantes:
        estado_variantes.insert(1, estado_uf)
    
    # Remover duplicatas mantendo ordem
    estado_variantes = list(dict.fromkeys(estado_variantes))
    
    log(f"[MANUAL] Variantes de estado a tentar: {estado_variantes}")
    
    # Tentar selecionar Estado com m√∫ltiplas variantes
    estado_selecionado = False
    await wait_for_select_ready(page, "EstadoId", 1, 8000)
    
    for variante in estado_variantes:
        if not variante:
            continue
            
        log(f"[MANUAL] Tentando selecionar Estado: '{variante}'")
        
        # Tentativa 1: force_select_bootstrap_by_text
        if await force_select_bootstrap_by_text(page, "EstadoId", variante):
            estado_selecionado = True
            log(f"[MANUAL] ‚úÖ Estado selecionado (for√ßa): {variante}")
            break
        
        # Tentativa 2: set_select_fuzzy_any (fuzzy matching)
        if await set_select_fuzzy_any(page, "EstadoId", variante, fallbacks=[variante]):
            estado_selecionado = True
            log(f"[MANUAL] ‚úÖ Estado selecionado (fuzzy): {variante}")
            break
        
        # Tentativa 3: _set_native_select_fuzzy (sele√ß√£o nativa)
        if await _set_native_select_fuzzy(page, "EstadoId", variante):
            estado_selecionado = True
            log(f"[MANUAL] ‚úÖ Estado selecionado (nativo): {variante}")
            break
    
    if not estado_selecionado:
        log(f"[MANUAL] ‚ùå Todas as variantes falharam para Estado")
    
    # SEMPRE reler o valor do DOM para confirmar sele√ß√£o
    estado_atual = await _get_selected_text(page, "EstadoId")
    if estado_atual and estado_atual.lower() not in ["selecione", "--", "---", ""]:
        estado = estado_atual
        log(f"[MANUAL] Estado confirmado do DOM: '{estado}'")
        
        # IMPORTANTE: Aguardar AJAX carregar cidades ap√≥s selecionar Estado
        log(f"[MANUAL] Aguardando cidades do estado {estado} carregarem (3s)...")
        await page.wait_for_timeout(3000)
        
        # Verificar se CidadeId tem op√ß√µes agora
        await wait_for_select_ready(page, "CidadeId", 2, 20000)  # 20s - tolerante a AJAX lento
    else:
        log(f"[MANUAL] ‚ùå Estado n√£o confirmado no DOM (valor atual: '{estado_atual}')")
    
    # === COMARCA ===
    if estado:  # S√≥ preencher Comarca se Estado foi selecionado
        log(f"[MANUAL] Preenchendo Comarca manualmente...")
        update_status("preenchendo_comarca_manual", "Preenchendo Comarca manualmente...", process_id=process_id)
        
        comarca_nome = (data.get("comarca") or data.get("cidade") or data.get("foro") or "").strip()
        
        # Aguardar select estar pronto (com op√ß√µes do estado)
        await wait_for_select_ready(page, "CidadeId", 2, 20000)  # 20s - tolerante a AJAX lento
        
        # Coletar op√ß√µes dispon√≠veis para fallback
        comarca_opts = []
        try:
            raw_opts = await page.evaluate("""sid => {
                const el = document.getElementById(sid);
                if (!el || !el.options) return [];
                return [...el.options].map(o => (o.textContent || '').trim()).filter(t => t && t.toLowerCase() !== 'selecione');
            }""", "CidadeId") or []
            comarca_opts = [o for o in raw_opts if o]
            log(f"[MANUAL] Comarcas dispon√≠veis: {len(comarca_opts)} op√ß√µes")
        except Exception as e:
            log(f"[MANUAL] Erro ao coletar comarcas: {e}")
        
        comarca_selecionada = False
        
        # Tentativa 1: Usar comarca do PDF/banco
        if comarca_nome:
            if await force_select_bootstrap_by_text(page, "CidadeId", comarca_nome):
                comarca = comarca_nome
                comarca_selecionada = True
                log(f"[MANUAL] ‚úÖ Comarca selecionada (for√ßa): {comarca}")
            else:
                # Tentar fuzzy
                if await set_select_fuzzy_any(page, "CidadeId", comarca_nome, fallbacks=comarca_opts[:5] if comarca_opts else None):
                    comarca = comarca_nome
                    comarca_selecionada = True
                    log(f"[MANUAL] ‚úÖ Comarca selecionada (fuzzy): {comarca}")
        
        # Tentativa 2: Se falhou, usar primeira comarca dispon√≠vel como fallback
        if not comarca_selecionada and comarca_opts:
            primeira_comarca = comarca_opts[0]
            log(f"[MANUAL] ‚ö†Ô∏è Usando primeira comarca dispon√≠vel como fallback: {primeira_comarca}")
            if await force_select_bootstrap_by_text(page, "CidadeId", primeira_comarca):
                comarca = primeira_comarca
                comarca_selecionada = True
                log(f"[MANUAL] ‚úÖ Comarca fallback selecionada: {comarca}")
            else:
                # Tentar nativo
                if await _set_native_select_fuzzy(page, "CidadeId", primeira_comarca):
                    comarca = primeira_comarca
                    comarca_selecionada = True
                    log(f"[MANUAL] ‚úÖ Comarca fallback selecionada (nativo): {comarca}")
        
        if not comarca_selecionada:
            log(f"[MANUAL] ‚ùå N√£o foi poss√≠vel selecionar nenhuma comarca")
        
        # Verificar sele√ß√£o de Comarca
        comarca_atual = await _get_selected_text(page, "CidadeId")
        if comarca_atual and comarca_atual.lower() not in ["selecione", "--", "---", ""]:
            comarca = comarca_atual
            log(f"[MANUAL] Comarca confirmada: {comarca}")
        
        # IMPORTANTE: Aguardar Foro (JuizadoId) carregar ap√≥s selecionar Comarca
        if comarca:
            log(f"[MANUAL] Aguardando Foro carregar ap√≥s comarca {comarca} (2s)...")
            await page.wait_for_timeout(2000)
            # Verificar se JuizadoId tem op√ß√µes
            try:
                await wait_for_select_ready(page, "JuizadoId", 1, 8000)
                log(f"[MANUAL] ‚úÖ Foro (JuizadoId) pronto para sele√ß√£o")
            except Exception:
                log(f"[MANUAL] ‚ö†Ô∏è Foro pode n√£o ter carregado completamente")
    
    # Atualizar status
    if estado and comarca:
        update_status("localizacao_ok", f"‚úÖ {estado} - {comarca}", process_id=process_id)
    elif estado:
        update_status("localizacao_parcial", f"‚ö†Ô∏è Estado: {estado} (Comarca n√£o preenchida)", process_id=process_id)
    else:
        update_status("localizacao_erro", "‚ùå Estado e Comarca n√£o preenchidos", process_id=process_id)
    
    return estado, comarca

async def set_bootstrap_select_fuzzy(
    page, select_id: str, wanted_text: str, fallbacks: Optional[List[str]] = None, prefer_words: Optional[List[str]] = None
) -> bool:
    try:
        btn, container = await _open_bs_and_get_container(page, select_id)
        if not container:
            return False
        sbox = container.locator(".bs-searchbox input").first
        if await sbox.count() > 0:
            await sbox.fill("")
            key = max(sorted(tokens(wanted_text), key=len), default=wanted_text)
            await sbox.type(key, delay=TYPE_DELAY_MS)
            await short_sleep_ms(110)

        options = _clean_choices(await _collect_options_from_container(container))
        target = _best_match(options, wanted_text, prefer_words=prefer_words, threshold=10)

        if not target and fallbacks:
            for fb in fallbacks:
                cand = _best_match(options, fb, prefer_words=prefer_words, threshold=8)
                if cand:
                    target = cand
                    break

        async def click_option(txt: str) -> bool:
            return await container.evaluate(
                """(root, wanted)=>{
                const norm=s=>(s||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().replace(/\\s+/g,' ').trim();
                const w=norm(wanted);
                const items=[...root.querySelectorAll('.dropdown-menu li a')];
                let best=null, score=-1;
                const scoreFn=(t)=>{
                  const n=norm(t); if(!n) return -1;
                  if(n===w) return 100;
                  if(n.includes(w)||w.includes(n)) return 85;
                  const wt=w.split(' ').filter(Boolean), nt=n.split(' ').filter(Boolean);
                  const inter=wt.filter(x=>nt.includes(x)).length; const uni=new Set([...wt,...nt]).size||1;
                  return Math.floor((inter/uni)*70);
                };
                for (const a of items){
                  const t=(a.querySelector('span.text')?.textContent||a.textContent||'').trim();
                  const sc=scoreFn(t);
                  if (sc>score) {best=a; score=sc;}
                }
                if (!best || score<10) return false;
                best.dispatchEvent(new MouseEvent('mousedown',{bubbles:true}));
                best.click();
                best.dispatchEvent(new MouseEvent('mouseup',{bubbles:true}));
                return true;
            }""",
                target or wanted_text,
            )

        clicked = await click_option(target or wanted_text)
        await btn.press("Escape")
        if clicked:
            await nudge_change_event(page, select_id)
            return True
        return False
    except Exception:
        return False

async def _set_native_select_fuzzy(
    page, select_id: str, wanted_text: str, fallbacks: Optional[List[str]] = None, prefer_words: Optional[List[str]] = None
) -> bool:
    try:
        opts = await page.evaluate(
            """sid=>{
          const el=document.getElementById(sid); if(!el||!el.options) return [];
          return [...el.options].map(o=>({text:(o.textContent||'').trim(), value:(o.value||'').trim()}));
        }""",
            select_id,
        ) or []
    except Exception:
        opts = []
    options = [o["text"] for o in opts if o.get("text") and not re.search(r"selecion", o["text"], re.I)]
    if not options:
        return False
    target = _best_match(options, wanted_text, prefer_words=prefer_words, threshold=12)
    if not target and fallbacks:
        for fb in fallbacks:
            cand = _best_match(options, fb, prefer_words=prefer_words, threshold=8)
            if cand:
                target = cand
                break
    if not target:
        return False

    ok = await page.evaluate(
        """({sid, label})=>{
      const norm=s=>(s||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().replace(/\\s+/g,' ').trim();
      const el=document.getElementById(sid); if(!el||!el.options) return false;
      const w=norm(label); let val='';
      for (const o of [...el.options]){
        const t=(o.textContent||'').trim(); if(!t || /selecion/i.test(t)) continue;
        const n=norm(t);
        if (n===w || n.includes(w) || w.includes(n)) { val=(o.value||'').trim(); break; }
      }
      if(!val) return false;
      try{ el.disabled=false; el.readOnly=false; }catch(e){}
      el.value=val;
      ['input','change'].forEach(ev=>{ try{ el.dispatchEvent(new Event(ev,{bubbles:true})) }catch(e){} });
      try{
        const $=window.jQuery||window.$;
        if ($ && $(el).selectpicker){ $(el).selectpicker('val', val).trigger('changed.bs.select'); }
      }catch(e){}
      return true;
    }""",
        {"sid": select_id, "label": target},
    )
    if ok:
        await nudge_change_event(page, select_id)
    return bool(ok)

async def select_from_bootstrap_dropdown(
    page: Page, select_id: str, search_text: str, field_label: str = ""
) -> bool:
    """
    Seleciona op√ß√£o em dropdown Bootstrap usando fuzzy matching.
    
    Args:
        page: P√°gina do Playwright
        select_id: ID do select (ex: SubTipoPrimeiraAudienciaId)
        search_text: Texto a ser buscado (ex: "Audi√™ncia Inicial Una (IU)")
        field_label: Label do campo para logging
    
    Returns:
        True se selecionou com sucesso, False caso contr√°rio
    """
    label = field_label if field_label else select_id
    log(f"[DROPDOWN] Selecionando '{search_text}' em {label}")
    
    try:
        result = await set_select_fuzzy_any(page, select_id, search_text, fallbacks=None, prefer_words=None)
        if result:
            log(f"[DROPDOWN] ‚úì Selecionado: {search_text}")
        else:
            log(f"[DROPDOWN] ‚úó Falha ao selecionar: {search_text}")
        return result
    except Exception as e:
        log(f"[DROPDOWN][ERRO] {label}: {e}")
        return False

async def set_select_fuzzy_any(
    page, select_id: str, wanted_text: str, fallbacks: Optional[List[str]] = None, prefer_words: Optional[List[str]] = None
) -> bool:
    try:
        has_bs = await page.locator(f"button.btn.dropdown-toggle[data-id='{select_id}']").count() > 0
    except Exception:
        has_bs = False
    if has_bs:
        ok = await set_bootstrap_select_fuzzy(page, select_id, wanted_text, fallbacks, prefer_words)
        if ok:
            return True
    return await _set_native_select_fuzzy(page, select_id, wanted_text, fallbacks, prefer_words)

async def wait_for_select_ready(page, select_id: str, min_opts: int = 1, timeout_ms: int = 15000) -> bool:
    deadline = asyncio.get_event_loop().time() + timeout_ms / 1000.0
    log(f"[WAIT] Aguardando select #{select_id} ficar pronto (timeout: {timeout_ms/1000}s)...")
    while True:
        try:
            count = await page.evaluate(
                """sid=>{
              const el=document.getElementById(sid);
              if(!el||!el.options) return 0;
              return [...el.options].filter(o=> (o.textContent||'').trim() && !/selecion/i.test(o.textContent||'')).length;
            }""",
                select_id,
            )
            if (count or 0) >= min_opts:
                log(f"[WAIT] Select #{select_id} pronto com {count} op√ß√µes")
                return True
        except Exception:
            pass
        if asyncio.get_event_loop().time() >= deadline:
            return False
        await short_sleep_ms(140)

async def _get_selected_text(page, select_id: str) -> str:
    try:
        return (
            await page.evaluate(
                """sid=>{
          const el=document.getElementById(sid); if(!el) return '';
          const opt=el.options && el.options[el.selectedIndex];
          return (opt && (opt.textContent||'').trim()) || '';
        }""",
                select_id,
            )
            or ""
        )
    except Exception:
        return ""

# =========================
# Campos por label / inputs / radios
# =========================
async def _find_control_id_by_label_contains(page, label_substr: str, prefer_selector: str = "") -> str:
    try:
        return await page.evaluate(
            """({needle, preferSel})=>{
          const norm=s=>(s||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase();
          needle=norm(needle);
          const labs=[...document.querySelectorAll('label')];
          for(const lab of labs){
            const txt=norm(lab.textContent||'');
            if(!txt || !txt.includes(needle)) continue;
            const forId=lab.getAttribute('for');
            if(forId) return forId;
            const root=lab.closest('.form-group, .input-group, .row, .col, .mb-3, .mt-2') || lab.parentElement;
            if(!root) continue;
            if(preferSel){
              const pref=root.querySelector(preferSel);
              if(pref && pref.id) return pref.id;
            }
            const sel=root.querySelector('select, input, textarea, button.btn.dropdown-toggle[data-id]');
            if(sel){
              if(sel.tagName==='BUTTON' && sel.dataset.id) return sel.dataset.id;
              if(sel.id) return sel.id;
            }
          }
          return '';
        }""",
            {"needle": label_substr, "preferSel": prefer_selector},
        )
    except Exception:
        return ""

async def set_input_by_id(page, input_id: str, value: str, label_log: str) -> bool:
    try:
        ctrl = page.locator(f"#{input_id}").first
        await ctrl.wait_for(state="attached", timeout=SHORT_TIMEOUT_MS)
    except Exception:
        log(f"[FORM][WARN] '{label_log}' ({input_id}) n√£o encontrado")
        return False
    try:
        await _scroll_into_view(ctrl)
        await ctrl.click()
        await ctrl.fill("")
        if value:
            await ctrl.type(value, delay=TYPE_DELAY_MS)
        log(f"[FORM] {label_log}: {value}")
        return True
    except Exception as e:
        log(f"[FORM][WARN] {label_log} erro: {e}")
        return False

async def set_input_by_label_contains(page, label_substr: str, value: str, label_log: str = "") -> bool:
    sid = await _find_control_id_by_label_contains(page, label_substr, prefer_selector="input, textarea")
    if not sid:
        return False
    return await set_input_by_id(page, sid, value, label_log or label_substr)

async def set_select_by_label_contains(
    page, label_substr: str, wanted: str, fallbacks: Optional[List[str]] = None, prefer_words: Optional[List[str]] = None
) -> bool:
    sid = await _find_control_id_by_label_contains(page, label_substr, prefer_selector="select, button.btn.dropdown-toggle")
    if not sid:
        return False
    return await set_select_fuzzy_any(page, sid, wanted, fallbacks=fallbacks, prefer_words=prefer_words)

async def set_radio_by_name(page, name: str, target_value: str, human_label: str = "") -> bool:
    try:
        await page.wait_for_selector(f"input[type='radio'][name='{name}']", timeout=5000)
    except Exception:
        return False
    radios = page.locator(f"input[type='radio'][name='{name}']")
    count = await radios.count()
    for i in range(count):
        r = radios.nth(i)
        v = (await r.get_attribute("value")) or ""
        if str(v).strip() != str(target_value).strip():
            continue
        await _scroll_into_view(r)
        try:
            await r.click(force=True)
        except Exception:
            try:
                parent = r.locator("xpath=ancestor::*[contains(@class,'iradio_')][1]").first
                helper = parent.locator("ins.iCheck-helper").first
                if await helper.count() > 0:
                    await helper.click()
            except Exception:
                pass
        await short_sleep_ms(60)
        cur = await page.evaluate(
            """(nm)=>{ const el=document.querySelector("input[type='radio'][name='"+nm+"']:checked"); return el ? String(el.value||'') : ''; }""",
            name,
        )
        if str(cur) == str(target_value):
            log(f"[RADIO] {human_label or name}: '{target_value}' marcado")
            return True
    return False

YES_VALUES = {"1", "true", "True", "on", "yes", "sim", "Sim", "S", "s"}

async def set_yes_radio_guess(page, name: str) -> bool:
    try:
        await page.wait_for_selector(f"input[type='radio'][name='{name}']", timeout=1000)
    except Exception:
        return False
    radios = page.locator(f"input[type='radio'][name='{name}']")
    count = await radios.count()
    for i in range(count):
        r = radios.nth(i)
        val = (await r.get_attribute("value")) or ""
        if val in YES_VALUES:
            try:
                await _scroll_into_view(r)
                await r.click(force=True)
                await short_sleep_ms(50)
                return True
            except Exception:
                pass
    for i in range(count):
        r = radios.nth(i)
        ok = await r.evaluate(
            """(el)=>{
            const t=((el.closest('label')?.textContent||'')+(el.parentElement?.textContent||'')); 
            const n=(t||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase(); 
            if(n.includes('sim')){ el.click(); return true; } return false;
        }"""
        )
        if ok:
            await short_sleep_ms(50)
            return True
    return False

# =========================
# CNJ
# =========================
CNJ_INPUT_IDS = [
    "NumeroProcesso",
    "Numero",
    "ProtocoloInicial",
    "Protocolo",
    "NumeroCNJ",
    "NumeroProcessoCNJ",
    "NumeroDoProcesso",
    "Numero_Processo",
]
CNJ_RADIO_NAMES = ["IsJudicial", "IsCNJ", "PossuiCNJ", "HasCNJ", "Cnj", "CnjFlag", "PossuiNumeroCNJ", "NumeroCNJFlag"]

async def ensure_cnj_flag_on(page) -> bool:
    for nm in CNJ_RADIO_NAMES:
        if await page.locator(f"input[type='radio'][name='{nm}']").count() > 0:
            if await set_yes_radio_guess(page, nm):
                log(f"[CNJ] R√°dio '{nm}' = Sim")
                await short_sleep_ms(60)
                return True
    try:
        ok = await page.evaluate(
            """()=>{ for (const el of document.querySelectorAll("input[type='checkbox']")){
            const txt=((el.closest('label')||{}).textContent||'')+(el.parentElement?.textContent||'');
            const n=(txt||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase();
            if(n.includes('cnj')){ if(!el.checked) el.click(); return true; }
          } return false; }"""
        )
        if ok:
            log("[CNJ] Checkbox marcado")
            return True
    except Exception:
        pass
    return False

async def wait_for_cnj_container(page, max_retries: int = 2) -> bool:
    """
    Aguarda explicitamente o campo CNJ aparecer no DOM ap√≥s callback AJAX do tipo Eletr√¥nico.
    
    DIAGN√ìSTICO (2025-11-21): O campo #ProtocoloInicial s√≥ √© materializado DEPOIS que
    o eLaw processa o radio Eletr√¥nico via AJAX. Sem esse wait, set_cnj_value() falha
    com count=0 em todos os seletores.
    
    Returns:
        True se campo CNJ foi encontrado, False caso contr√°rio.
    """
    process_id = get_current_process_id()  # ‚úÖ Thread-safe: usa contextvar primeiro
    log(f"[CNJ][WAIT][#{process_id}] ‚è≥ Aguardando campo CNJ aparecer no DOM ap√≥s AJAX...")
    
    # Seletores piv√¥ - pelo menos um deve aparecer quando formul√°rio CNJ estiver pronto
    pivot_selectors = [
        "#ProtocoloInicial",  # Seletor principal ap√≥s tipo Eletr√¥nico
        "#NumeroProcesso",
        "input[name='NumeroProcesso']",
        "input[name='ProtocoloInicial']",
    ]
    
    for attempt in range(max_retries):
        if attempt > 0:
            log(f"[CNJ][WAIT][#{process_id}] Tentativa {attempt + 1}/{max_retries} - Religando flag CNJ...")
            await ensure_cnj_flag_on(page)
            await _settle(page, f"cnj_retry_{attempt}")
        
        # Tentar encontrar qualquer seletor piv√¥ com timeout generoso
        for selector in pivot_selectors:
            try:
                log(f"[CNJ][WAIT][#{process_id}] Tentando aguardar: {selector}")
                await page.wait_for_selector(
                    selector,
                    state="visible",
                    timeout=20000  # 20s - tolerante a AJAX lento
                )
                log(f"[CNJ][WAIT][#{process_id}] ‚úÖ Campo CNJ encontrado: {selector}")
                await short_sleep_ms(200)  # Estabiliza√ß√£o adicional
                return True
            except Exception:
                # N√£o logar erro aqui - normal tentar m√∫ltiplos seletores
                continue
        
        log(f"[CNJ][WAIT][#{process_id}] ‚ö†Ô∏è Nenhum campo CNJ encontrado na tentativa {attempt + 1}")
    
    log(f"[CNJ][WAIT][#{process_id}] ‚ùå TIMEOUT: Campo CNJ n√£o apareceu ap√≥s {max_retries} tentativas")
    return False

CNJ_FMT_RE = re.compile(r"\b\d{7}-\d{2}\.\d{4}\.\d\.\d{2}\.\d{4}\b")
CNJ_DIG_RE = re.compile(r"\d{20}")

def _cnj_normalize(s: str) -> str:
    d = re.sub(r"\D", "", s or "")
    if len(d) != 20:
        return (s or "").strip()
    return f"{d[:7]}-{d[7:9]}.{d[9:13]}.{d[13]}.{d[14:16]}.{d[16:]}"

def extract_cnj_from_anywhere(data: Dict[str, Any]) -> str:
    for k in ("numero_processo", "cnj", "numero", "NumeroProcesso", "NumeroCNJ"):
        v = (data.get(k) or "").strip()
        if not v:
            continue
        if CNJ_FMT_RE.search(v) or CNJ_DIG_RE.search(re.sub(r"\D", "", v)):
            return _cnj_normalize(v)
    # Usar PDF espec√≠fico do processo (evita mistura de dados)
    pdf_text = data.get("_pdf_text") or read_pdf_api_all_text()
    bag = json.dumps(data, ensure_ascii=False) + "\n" + pdf_text
    m = CNJ_FMT_RE.search(bag)
    if m:
        return _cnj_normalize(m.group(0))
    d20 = CNJ_DIG_RE.search(re.sub(r"\D", "", bag))
    if d20:
        return _cnj_normalize(d20.group(0))
    return ""

async def set_cnj_value(page, cnj: str) -> bool:
    # üîß 2025-11-21: DEBUGGING CNJ - Logs detalhados para troubleshooting batch
    process_id = get_current_process_id()  # ‚úÖ Thread-safe: usa contextvar primeiro
    log(f"[CNJ][set_cnj_value] ‚ïê‚ïê‚ïê PROCESSO #{process_id} ‚ïê‚ïê‚ïê")
    log(f"[CNJ][DEBUG][#{process_id}] Entrada CNJ recebida: '{cnj}' (type: {type(cnj)})")
    
    wanted_digits = re.sub(r"\D", "", cnj or "")
    if not wanted_digits:
        log(f"[CNJ][FAIL][#{process_id}] ‚ùå CNJ vazio ou sem d√≠gitos: '{cnj}'")
        return False
    
    if len(wanted_digits) != 20:
        log(f"[CNJ][WARN][#{process_id}] CNJ com {len(wanted_digits)} d√≠gitos (esperado: 20): '{wanted_digits}'")

    log(f"[CNJ][DEBUG][#{process_id}] Tentando preencher CNJ: '{cnj}' (d√≠gitos: {wanted_digits})")
    
    # üîß CRITICAL FIX: APENAS seletores de TEXTBOX para n√∫mero do processo (N√ÉO incluir radios/checkboxes CNJ!)
    loc_candidates = [
        '#NumeroProcesso',  # ID principal do campo de texto
        'input[name="NumeroProcesso"]',  # Por nome
        'input[placeholder*="N√∫mero do Processo" i]',  # Por placeholder
        '#Numero',  # Fallback alternativo
        'input[name="Numero"]',  # Fallback por nome alternativo
        '#ProtocoloInicial',  # Outro nome poss√≠vel para o campo
        'input[placeholder*="numero do processo" i]'  # Case variations
    ]

    for css in dict.fromkeys(loc_candidates):
        try:
            log(f"[CNJ][DEBUG][#{process_id}] Tentando seletor: {css}")
            el = page.locator(css).first
            count = await el.count()
            if count == 0:
                log(f"[CNJ][DEBUG][#{process_id}] ‚ùå Seletor {css} N√ÉO encontrado (count=0)")
                continue
            
            log(f"[CNJ][DEBUG][#{process_id}] ‚úÖ Elemento {css} encontrado (count={count})")
            await _scroll_into_view(el)
            
            # Verificar se elemento est√° vis√≠vel e habilitado
            is_visible = await el.is_visible()
            is_enabled = await el.is_enabled()
            log(f"[CNJ][DEBUG][#{process_id}] Estado do campo: visible={is_visible}, enabled={is_enabled}")
            
            if not is_visible:
                log(f"[CNJ][FAIL][#{process_id}] Campo {css} encontrado mas N√ÉO vis√≠vel")
                continue
            if not is_enabled:
                log(f"[CNJ][FAIL][#{process_id}] Campo {css} encontrado mas N√ÉO habilitado")
                continue
            
            # Verificar valor inicial
            initial_val = (await el.input_value()) or ""
            log(f"[CNJ][DEBUG][#{process_id}] Valor inicial do campo {css}: '{initial_val}'")
            
            # Limpar campo
            try:
                await el.fill("")
                log(f"[CNJ][DEBUG][#{process_id}] Campo {css} limpo com fill('')")
            except Exception as e:
                log(f"[CNJ][WARN][#{process_id}] Erro ao limpar campo {css}: {e}")
            
            # Digitar CNJ
            try:
                log(f"[CNJ][#{process_id}] üéØ PREENCHENDO n√∫mero do processo no seletor: {css}")
                await el.type(cnj, delay=TYPE_DELAY_MS)
                log(f"[CNJ][DEBUG][#{process_id}] CNJ digitado no campo {css} com type()")
            except Exception as e:
                log(f"[CNJ][ERROR][#{process_id}] ‚ùå Erro ao digitar CNJ no campo {css}: {e}")
                continue
            
            # Validar resultado ap√≥s type()
            val = (await el.input_value()) or ""
            val_digits = re.sub(r"\D", "", val)
            log(f"[CNJ][DEBUG][#{process_id}] Valor ap√≥s type(): '{val}' (d√≠gitos: {val_digits})")
            
            if val_digits == wanted_digits:
                # üîß DOUBLE CHECK: Aguardar e verificar se valor persistiu (n√£o sumiu ap√≥s AJAX)
                await short_sleep_ms(300)
                val_final = (await el.input_value()) or ""
                val_final_digits = re.sub(r"\D", "", val_final)
                if val_final_digits == wanted_digits:
                    log(f"[CNJ][SUCCESS][#{process_id}] ‚úÖ CNJ verificado e persistido: '{val_final}'")
                    return True
                else:
                    log(f"[CNJ][FAIL][#{process_id}] ‚ö†Ô∏è CNJ sumiu ap√≥s Double Check. Esperado: {wanted_digits}, Obtido: {val_final_digits}")
                    # Tenta pr√≥ximo seletor
                    continue
            else:
                log(f"[CNJ][WARN][#{process_id}] type() N√ÉO persistiu corretamente. Esperado: {wanted_digits}, Obtido: {val_digits}")
            
            # Tentativa 2: for√ßar via JavaScript
            log(f"[CNJ][DEBUG][#{process_id}] Tentativa #2: For√ßando via JavaScript...")
            ok = await page.evaluate(
                """([sel, val])=>{
                const el=document.querySelector(sel); if(!el) return false;
                try{
                  const desc = Object.getOwnPropertyDescriptor(el.__proto__, 'value') ||
                               Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
                  if (desc && desc.set) desc.set.call(el, val); else el.value = val;
                } catch(e){ el.value = val; }
                for (const ev of ['input','keyup','change','blur']) {
                  try{ el.dispatchEvent(new Event(ev,{bubbles:true})) }catch(e){}
                }
                try{
                  const $=window.jQuery||window.$;
                  if ($) { $(el).trigger('input').trigger('keyup').trigger('change'); }
                }catch(e){}
                return true;
            }""",
                [css, cnj],
            )
            log(f"[CNJ][DEBUG][#{process_id}] JavaScript execute retornou: {ok}")
            
            if not ok:
                log(f"[CNJ][FAIL][#{process_id}] JavaScript falhou ao executar para {css}")
                continue
            
            await short_sleep_ms(80)
            
            # Validar resultado ap√≥s JavaScript
            val = (await el.input_value()) or ""
            val_digits = re.sub(r"\D", "", val)
            log(f"[CNJ][DEBUG][#{process_id}] Valor ap√≥s JavaScript: '{val}' (d√≠gitos: {val_digits})")
            
            if val_digits == wanted_digits:
                # üîß DOUBLE CHECK: Aguardar e verificar se valor persistiu (n√£o sumiu ap√≥s AJAX)
                await short_sleep_ms(300)
                val_final = (await el.input_value()) or ""
                val_final_digits = re.sub(r"\D", "", val_final)
                if val_final_digits == wanted_digits:
                    log(f"[CNJ][SUCCESS][#{process_id}] ‚úÖ CNJ verificado e persistido via JavaScript: '{val_final}'")
                    return True
                else:
                    log(f"[CNJ][FAIL][#{process_id}] ‚ö†Ô∏è CNJ sumiu ap√≥s Double Check JS. Esperado: {wanted_digits}, Obtido: {val_final_digits}")
                    # Tenta pr√≥ximo seletor
                    continue
            else:
                log(f"[CNJ][FAIL][#{process_id}] JavaScript N√ÉO persistiu. Esperado: {wanted_digits}, Obtido: {val_digits}")
            
            log(f"[CNJ][FAIL][#{process_id}] Seletor {css} testado mas valor n√£o persistiu - pr√≥ximo seletor...")
        except Exception as e:
            log(f"[CNJ][ERROR][#{process_id}] Exception ao processar seletor {css}: {e}")
            import traceback
            log(f"[CNJ][ERROR][#{process_id}] Traceback: {traceback.format_exc()}")
            continue

    # Falhou em todos os seletores
    log(f"[CNJ][ERROR][#{process_id}] ‚ùå‚ùå‚ùå FALHOU EM TODOS OS {len(loc_candidates)} SELETORES para CNJ '{cnj}' ‚ùå‚ùå‚ùå")
    log(f"[CNJ][ERROR][#{process_id}] Seletores testados: {list(dict.fromkeys(loc_candidates))}")
    
    # üîß FIX PROBLEMA 2: Salvar screenshot de CNJ no Process.elaw_screenshot_after_path
    try:
        png = _get_screenshot_path("cnj_nao_preenchido.png", process_id=process_id)
        await page.screenshot(path=str(png), full_page=True)
        log(f"[CNJ][FAIL] Screenshot salvo: {png}")
        send_screenshot_to_monitor(png, region="CNJ_ERROR")
        
        # Salvar caminho do screenshot no banco para UI exibir bot√£o
        if process_id and flask_app:
            try:
                from models import Process, db
                with flask_app.app_context():
                    proc = Process.query.get(process_id)
                    if proc:
                        proc.elaw_screenshot_after_path = f"rpa_screenshots/{png.name}"
                        db.session.commit()
                        log(f"[SCREENSHOT CNJ] ‚úÖ Caminho salvo no banco: {proc.elaw_screenshot_after_path}")
            except Exception as db_ex:
                log(f"[SCREENSHOT CNJ][WARN] Erro ao salvar caminho no banco: {db_ex}")
    except Exception as e:
        log(f"[CNJ][DEBUG] Erro ao capturar screenshot: {e}")
    
    return False

async def ensure_cnj_still_present(page, expected: str):
    if not expected:
        return
    locs = [f"#{i}" for i in CNJ_INPUT_IDS] + [
        "input[name='NumeroProcesso']",
        "input[placeholder*='N√∫mero do Processo' i]",
        "input[name*='cnj' i]",
    ]
    try:
        for css in locs:
            el = page.locator(css).first
            if await el.count() == 0:
                continue
            val = (await el.input_value()) or ""
            if re.sub(r"\D", "", val) == re.sub(r"\D", "", expected):
                return
        log("[CNJ] sumiu ap√≥s rerender ‚Äî recolocando")
        await set_cnj_value(page, expected)
    except Exception:
        pass


async def wait_for_cnj_autofill(page, timeout_ms: int = 12000, process_id: int = None) -> bool:
    """
    2025-11-27: Aguarda campos autom√°ticos do eLaw serem preenchidos ap√≥s inserir CNJ.
    
    O eLaw dispara AJAX ap√≥s preencher o n√∫mero do processo (CNJ) e preenche
    automaticamente campos como Estado, Comarca, Vara, Foro, etc.
    
    Args:
        page: Playwright page
        timeout_ms: Timeout m√°ximo em milissegundos (default: 12s)
        process_id: ID do processo para logging
        
    Returns:
        bool: True se pelo menos Estado foi preenchido, False se timeout
    """
    log(f"[CNJ_AUTOFILL][#{process_id}] Aguardando campos autom√°ticos (timeout={timeout_ms}ms)...")
    update_status("aguardando_autofill", "Aguardando eLaw preencher campos autom√°ticos...", process_id=process_id)
    
    start_time = time.time()
    max_wait_s = timeout_ms / 1000.0
    check_interval_ms = 500
    
    estado_filled = False
    cidade_filled = False
    
    while (time.time() - start_time) < max_wait_s:
        try:
            estado_el = page.locator('#EstadoId').first
            if await estado_el.count() > 0:
                estado_val = await estado_el.input_value()
                if estado_val and estado_val.strip() and estado_val != "0":
                    estado_filled = True
                    log(f"[CNJ_AUTOFILL][#{process_id}] ‚úÖ Estado preenchido: {estado_val}")
            
            cidade_el = page.locator('#CidadeId').first
            if await cidade_el.count() > 0:
                cidade_val = await cidade_el.input_value()
                if cidade_val and cidade_val.strip() and cidade_val != "0":
                    cidade_filled = True
                    log(f"[CNJ_AUTOFILL][#{process_id}] ‚úÖ Cidade/Comarca preenchida: {cidade_val}")
            
            if estado_filled and cidade_filled:
                elapsed = time.time() - start_time
                log(f"[CNJ_AUTOFILL][#{process_id}] ‚úÖ Campos autom√°ticos preenchidos em {elapsed:.1f}s")
                update_status("autofill_ok", "‚úÖ Campos autom√°ticos preenchidos", process_id=process_id)
                return True
                
        except Exception as e:
            log(f"[CNJ_AUTOFILL][#{process_id}] Erro ao verificar campos: {e}")
        
        await short_sleep_ms(check_interval_ms)
    
    elapsed = time.time() - start_time
    log(f"[CNJ_AUTOFILL][#{process_id}] ‚ö†Ô∏è Timeout ap√≥s {elapsed:.1f}s - Estado={estado_filled}, Cidade={cidade_filled}")
    
    if estado_filled:
        log(f"[CNJ_AUTOFILL][#{process_id}] Continuando apenas com Estado preenchido...")
        return True
    
    log(f"[CNJ_AUTOFILL][#{process_id}] ‚ùå Campos autom√°ticos n√£o foram preenchidos - CNJ pode n√£o ter sido reconhecido pelo eLaw")
    return False


# =========================
# Dom√≠nio / heur√≠sticas
# =========================
AREA_LIST = ["Administrativo", "Ambiental", "C√≠vel", "Criminal", "Fam√≠lia", "Federal", "√ìrf√£os", "Trabalhista", "Tribut√°rio"]

def resolve_sistema_eletronico(data: Dict[str, Any]) -> str:
    bag = " ".join(str(v or "") for v in data.values())
    s = norm(bag)
    if re.search(r"\b(e-?proc)\b", s):
        return "E-PROC"
    if "projudi" in s:
        return "PROJUDI"
    if "juizo 100" in s:
        return "Ju√≠zo 100% Digital - PJE"
    if "pje" in s:
        return "PJE"
    # Usar PDF espec√≠fico do processo (evita mistura de dados)
    text = data.get("_pdf_text") or read_pdf_api_all_text()
    if not data.get("_pdf_text"):
        log("[resolve_sistema_eletronico][WARN] Usando PDF gen√©rico - data['_pdf_text'] n√£o encontrado")
    s = norm(text)
    if "e-proc" in s or "eproc" in s:
        return "E-PROC"
    if "projudi" in s:
        return "PROJUDI"
    if "juizo 100" in s:
        return "Ju√≠zo 100% Digital - PJE"
    if "pje" in s:
        return "PJE"
    return "PJE"

def resolve_area_direito(data: Dict[str, Any]) -> str:
    for k in ("area_direito", "area"):
        v = (data.get(k) or "").strip()
        if v:
            for opt in AREA_LIST:
                if norm(opt) in norm(v) or norm(v) in norm(opt):
                    return opt
    # Usar PDF espec√≠fico do processo (evita mistura de dados)
    text = data.get("_pdf_text") or read_pdf_api_all_text()
    if not data.get("_pdf_text"):
        log("[resolve_area_direito][WARN] Usando PDF gen√©rico - data['_pdf_text'] n√£o encontrado")
    s = norm(text)
    if any(w in s for w in ["trabalh", "reclamat", "clt"]):
        return "Trabalhista"
    if any(w in s for w in ["tribut", "receita federal", "icms", "iss", "iptu"]):
        return "Tribut√°rio"
    if any(w in s for w in ["criminal", "penal", "crime"]):
        return "Criminal"
    if any(w in s for w in ["ambiental", "ibama", "licenca"]):
        return "Ambiental"
    if any(w in s for w in ["administrat", "improbidade", "licitacao"]):
        return "Administrativo"
    if any(w in s for w in ["familia", "alimentos", "guarda", "divorcio"]):
        return "Fam√≠lia"
    if "federal" in s:
        return "Federal"
    return "C√≠vel"

_CNJ_R = re.compile(r"\.(\d)\.(\d{2})\.")

def _origin_from_cnj(cnj: str) -> Optional[str]:
    m = _CNJ_R.search(cnj or "")
    if not m:
        return None
    ramo, tr = m.group(1), m.group(2)
    if ramo == "5":
        return "TST" if tr == "90" else "TRT"
    return None

def resolve_origem_final(data: Dict[str, Any], area_txt: str, pdf_text: str) -> str:
    for k in ("origem", "origem_sigla"):
        v = (data.get(k) or "").strip().upper()
        if v in {
            "TRT",
            "TST",
            "TRF",
            "JF",
            "STJ",
            "STF",
            "PROCON",
            "PREFEITURA",
            "RECEITA FEDERAL",
            "√ìRG√ÉO ADMINISTRATIVO",
        }:
            return v
    cnj = (data.get("numero_processo") or "").strip()
    o = _origin_from_cnj(cnj)
    if o:
        return o
    s = norm((area_txt or "") + " " + (pdf_text or ""))
    if "trabalh" in s:
        if re.search(r"\btribunal superior do trabalho\b|\bno\s+tst\b|\borgao\s*:\s*tst\b", s):
            return "TST"
        return "TRT"
    if "procon" in s:
        return "PROCON"
    if "prefeitura" in s or "municip" in s:
        return "PREFEITURA"
    if "receita federal" in s or "carf" in s:
        return "RECEITA FEDERAL"
    if "stj" in s:
        return "STJ"
    if "stf" in s:
        return "STF"
    if "trf" in s or "justica federal" in s:
        return "TRF"
    if "jf" in s:
        return "JF"
    if "orgao administrativo" in s:
        return "√ìRG√ÉO ADMINISTRATIVO"
    return "TRT"

def _coerce_numero_orgao(v: Any, default: int = 1) -> str:
    if v is None:
        n = default
    else:
        s = str(v).strip()
        m = re.search(r"\d+", s)
        n = int(m.group(0)) if m else default
    if n < 1 or n > 99:
        n = default
    return f"{n:02d}"

# =========================
# C√âLULA mapping (docx/json + aliases)
# =========================
def _load_cell_map_from_json(json_path: str) -> Dict[str, str]:
    try:
        if json_path and os.path.exists(json_path):
            with open(json_path, "r", encoding="utf-8") as f:
                raw = json.load(f) or {}
            return {norm(k): str(v).strip() for k, v in raw.items() if str(k).strip() and str(v).strip()}
    except Exception as e:
        log(f"[C√âLULA][WARN] JSON map: {e}")
    return {}

def _load_cell_map_from_docx(paths: List[str]) -> Dict[str, str]:
    out: Dict[str, str] = {}
    if DocxDocument is None:
        return out
    for p in paths:
        p = p.strip()
        if not p or not os.path.exists(p):
            continue
        try:
            doc = DocxDocument(p)  # type: ignore
            for tb in doc.tables:
                for i, row in enumerate(tb.rows):
                    try:
                        cols = [(c.text or "").strip() for c in row.cells]
                    except Exception:
                        cols = []
                    if not cols:
                        continue
                    cel = (cols[0] if len(cols) >= 1 else "").strip()
                    cli = (cols[1] if len(cols) >= 2 else "").strip()
                    pit = (cols[2] if len(cols) >= 3 else "").strip()
                    if cel and cli:
                        out[norm(cli)] = cel.strip()
                    if cel and pit:
                        out[norm(pit)] = cel.strip()
        except Exception as e:
            log(f"[C√âLULA][WARN] DOCX '{p}': {e}")
    return out

def _canonical_cell_label(celula: str) -> str:
    n = norm(celula)
    if "gpa" in n or "pao de acucar" in n or "p√£o de a√ß√∫car" in n or "companhia brasileira de distribuicao" in n or "sendas" in n:
        return "Trabalhista GPA"
    if "pro" in n and "pharm" in n:
        return "Trabalhista Pro Pharma"
    if "prudential" in n:
        return "Trabalhista Prudential"
    if "casas bahia" in n or "globex" in n or "cnova" in n or "banqi" in n:
        return "Trabalhista Casas Bahia"
    if "csn" in n or "companhia siderurgica nacional" in n or "cbsi" in n or "prada" in n or "sepetiba tecon" in n or "csn mineracao" in n:
        return "Trabalhista CSN"
    if "outros" in n:
        return "Trabalhista Outros Clientes"
    return celula.strip()

def _build_brand_synonyms() -> Dict[str, str]:
    pairs = {
        "gpa": "Trabalhista GPA",
        "grupo pao de acucar": "Trabalhista GPA",
        "p√£o de a√ß√∫car": "Trabalhista GPA",
        "companhia brasileira de distribuicao": "Trabalhista GPA",
        "cbd": "Trabalhista GPA",
        "sendas distribuidora": "Trabalhista GPA",
        "pao de acucar": "Trabalhista GPA",
        "casas bahia": "Trabalhista Casas Bahia",
        "viavarejo": "Trabalhista Casas Bahia",
        "via varejo": "Trabalhista Casas Bahia",
        "globex": "Trabalhista Casas Bahia",
        "cnova": "Trabalhista Casas Bahia",
        "banqi": "Trabalhista Casas Bahia",
        "bartira": "Trabalhista Casas Bahia",
        "integra solucoes para varejo": "Trabalhista Casas Bahia",
        "cnt log": "Trabalhista Casas Bahia",
        "csn": "Trabalhista CSN",
        "companhia siderurgica nacional": "Trabalhista CSN",
        "cbsi": "Trabalhista CSN",
        "prada": "Trabalhista CSN",
        "sepetiba tecon": "Trabalhista CSN",
        "csn mineracao": "Trabalhista CSN",
        "csn cimentos": "Trabalhista CSN",
        "fundacao csn": "Trabalhista CSN",
        "profarma": "Trabalhista Pro Pharma",
        "d1000": "Trabalhista Pro Pharma",
        "d 1000": "Trabalhista Pro Pharma",
        "pro pharma": "Trabalhista Pro Pharma",
        "prudential": "Trabalhista Prudential",
    }
    return {norm(k): v for k, v in pairs.items()}

def _load_cell_mapping() -> Dict[str, str]:
    mapping: Dict[str, str] = {}
    mapping.update(_load_cell_map_from_json(RPA_CELL_JSON_PATH))
    mapping.update(_load_cell_map_from_docx(RPA_CELL_DOCX_PATHS))
    for k, v in _build_brand_synonyms().items():
        mapping.setdefault(k, v)
    mapping = {k: _canonical_cell_label(v) for k, v in mapping.items()}
    return mapping

def _score_text_hit(hay: str, needle: str, base: int) -> int:
    h = norm(hay)
    n = norm(needle)
    return base if n and n in h else 0

def decide_celula_from_sources(data: Dict[str, Any], pdf_text: str, options: List[str]) -> Tuple[str, str]:
    if not options:
        opt = (data.get("celula") or "").strip()
        if opt:
            return (_canonical_cell_label(opt), f"data.celula='{opt}'")
        area = (data.get("area_direito") or "").strip()
        if "trabalh" in norm(area):
            return ("Trabalhista Outros Clientes", "sem op√ß√µes; √°rea trabalhista")
        return ((data.get("celula") or "Em Segredo").strip() or "Em Segredo", "sem op√ß√µes; fallback")
    explicit = (data.get("celula") or data.get("escritorio") or "").strip()
    if explicit:
        bm = _best_match(options, _canonical_cell_label(explicit), threshold=10)
        if bm:
            return (bm, f"data.celula='{explicit}'")
    mapping = _load_cell_mapping()
    ctx_fields = [
        ("cliente", 5),
        ("parte_interessada", 5),
        ("parte_adversa", 2),
        ("empresa", 3),
        ("grupo", 5),
        ("assunto", 1),
        ("objeto", 1),
    ]
    bag = " ".join(str(v or "") for v in data.values())
    best_label = ""
    best_score = 0
    reason = ""
    for key, base in ctx_fields:
        val = str(data.get(key) or "")
        if not val:
            continue
        for alias, cell in mapping.items():
            sc = _score_text_hit(val, alias, base)
            if sc > 0:
                sc += 2 if key in {"cliente", "parte_interessada", "grupo"} else 0
                if sc > best_score:
                    best_label = cell
                    best_score = sc
                    reason = f"hit: {key}='{val}' ‚áí c√©lula '{cell}' (alias='{alias}')"
    if not best_label:
        check = (pdf_text or "") + " " + bag
        for alias, cell in mapping.items():
            sc = _score_text_hit(check, alias, 2)
            if sc > best_score:
                best_label = cell
                best_score = sc
                reason = f"hit: PDF/bag cont√©m '{alias}' ‚áí c√©lula '{cell}'"
    if best_label:
        match = _best_match(options, best_label, threshold=8) or _best_match(options, _canonical_cell_label(best_label), threshold=8)
        if match:
            return (match, reason or f"map '{best_label}'")
    alias_rows = load_alias_rows("config/client_aliases.json")
    alias_index = build_alias_index(alias_rows)
    pdf_pick = guess_cell_from_pdf_text(pdf_text or "", alias_index, options)
    if pdf_pick:
        return (pdf_pick, "utils.aliases por PDF")
    area = resolve_area_direito(data)
    if "trabalh" in norm(area):
        bm = _best_match(options, "Trabalhista Outros Clientes", threshold=1)
        if bm:
            return (bm, "fallback trabalhista")
    non_brand = [o for o in options if not any(k in norm(o) for k in ["gpa", "csn", "bahia", "pro pharma", "prudential"])]
    if non_brand:
        return (non_brand[0], "fallback non-brand")
    return (options[0], "fallback first")

# =========================
# ‚ÄúTipo de processo‚Äù ‚Äî Eletr√¥nico/F√≠sico
# =========================
RADIO_VIRTUAL_NAMES = ["IsProcessoVirtual", "ProcessoVirtual", "IsVirtual", "ProcessoEletronico", "IsEletronico"]

async def set_tipo_processo_virtual(page, want_virtual: bool = True) -> bool:
    try:
        want_label = "eletronico" if want_virtual else "fisico"
        # 1) Por label
        try:
            label_text = "Eletr√¥nico" if want_virtual else "F√≠sico"
            lab = page.locator(f"label:has-text('{label_text}')").first
            if await lab.count():
                await _scroll_into_view(lab)
                try:
                    await lab.click(force=True)
                except Exception:
                    pass
                changed = await page.evaluate(
                    """(labelTextNorm)=>{
                    const norm=(s)=> (s||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase();
                    const labs=[...document.querySelectorAll('label')];
                    for(const l of labs){
                        if(norm(l.textContent||'').includes(labelTextNorm)){
                            const input = l.control || l.querySelector('input[type="radio"]');
                            if(input){
                                try{
                                    input.checked = true;
                                    for(const ev of ['click','input','change']){
                                        input.dispatchEvent(new Event(ev,{bubbles:true}));
                                    }
                                    return true;
                                }catch(e){}
                            }
                        }
                    }
                    return false;
                }""",
                    want_label,
                )
                if changed:
                    await wait_network_quiet(page, timeout_ms=800)
                    return True
        except Exception:
            pass

        # 2) Por name/value
        truthy_vals = ["1", "true", "on", "eletronico", "eletr√¥nico", "e", "sim"]
        falsy_vals = ["0", "false", "off", "fisico", "f√≠sico", "f", "nao", "n√£o"]
        wanted_vals = truthy_vals if want_virtual else falsy_vals
        names_try = RADIO_VIRTUAL_NAMES + ["TipoProcesso", "Processo", "Tipo", "tipo_processo"]

        for nm in names_try:
            try:
                radios = page.locator(f"input[type='radio'][name='{nm}']")
                cnt = await radios.count()
                if cnt == 0:
                    continue
                chosen = None
                for i in range(cnt):
                    r = radios.nth(i)
                    v = (await r.get_attribute("value")) or ""
                    if norm(v) in [norm(x) for x in wanted_vals]:
                        chosen = r
                        break
                if not chosen:
                    for i in range(cnt):
                        r = radios.nth(i)
                        lab_text = await r.evaluate(
                            """(el)=>{
                            const lab = el.id ? document.querySelector(`label[for="${el.id}"]`) : (el.closest('label') || el.parentElement?.querySelector('label'));
                            return (lab && (lab.textContent||'').trim()) || '';
                        }"""
                        )
                        if norm(lab_text).find(want_label) >= 0:
                            chosen = r
                            break
                if chosen:
                    await _scroll_into_view(chosen)
                    
                    # üîß BATCH FIX: Se j√° estiver marcado, for√ßar toggle via CLICK para disparar AJAX do CNJ
                    is_checked = await chosen.is_checked()
                    if is_checked and want_virtual:
                        # Se queremos Eletr√¥nico e J√Å EST√Å Eletr√¥nico, o AJAX pode n√£o ter rodado se a p√°gina foi cacheada.
                        # T√°tica: Clicar em F√≠sico via DOM interaction e voltar para Eletr√¥nico para for√ßar eventos change/input
                        log("[RADIO] J√° est√° Eletr√¥nico - For√ßando toggle via CLICK para disparar AJAX do CNJ...")
                        try:
                            # Buscar qualquer outro r√°dio do grupo (n√£o-checked) e clicar
                            other_radio = await page.evaluate(
                                """(name, currentValue) => {
                                    const radios = document.querySelectorAll(`input[type='radio'][name='${name}']`);
                                    for (const r of radios) {
                                        if (r.value !== currentValue && !r.checked) {
                                            r.click();  // Dispara evento change no r√°dio perdedor
                                            return true;
                                        }
                                    }
                                    return false;
                                }""",
                                nm,
                                await chosen.get_attribute("value") or ""
                            )
                            if other_radio:
                                log("[RADIO] Clicou em outro r√°dio para desmarcar Eletr√¥nico")
                                # Aguardar AJAX do F√≠sico completar antes de voltar ao Eletr√¥nico
                                await wait_network_quiet(page, timeout_ms=800)
                                await short_sleep_ms(150)
                        except Exception as e:
                            log(f"[RADIO][WARN] Erro ao clicar em outro r√°dio: {e}")
                    
                    # Clicar no r√°dio desejado (Eletr√¥nico) - sempre dispara eventos
                    try:
                        await chosen.click(force=True)
                    except Exception:
                        try:
                            parent = chosen.locator("xpath=ancestor::*[contains(@class,'iradio_')][1]").first
                            helper = parent.locator("ins.iCheck-helper").first
                            if await helper.count() > 0:
                                await helper.click()
                        except Exception:
                            pass
                    try:
                        await page.evaluate(
                            """(nm)=>{
                            const el=document.querySelector(`input[type='radio'][name='${nm}']:checked`);
                            if(el){
                                for(const ev of ['click','input','change']){
                                    try{ el.dispatchEvent(new Event(ev,{bubbles:true})) }catch(e){}
                                }
                            }
                        }""",
                            nm,
                        )
                    except Exception:
                        pass
                    await wait_network_quiet(page, timeout_ms=700)
                    return True
            except Exception:
                continue
    except Exception:
        pass
    return False

# =========================
# Campos Trabalhistas (Data, Texto)
# =========================
async def set_text_field_by_id(page, field_id: str, value: str, field_name: str) -> bool:
    """
    Preenche um campo de texto simples por ID.
    """
    if not value:
        return False
    
    try:
        selector = f"#{field_id}"
        el = page.locator(selector).first
        
        if await el.count() == 0:
            log(f"[{field_name}][WARN] Campo #{field_id} n√£o encontrado")
            return False
        
        await _scroll_into_view(el)
        
        # Remover readonly se existir
        try:
            await el.evaluate("e=>{ e.removeAttribute('readonly'); e.disabled=false; }")
        except Exception:
            pass
        
        # Limpar e preencher campo
        await el.click()
        await el.press("Control+A")
        await el.press("Backspace")
        await el.type(str(value), delay=TYPE_DELAY_MS)
        
        # Disparar eventos
        await el.evaluate("""el => {
            ['input', 'change', 'blur'].forEach(ev => {
                try { el.dispatchEvent(new Event(ev, {bubbles: true})); } catch(e) {}
            });
        }""")
        
        log(f"[{field_name}] ‚úÖ Preenchido: {value}")
        return True
        
    except Exception as e:
        log(f"[{field_name}][WARN] Erro ao preencher: {e}")
        return False

async def set_date_field_by_id(page, field_id: str, date_value: str, field_name: str) -> bool:
    """
    Preenche um campo de data (formato DD/MM/YYYY).
    """
    if not date_value:
        return False
    
    try:
        selector = f"#{field_id}"
        el = page.locator(selector).first
        
        if await el.count() == 0:
            log(f"[{field_name}][WARN] Campo #{field_id} n√£o encontrado")
            return False
        
        await _scroll_into_view(el)
        
        # Remover readonly se existir
        try:
            await el.evaluate("e=>{ e.removeAttribute('readonly'); e.disabled=false; }")
        except Exception:
            pass
        
        # Limpar e preencher campo
        await el.click()
        await el.press("Control+A")
        await el.press("Backspace")
        
        # Preencher data (formato DD/MM/YYYY)
        await el.type(str(date_value), delay=TYPE_DELAY_MS)
        
        # Disparar eventos para datepicker
        await el.evaluate("""el => {
            ['input', 'change', 'blur', 'keyup'].forEach(ev => {
                try { el.dispatchEvent(new Event(ev, {bubbles: true})); } catch(e) {}
            });
        }""")
        
        log(f"[{field_name}] ‚úÖ Preenchido: {date_value}")
        return True
        
    except Exception as e:
        log(f"[{field_name}][WARN] Erro ao preencher: {e}")
        return False

# =========================
# Valor da Causa
# =========================
def _money_variants(raw: str) -> List[str]:
    s = (raw or "").strip()
    s = re.sub(r"[^\d,\.]", "", s)
    if not s:
        return []
    digits = re.sub(r"[^\d]", "", s)
    v = []
    if "," in s:
        v.append(s)
    if "." in s:
        v.append(s)
    if len(digits) >= 3:
        v.append(digits[:-2] + "," + digits[-2:])
        v.append(digits[:-2] + "." + digits[-2:])
    v.append(digits)
    out = []
    seen = set()
    for x in v:
        if x and x not in seen:
            seen.add(x)
            out.append(x)
    return out

async def _type_text_slow(el, text: str, delay: int):
    try:
        await el.click()
        try:
            await el.press("Control+A")
        except Exception:
            pass
        try:
            await el.press("Backspace")
        except Exception:
            pass
        if text:
            await el.type(text, delay=delay)
    except Exception:
        pass

async def set_valor_causa_any(page, valor: str) -> bool:
    if not valor:
        return False
    candidatos = [
        "#ValorCausa",
        "input#ValorCausa",
        "input[name*='Valor'][name*='Causa' i]",
        "input[id*='Valor'][id*='Causa' i]",
        "input[placeholder*='Valor da Causa' i]",
        "input.money",
        "input.currency",
        "input[class*='valor' i]",
    ]
    variants = _money_variants(valor) or [re.sub(r"[^\d]", "", valor or "")]
    for css in dict.fromkeys(candidatos):
        try:
            el = page.locator(css).first
            if await el.count() == 0:
                continue
            await _scroll_into_view(el)
            try:
                await el.evaluate("e=>{ e.removeAttribute('readonly'); e.disabled=false; }")
            except Exception:
                pass

            plugin_ok = await page.evaluate(
                """(sel, vs)=>{
              const el=document.querySelector(sel); if(!el) return false;
              const trySet=(val)=>{
                try{
                  const $=window.jQuery||window.$;
                  if ($ && ($(el).data && ($(el).data('autoNumeric') || $(el).autoNumeric))){
                    try{ $(el).autoNumeric('set', val); return true; }catch(e){}
                  }
                }catch(e){}
                try{ if(el.inputmask && el.inputmask.setValue){ el.inputmask.setValue(val); return true; } }catch(e){}
                try{
                  const w = (window.kendo||{}).ui && (window.jQuery||window.$) && ( (window.jQuery||window.$)(el).data && (window.jQuery||window.$)(el).data('kendoNumericTextBox') );
                  if (w){ w.value(parseFloat(String(val).replace('.','').replace(',','.'))); w.trigger('change'); return true; }
                }catch(e){}
                return false;
              };
              for(const v of vs){
                if(trySet(v)){
                  for(const ev of ['input','keyup','change','blur']){ try{ el.dispatchEvent(new Event(ev,{bubbles:true})) }catch(e){} }
                  return true;
                }
              }
              return false;
            }""",
                css,
                variants,
            )
            if plugin_ok:
                log(f"[FORM] Valor da Causa (plugin): {variants[0]} ({css})")
                return True

            for v in variants + [re.sub(r"[^\d]", "", variants[0] if variants else valor)]:
                await _type_text_slow(el, v, TYPE_DELAY_MS)
                await short_sleep_ms(90)
                val = (await el.input_value()) or ""
                if re.search(r"\d", val):
                    log(f"[FORM] Valor da Causa: {val} ({css})")
                    return True
        except Exception:
            continue
    ok = await set_input_by_label_contains(page, "valor da causa", variants[0] if variants else valor, "Valor da Causa")
    if ok:
        return True
    log("[FORM][WARN] Valor da Causa n√£o encontrado")
    return False

# =========================
# Picks inteligentes
# =========================
def pick_tipo_acao_smart(opts, data, pdf_text, assunto_sel):
    """
    Decide o 'Tipo de A√ß√£o' (select id=TipoAcaoId) a partir do PDF e metadados.

    Regras principais:
      - Em contexto TRABALHISTA, NUNCA escolher itens "constitucional".
      - Prioriza √¢ncoras de rito extra√≠das do PDF:
          ‚Ä¢ "Classe judicial: A√ß√£o Trabalhista - Rito Ordin√°rio/Sumar√≠ssimo"
          ‚Ä¢ "UNA SUMAR√çSSIMO"
          ‚Ä¢ "rito ordin√°rio/sumar√≠ssimo"
      - Cautelar s√≥ quando detectado E permitido (RPA_DISALLOW_CAUTELAR == False),
        e apenas se o r√≥tulo contiver 'cautelar/liminar/tutela'.
      - Sumar√≠ssimo apenas quando detectado com clareza.
      - Ordin√°rio ‚Üí preferir "(100% DIGITAL - PJE)" e depois "(PJE)".
      - Fallback seguro favorecendo op√ß√µes com 'trabalh' no nome.
    """
    if not opts:
        return None

    # -----------------------------
    # Contexto consolidado
    bag = " ".join(str(data.get(k) or "") for k in ("assunto", "sub_area_direito", "objeto", "classe", "tipo_acao"))
    ctx = norm(" ".join([assunto_sel or "", bag, pdf_text or ""]))

    def has(*terms: str) -> bool:
        return any(norm(t) in ctx for t in terms)

    # -----------------------------
    # √Çncoras de rito diretamente do PDF (fortes)
    RE_CLASSE = re.compile(
        r"classe\s+judicial\s*:\s*a[c√ß][a√£]o\s+trabalhista\s*-\s*rito\s*(ordin[√°a]rio|sumar[√≠i]ssimo)",
        re.I
    )
    RE_UNA_SUM = re.compile(r"\buna\b[^\n]{0,60}sumar[√≠i]ssim", re.I)
    RE_RITO_TXT = re.compile(r"rito\s+(ordin[√°a]rio|sumar[√≠i]ssimo)", re.I)

    def _scan_rito_anchor(txt: str) -> str | None:
        s = txt or ""
        m = RE_CLASSE.search(s)
        if m:
            hit = m.group(1)
            return "sumar√≠ssimo" if "sumar" in norm(hit) else "ordin√°rio"
        if RE_UNA_SUM.search(s):
            return "sumar√≠ssimo"
        m = RE_RITO_TXT.search(s)
        if m:
            hit = m.group(1)
            return "sumar√≠ssimo" if "sumar" in norm(hit) else "ordin√°rio"
        return None

    hint = _scan_rito_anchor(pdf_text or "")

    # -----------------------------
    # Sinais de alto n√≠vel
    is_trabalhista = ("trabalh" in ctx) or has(
        "reclama√ß√£o trabalhista", "reclamatoria trabalhista", "a√ß√£o trabalhista", "acao trabalhista"
    )
    is_reclamacao = has("reclama√ß√£o", "reclamacao", "reclamat√≥ria", "reclamatoria") or is_trabalhista

    # Se houver "hint" do PDF, ele manda. Sem hint, ca√≠mos nas heur√≠sticas.
    is_sumarissimo = (hint == "sumar√≠ssimo") or has("sumar√≠ssimo", "sumarissimo", "rito sumar√≠ssimo", "rito sumarissimo")
    is_ordinario   = (hint == "ordin√°rio") or (not is_sumarissimo and has("rito ordin√°rio", "rito ordinario", "procedimento comum", "ordin√°rio", "ordinario"))

    # Detec√ß√£o de cautelar APENAS no cabe√ßalho/t√≠tulo (primeiros 2000 caracteres),
    # N√ÉO no corpo inteiro do texto (para evitar falsos positivos de men√ß√µes nos pedidos)
    pdf_header = (pdf_text or "")[:2000]
    pdf_header_norm = norm(pdf_header)
    is_cautelar_in_header = any(t in pdf_header_norm for t in [
        "pedido cautelar", "cautelar", 
        "tutela de urgencia", "tutela de urg√™ncia",
        "liminar", "tutela antecipada",
        "mandado de seguran√ßa com", "mandado de seguranca com"
    ])
    
    # PRIORIDADE ABSOLUTA: Se o PDF declarou explicitamente o rito (ordin√°rio/sumar√≠ssimo)
    # no cabe√ßalho (classe judicial/a√ß√£o trabalhista), isso SOBREP√ïE qualquer detec√ß√£o de cautelar.
    # Exemplo: PDF com "A√ß√£o Trabalhista - Rito Ordin√°rio" + men√ß√£o a "liminar" nos pedidos
    # ‚Üí deve ser "Reclama√ß√£o Trabalhista (Ordin√°rio)", N√ÉO "Reclama√ß√£o com Pedido Cautelar"
    if hint in ("ordin√°rio", "sumar√≠ssimo"):
        is_cautelar = False
        log(f"[TipoA√ß√£o] ‚≠ê Rito expl√≠cito '{hint}' detectado no PDF ‚Üí cautelar=False (prioridade)")
    else:
        is_cautelar = is_cautelar_in_header
        if is_cautelar:
            log(f"[TipoA√ß√£o] ‚ö†Ô∏è Cautelar detectado no cabe√ßalho (sem rito expl√≠cito)")
        else:
            log(f"[TipoA√ß√£o] Sem cautelar detectado")

    # Respeita ENV p/ cautelar
    try:
        disallow_caut = bool(RPA_DISALLOW_CAUTELAR)  # type: ignore[name-defined]
    except Exception:
        disallow_caut = True
    if disallow_caut:
        is_cautelar = False

    # -----------------------------
    # Poda inicial dos candidatos
    cand = list(opts)

    # Em TRABALHISTA: nunca pegar "constitucional"
    if is_trabalhista:
        _cand = [o for o in cand if "constitucional" not in norm(o)]
        cand = _cand or cand

    # Se o PDF disse "ordin√°rio", removemos sumar√≠ssimo E cautelar para reduzir ru√≠do
    if hint == "ordin√°rio":
        _cand = [o for o in cand if "sumar" not in norm(o)]
        cand = _cand or cand
        # REMOVE cautelar quando h√° rito ordin√°rio expl√≠cito
        _cand = [o for o in cand if not any(k in norm(o) for k in ("cautelar", "liminar", "tutela"))]
        if _cand:
            cand = _cand
            log(f"[TipoA√ß√£o] Filtrado cautelar devido ao rito ordin√°rio expl√≠cito ‚Üí {len(cand)} op√ß√µes restantes")
    # Se o PDF disse "sumar√≠ssimo", removemos cautelar tamb√©m
    elif hint == "sumar√≠ssimo":
        _cand = [o for o in cand if not any(k in norm(o) for k in ("cautelar", "liminar", "tutela"))]
        if _cand:
            cand = _cand
            log(f"[TipoA√ß√£o] Filtrado cautelar devido ao rito sumar√≠ssimo expl√≠cito ‚Üí {len(cand)} op√ß√µes restantes")
    # Se n√£o houve hint e n√£o detectamos sumar√≠ssimo, tamb√©m removemos sumar√≠ssimo
    elif hint is None and not is_sumarissimo:
        _cand = [o for o in cand if "sumar" not in norm(o)]
        cand = _cand or cand

    # -----------------------------
    # 1) Regra principal: Reclama√ß√£o Trabalhista
    if is_reclamacao:
        # 1.a) Cautelar? (somente se permitido e r√≥tulo contiver a palavra)
        if is_cautelar:
            cand_caut = [o for o in cand if any(k in norm(o) for k in ("cautelar", "liminar", "tutela"))]
            if cand_caut:
                m = (
                    _best_match(cand_caut, "Reclama√ß√£o com Pedido Cautelar",
                                prefer_words=["reclama", "trabalh", "cautelar"], threshold=20)
                    or _best_match(cand_caut, "A√ß√£o Cautelar",
                                   prefer_words=["cautelar"], threshold=20)
                )
                if m:
                    log(f"[TipoA√ß√£o] ‚úÖ ESCOLHIDO (cautelar): {m}")
                    return m

        # 1.b) Sumar√≠ssimo?
        if is_sumarissimo:
            for p in (
                "Reclama√ß√£o Trabalhista Procedimento Sumar√≠ssimo (PJE)",
                "Reclama√ß√£o Trabalhista Rito Sumar√≠ssimo (100% Digital - PJE)",
                "RECLAMA√á√ÉO TRABALHISTA PROCEDIMENTO SUMAR√çSSIMO (PJE)",
            ):
                m = _best_match(cand, p, prefer_words=["reclama", "trabalh", "sumar"], threshold=12)
                if m:
                    log(f"[TipoA√ß√£o] ‚úÖ ESCOLHIDO (sumar√≠ssimo): {m}")
                    return m

        # 1.c) Ordin√°rio / padr√£o ‚Üí preferir (100% DIGITAL - PJE) e depois (PJE)
        if is_ordinario or not is_sumarissimo:
            for p in (
                "RECLAMA√á√ÉO TRABALHISTA (100% DIGITAL - PJE)",
                "Reclama√ß√£o Trabalhista (100% DIGITAL - PJE)",
                "RECLAMA√á√ÉO TRABALHISTA (PJE)",
                "Reclama√ß√£o Trabalhista (PJE)",
                "Reclama√ß√£o Trabalhista",
                "Reclamat√≥ria Trabalhista",
            ):
                m = _best_match(cand, p, prefer_words=["reclama", "trabalh", "pje", "digital"], threshold=10)
                if m:
                    log(f"[TipoA√ß√£o] ‚úÖ ESCOLHIDO (ordin√°rio): {m}")
                    return m

    # -----------------------------
    # 2) Outra classe comum: Consigna√ß√£o em Pagamento
    if has("consigna√ß√£o", "consignacao"):
        for p in ("A√ß√£o de Consigna√ß√£o em Pagamento (100% PJE)", "A√á√ÉO DE CONSIGNA√á√ÉO EM PAGAMENTO"):
            m = _best_match(cand, p, prefer_words=["consign"], threshold=12)
            if m:
                dlog(f"[TipoA√ß√£o] escolhido (consigna√ß√£o): {m}")
                return m

    # -----------------------------
    # 3) Tentativa por metadados vindos do sistema (classe/tipo/assunto)
    for k in ("tipo_acao", "classe", "assunto"):
        v = (data.get(k) or "").strip()
        if v:
            m = _best_match(cand, v, threshold=12)
            if m:
                dlog(f"[TipoA√ß√£o] escolhido (metadata:{k}): {m}")
                return m

    # -----------------------------
    # 4) Fallbacks
    if is_trabalhista:
        labor = [o for o in cand if "trabalh" in norm(o)]
        if labor:
            m = (
                _best_match(labor, "Reclama√ß√£o Trabalhista (PJE)", prefer_words=["reclama", "trabalh", "pje"], threshold=5)
                or labor[0]
            )
            dlog(f"[TipoA√ß√£o] fallback trabalhista: {m}")
            return m

    # Evita cair em cautelar/tutela por engano no fallback
    plain = [o for o in cand if not any(k in norm(o) for k in ("cautelar", "liminar", "tutela"))] if disallow_caut else cand
    choice = plain[0] if plain else (cand[0] if cand else None)
    dlog(f"[TipoA√ß√£o] fallback: {choice}")
    return choice



def pick_objeto_smart(opts: List[str], data: Dict[str, Any], pdf_text: str, assunto_sel: str, tipo_sel: str) -> Optional[str]:
    if not opts:
        return None
    prefer = []
    for k in ("objeto", "classe", "classe_processual", "tema", "assunto", "sub_assunto", "tipo_acao"):
        v = (data.get(k) or "").strip()
        if v:
            prefer.append(v)
    if assunto_sel:
        prefer.append(assunto_sel)
    if tipo_sel:
        prefer.append(tipo_sel)
    prefer += [
        "Reclama√ß√£o Trabalhista",
        "A√ß√£o Trabalhista",
        "Verbas Rescis√≥rias",
        "Horas Extras",
        "Danos Morais",
        "Rescis√£o Indireta",
        "Diferen√ßas Salariais",
        "FGTS",
    ]
    if "cautelar" in norm(pdf_text or ""):
        prefer = ["A√ß√£o Cautelar"] + prefer
    for p in prefer:
        m = _best_match(opts, p, threshold=12)
        if m:
            return m
    return opts[0]

# =========================
# Dados de entrada
# =========================
def _http_get_json(url: str, timeout: int = 8) -> dict:
    try:
        r = requests.get(url, timeout=timeout)
        if r.status_code == 200:
            return r.json() or {}
    except Exception:
        pass
    return {}

def load_process_data_for_fill(process_id: Optional[int] = None) -> Dict[str, Any]:
    jur_api = os.getenv("JURIDICO_LAST_PROCESS_ENDPOINT", "").strip()
    if jur_api:
        d = _http_get_json(jur_api)
        if d and (d.get("numero_processo") or d.get("tipo_processo") or d.get("sistema_eletronico")):
            log("[DATA] Sistema Jur√≠dico (endpoint) OK")
            return d

    try:
        from app import create_app  # type: ignore
        from models import db, Process  # type: ignore
        
        app = create_app()
        with app.app_context():  # type: ignore
            if process_id:
                p = Process.query.get(process_id)
                if p:
                    data = {k: getattr(p, k, "") or "" for k in [
                        "numero_processo", "tipo_processo", "sistema_eletronico", "numero_processo_antigo",
                        "area_direito", "sub_area_direito", "origem", "orgao", "numero_orgao",
                        "comarca", "estado", "assunto", "objeto", "celula",
                        "cliente", "parte_interessada", "parte_adversa_nome", "empresa", "grupo",
                        "posicao_parte_interessada", "parte_adversa_tipo", "valor_causa", "estrategia",
                        "escritorio_parte_adversa", "cpf_cnpj_parte_adversa", "telefone_parte_adversa",
                        "email_parte_adversa", "endereco_parte_adversa", "cnj", "pdf_filename",
                        "audiencia_inicial", "cadastrar_primeira_audiencia",
                        "link_audiencia", "subtipo_audiencia", "envolvido_audiencia",
                        "data_distribuicao", "data_admissao", "data_demissao", "motivo_demissao", "salario", 
                        "cargo_funcao", "cargo", "empregador", "local_trabalho", "pis", "ctps",
                        "outra_reclamada_cliente"  # ‚úÖ Adicionado para reclamadas extras do banco
                    ]}
                    
                    # M√öLTIPLAS RECLAMADAS: Extrair do PDF se existir
                    pdf_filename = data.get("pdf_filename", "")
                    pdf_path = None
                    if pdf_filename:
                        # Tentar caminho completo primeiro (batch: uploads/batch/68/arquivo.pdf)
                        if Path(pdf_filename).exists():
                            pdf_path = Path(pdf_filename)
                        # Fallback: tentar dentro do UPLOADS_DIR
                        elif UPLOADS_DIR.exists():
                            pdf_path = UPLOADS_DIR / pdf_filename
                            if not pdf_path.exists():
                                # Tentar apenas o nome do arquivo no UPLOADS_DIR
                                pdf_path = UPLOADS_DIR / Path(pdf_filename).name
                                if not pdf_path.exists():
                                    pdf_path = None
                    
                    if pdf_path and pdf_path.exists():
                        try:
                            from extractors.regex_utils import extract_todas_reclamadas
                            from PyPDF2 import PdfReader
                            reader = PdfReader(str(pdf_path))
                            pdf_text = "\n".join([pg.extract_text() or "" for pg in reader.pages])
                            reclamadas = extract_todas_reclamadas(pdf_text)
                            data["reclamadas"] = reclamadas
                            log(f"[DATA] Reclamadas extra√≠das do PDF ({pdf_path}): {len(reclamadas)}")
                        except Exception as e:
                            log(f"[DATA][WARN] Erro ao extrair reclamadas: {e}")
                            data["reclamadas"] = []
                    else:
                        log(f"[DATA][WARN] PDF n√£o encontrado: {pdf_filename}")
                        data["reclamadas"] = []
                    
                    # üîß 2025-11-27: FALLBACK - Se n√£o extraiu do PDF, usar outra_reclamada_cliente do banco
                    if len(data.get("reclamadas", [])) <= 1:
                        outra_reclamada = (data.get("outra_reclamada_cliente") or "").strip()
                        if outra_reclamada:
                            log(f"[DATA][RECLAMADAS] Usando outra_reclamada_cliente do banco: {outra_reclamada}")
                            # Criar lista de reclamadas com parte_adversa + outra_reclamada
                            reclamadas_from_db = []
                            
                            # Primeira reclamada = parte_adversa_nome (a principal)
                            parte_adversa = (data.get("parte_adversa_nome") or "").strip()
                            
                            # üîß 2025-11-27: DEDUPLICA√á√ÉO - Verificar se outra_reclamada √© diferente de parte_adversa
                            # Normalizar para compara√ß√£o (ignorar case, espa√ßos extras)
                            parte_normalizada = parte_adversa.upper().strip() if parte_adversa else ""
                            outra_normalizada = outra_reclamada.upper().strip()
                            
                            if parte_adversa:
                                reclamadas_from_db.append({
                                    "nome": parte_adversa,
                                    "posicao": "RECLAMADO",
                                    "tipo_pessoa": "juridica" if any(x in parte_adversa.upper() for x in ["LTDA", "S/A", "S.A.", "EIRELI", "ME", "EPP", "CIA", "COMPANHIA", "INDUSTRIA", "COMERCIO"]) else "fisica"
                                })
                            
                            # Segunda reclamada = outra_reclamada_cliente (somente se n√£o for duplicata)
                            if outra_normalizada and outra_normalizada != parte_normalizada:
                                reclamadas_from_db.append({
                                    "nome": outra_reclamada,
                                    "posicao": "RECLAMADO",
                                    "tipo_pessoa": "juridica" if any(x in outra_reclamada.upper() for x in ["LTDA", "S/A", "S.A.", "EIRELI", "ME", "EPP", "CIA", "COMPANHIA", "INDUSTRIA", "COMERCIO"]) else "fisica"
                                })
                                log(f"[DATA][RECLAMADAS] ‚úÖ Adicionada outra_reclamada: {outra_reclamada}")
                            elif outra_normalizada == parte_normalizada:
                                log(f"[DATA][RECLAMADAS] ‚ö†Ô∏è outra_reclamada √© igual a parte_adversa - ignorando duplicata")
                            
                            data["reclamadas"] = reclamadas_from_db
                            log(f"[DATA][RECLAMADAS] Lista constru√≠da do banco: {len(reclamadas_from_db)} reclamadas")
                    
                    # PEDIDOS: Carregar do campo pedidos_json
                    pedidos_json = getattr(p, 'pedidos_json', None) or ""
                    if pedidos_json:
                        try:
                            import json
                            data["pedidos"] = json.loads(pedidos_json)
                            log(f"[DATA] Pedidos carregados do banco: {len(data['pedidos'])}")
                        except Exception as e:
                            log(f"[DATA][WARN] Erro ao carregar pedidos: {e}")
                            data["pedidos"] = []
                    else:
                        data["pedidos"] = []
                    
                    # 2025-12-02: Log expandido para campos trabalhistas
                    log(f"[DATA] DB (id={process_id}) OK - CNJ: {data.get('cnj', 'N/A')}, Parte Adversa: {data.get('parte_adversa_nome', 'N/A')}")
                    log(f"[DATA] DB (id={process_id}) Trabalhista: cargo={data.get('cargo_funcao') or data.get('cargo') or 'N/A'}, pis={data.get('pis', 'N/A')}, ctps={data.get('ctps', 'N/A')}")
                    log(f"[DATA] DB (id={process_id}) PDF: {data.get('pdf_filename', 'N/A')}, Reclamadas: {len(data.get('reclamadas', []))}, Pedidos: {len(data.get('pedidos', []))}")
                    return data
            p = (
                Process.query.filter(Process.numero_processo.isnot(None), Process.numero_processo != "")
                .order_by(Process.updated_at.desc(), Process.id.desc())
                .first()
            )
            if p:
                data = {k: getattr(p, k, "") or "" for k in [
                    "numero_processo", "tipo_processo", "sistema_eletronico", "numero_processo_antigo",
                    "area_direito", "sub_area_direito", "origem", "orgao", "numero_orgao",
                    "comarca", "estado", "assunto", "objeto", "celula",
                    "cliente", "parte_interessada", "parte_adversa_nome", "empresa", "grupo",
                    "posicao_parte_interessada", "parte_adversa_tipo", "valor_causa", "estrategia",
                    "escritorio_parte_adversa", "cpf_cnpj_parte_adversa", "telefone_parte_adversa",
                    "email_parte_adversa", "endereco_parte_adversa", "cnj", "pdf_filename",
                    "audiencia_inicial", "cadastrar_primeira_audiencia",
                    "link_audiencia", "subtipo_audiencia", "envolvido_audiencia",
                    "data_distribuicao", "data_admissao", "data_demissao", "motivo_demissao", "salario", 
                    "cargo_funcao", "cargo", "empregador", "local_trabalho", "pis", "ctps"
                ]}
                
                # M√öLTIPLAS RECLAMADAS: Extrair do PDF se existir
                pdf_filename = data.get("pdf_filename", "")
                pdf_path = None
                if pdf_filename:
                    # Tentar caminho completo primeiro (batch: uploads/batch/68/arquivo.pdf)
                    if Path(pdf_filename).exists():
                        pdf_path = Path(pdf_filename)
                    # Fallback: tentar dentro do UPLOADS_DIR
                    elif UPLOADS_DIR.exists():
                        pdf_path = UPLOADS_DIR / pdf_filename
                        if not pdf_path.exists():
                            # Tentar apenas o nome do arquivo no UPLOADS_DIR
                            pdf_path = UPLOADS_DIR / Path(pdf_filename).name
                            if not pdf_path.exists():
                                pdf_path = None
                
                if pdf_path and pdf_path.exists():
                    try:
                        from extractors.regex_utils import extract_todas_reclamadas
                        from PyPDF2 import PdfReader
                        reader = PdfReader(str(pdf_path))
                        pdf_text = "\n".join([pg.extract_text() or "" for pg in reader.pages])
                        reclamadas = extract_todas_reclamadas(pdf_text)
                        data["reclamadas"] = reclamadas
                        log(f"[DATA] Reclamadas extra√≠das do PDF ({pdf_path}): {len(reclamadas)}")
                    except Exception as e:
                        log(f"[DATA][WARN] Erro ao extrair reclamadas: {e}")
                        data["reclamadas"] = []
                else:
                    log(f"[DATA][WARN] PDF n√£o encontrado: {pdf_filename}")
                    data["reclamadas"] = []
                
                log(f"[DATA] DB (√∫ltimo processo atualizado) OK - ID: {p.id}, CNJ: {data.get('cnj', 'N/A')}, Parte Adversa: {data.get('parte_adversa_nome', 'N/A')}, Reclamadas: {len(data.get('reclamadas', []))}")
                return data
    except Exception as e:
        log(f"[DATA][WARN] DB: {e}")

    try:
        if RPA_DATA_JSON and os.path.exists(RPA_DATA_JSON):
            if RPA_DATA_TTL_SECONDS > 0:
                age = datetime.now().timestamp() - os.path.getmtime(RPA_DATA_JSON)
                if age > RPA_DATA_TTL_SECONDS:
                    log(f"[DATA][WARN] JSON expirado ({age:.0f}s) ‚Äî ignorando: {RPA_DATA_JSON}")
                else:
                    with open(RPA_DATA_JSON, "r", encoding="utf-8") as f:
                        data = json.load(f) or {}
                    
                    # VALIDA√á√ÉO CR√çTICA: Verificar se o JSON √© do process_id correto
                    cached_pid = data.get("_cache_process_id")
                    if process_id is not None and cached_pid is not None:
                        if int(cached_pid) != int(process_id):
                            log(f"[DATA][WARN] JSON cache process_id mismatch! Cache: {cached_pid}, Solicitado: {process_id} ‚Äî ignorando JSON")
                            # N√£o retornar dados do cache se for de outro processo
                        elif RPA_EXPECT_CNJ:
                            only_digits = lambda s: re.sub(r"\D", "", s or "")
                            if only_digits(data.get("numero_processo")) != only_digits(RPA_EXPECT_CNJ):
                                log("[DATA][WARN] JSON CNJ != RPA_EXPECT_CNJ ‚Äî ignorando JSON")
                            else:
                                log(f"[DATA] JSON (v√°lido, process_id={cached_pid}): {RPA_DATA_JSON}")
                                return data
                        else:
                            log(f"[DATA] JSON (v√°lido, process_id={cached_pid}): {RPA_DATA_JSON}")
                            return data
                    elif RPA_EXPECT_CNJ:
                        only_digits = lambda s: re.sub(r"\D", "", s or "")
                        if only_digits(data.get("numero_processo")) != only_digits(RPA_EXPECT_CNJ):
                            log("[DATA][WARN] JSON CNJ != RPA_EXPECT_CNJ ‚Äî ignorando JSON")
                        else:
                            log(f"[DATA] JSON (v√°lido): {RPA_DATA_JSON}")
                            return data
                    else:
                        log(f"[DATA] JSON: {RPA_DATA_JSON}")
                        return data
    except Exception as e:
        log(f"[DATA][WARN] JSON: {e}")

    return {"numero_processo": "", "tipo_processo": "eletr√¥nico", "sistema_eletronico": "PJE"}

# =========================
# SALVAR
# =========================
async def _has_validation_errors(page) -> bool:
    try:
        return await page.evaluate(
            "() => !!document.querySelector('.field-validation-error, .input-validation-error, .text-danger, .has-error, .validation-summary-errors')"
        )
    except Exception:
        return False

async def _first_visible(page: Page, selectors: List[str], timeout_ms: int = 1500) -> Optional[Any]:
    """
    Helper otimizado: aguarda PRIMEIRO seletor vis√≠vel usando Promise.race pattern.
    
    Dispara todas as esperas em PARALELO e retorna assim que qualquer uma completar COM SUCESSO,
    cancelando as demais. Reduz tempo de ~48s para <2s por chamada.
    
    CORRIGIDO: Verifica se task completou com sucesso ou com TimeoutError antes de retornar.
    
    Returns:
        Tuple (locator, selector) se encontrar, ou None se timeout/erro
    """
    if not selectors:
        return None
    
    # Verifica√ß√£o r√°pida: algum j√° est√° vis√≠vel?
    for sel in selectors:
        try:
            loc = page.locator(sel).first
            if await loc.count() > 0:
                is_vis = await loc.is_visible()
                if is_vis:
                    log(f"[_first_visible] ‚úÖ Encontrado imediatamente: {sel}")
                    return (loc, sel)
        except Exception:
            pass
    
    # Nenhum vis√≠vel agora - fazer race entre todos os seletores
    tasks = []
    for sel in selectors:
        try:
            task = asyncio.create_task(
                page.locator(sel).first.wait_for(state="visible", timeout=timeout_ms)
            )
            tasks.append((task, sel))
        except Exception:
            pass
    
    if not tasks:
        return None
    
    try:
        # Race: retorna primeira tarefa que completar
        done, pending = await asyncio.wait(
            [t[0] for t in tasks],
            timeout=timeout_ms / 1000.0,
            return_when=asyncio.FIRST_COMPLETED
        )
        
        # Cancelar tarefas pendentes
        for task in pending:
            task.cancel()
        
        # Verificar se algum task completou COM SUCESSO (sem exce√ß√£o)
        if done:
            for completed_task in done:
                # Verificar se task completou sem exce√ß√£o
                if completed_task.exception() is None:
                    # Task completou com sucesso! Encontrar qual seletor foi
                    for task, sel in tasks:
                        if task == completed_task:
                            loc = page.locator(sel).first
                            log(f"[_first_visible] ‚úÖ Encontrado via race: {sel}")
                            return (loc, sel)
                else:
                    # Task completou com TimeoutError ou outra exce√ß√£o - ignorar
                    pass
        
        # Nenhum task completou com sucesso - todos deram timeout
        log(f"[_first_visible] ‚è±Ô∏è Timeout ({timeout_ms}ms) - nenhum seletor encontrado")
        return None
        
    except asyncio.TimeoutError:
        log(f"[_first_visible] ‚è±Ô∏è Timeout global ({timeout_ms}ms)")
        return None
    except Exception as e:
        log(f"[_first_visible] ‚ùå Erro: {e}")
        return None
    finally:
        # Garantir cancelamento de todas as tarefas pendentes
        for task, _ in tasks:
            if not task.done():
                task.cancel()


async def _find_salvar_button(page):
    sels = [
        "#buttonSave",
        "a#buttonSave",
        "button#buttonSave",
        "button[type='submit']",
        "button:has-text('Salvar')",
        "button:has-text('Gravar')",
        "button:has-text('Salvar e')",
        "input[type='submit'][value*='Salvar' i]",
        "a[onclick*='Salvar' i]",
        "button.btn-success",
        "button[data-action*='salvar' i]",
        "button[name='salvar']",
    ]
    for css in sels:
        try:
            loc = page.locator(css).first
            if await loc.count() > 0 and await loc.is_enabled():
                return loc
        except Exception:
            pass
    try:
        loc = page.get_by_role("button", name=re.compile(r"salvar|gravar", re.I))
        if await loc.count() > 0:
            return loc.first
    except Exception:
        pass
    return None

async def _check_success_signals(page, url_before: str) -> Dict[str, Any]:
    """
    Verifica sinais de sucesso no salvamento do eLaw com espera otimizada.
    
    OTIMIZADO: Usa Promise.race pattern para reduzir tempo de <2s por chamada
    (antes era ~48s devido a loops sequenciais de wait_for).
    
    Returns:
        dict: {
            'navigation_ok': bool,
            'toast_ok': bool,
            'toast_text': str,
            'toast_level': str ('success', 'error', 'warning', etc),
            'already_exists': bool,
            'validation_errors': list[str],
            'current_url': str
        }
    """
    signals = {
        'navigation_ok': False,
        'toast_ok': False,
        'toast_text': '',
        'toast_level': '',
        'already_exists': False,
        'validation_errors': [],
        'current_url': ''
    }
    
    try:
        signals['current_url'] = page.url
        # Verificar se navegou para p√°gina de detalhes (com "s" tamb√©m)
        if signals['current_url'] != url_before and (
            '/detail' in signals['current_url'].lower() or 
            'id=' in signals['current_url'].lower()
        ):
            signals['navigation_ok'] = True
    except Exception:
        pass
    
    # DETEC√á√ÉO 1: Modal/Dialog com TODOS os seletores poss√≠veis (Bootbox, SweetAlert2, Bootstrap, Kendo)
    modal_selectors = [
        ".modal.show",
        ".modal-dialog",
        ".modal.in",
        ".modal.fade.in",
        "[role='dialog']",
        ".bootbox",
        ".bootbox-alert",
        ".bootbox-confirm",
        ".dialog",
        ".k-dialog",
        ".swal2-modal",
        ".swal2-popup",
        ".modal-content"
    ]
    
    try:
        # Usar helper otimizado: timeout √∫nico de 1.5s para TODOS os seletores em paralelo
        modal_result = await _first_visible(page, modal_selectors, timeout_ms=1500)
        
        if modal_result:
            modal_loc, modal_sel = modal_result
            
            # Modal encontrado! Ler texto
            try:
                modal_text = await modal_loc.text_content()
                if modal_text:
                    modal_text_clean = modal_text.strip()
                    log(f"[MODAL] üîç Detectado via {modal_sel}: {modal_text_clean[:150]}")
                    
                    # CASO 1: Modal "J√° existe processo cadastrado" - SUCESSO!
                    # ‚ö†Ô∏è IMPORTANTE: N√ÉO clicar em "Sim" pois cria duplicatas!
                    # Devemos fechar o modal e usar fallback via ListRelatorio
                    if re.search(r"j√° existe processo cadastrado", modal_text_clean, re.I):
                        signals['already_exists'] = True
                        signals['toast_ok'] = True
                        signals['toast_level'] = 'success'
                        signals['toast_text'] = modal_text_clean[:200]
                        log(f"[MODAL] ‚úÖ Processo j√° existe - N√ÉO clicando em Sim (evita duplicatas)")
                        
                        # Fechar o modal clicando em "N√£o" para N√ÉO criar duplicata
                        try:
                            # Tentar clicar em "N√£o" primeiro (op√ß√£o segura que n√£o cria duplicata)
                            btn_nao = page.locator(".bootbox.modal.in button:has-text('N√£o'), .bootbox.modal.in button:has-text('Nao'), .modal.in button:has-text('N√£o')").first
                            if await btn_nao.is_visible(timeout=1000):
                                await btn_nao.click(timeout=2000)
                                log(f"[MODAL] ‚úÖ Clicou em 'N√£o' - modal fechado sem criar duplicata")
                            else:
                                # Fallback: tentar fechar via X ou bot√£o de fechar
                                btn_close = page.locator(".bootbox.modal.in button.close, .modal.in button.close, .bootbox.modal.in [data-dismiss='modal']").first
                                if await btn_close.is_visible(timeout=1000):
                                    await btn_close.click(timeout=2000)
                                    log(f"[MODAL] ‚úÖ Modal fechado via bot√£o X")
                                else:
                                    # √öltimo recurso: ESC
                                    await page.keyboard.press('Escape')
                                    log(f"[MODAL] ‚úÖ Modal fechado via ESC")
                            
                            await short_sleep_ms(500)
                            
                            # Sinalizar que precisamos usar fallback via ListRelatorio
                            signals['needs_relatorio_fallback'] = True
                            log(f"[MODAL] ‚ÑπÔ∏è Fallback via ListRelatorio ser√° acionado para obter URL de detalhes")
                            
                        except Exception as e:
                            log(f"[MODAL] ‚ö†Ô∏è Erro ao fechar modal: {e}")
                            signals['needs_relatorio_fallback'] = True
                    
                    # CASO 2: Modal de "data processual pr√≥xima" - CONFIRMAR SALVAMENTO
                    elif re.search(r"data processual.*pr√≥xima.*data de hoje|deseja editar", modal_text_clean, re.I):
                        log(f"[MODAL] ‚ö†Ô∏è Modal de data processual - confirmando salvamento...")
                        
                        # Clicar em "N√£o" para confirmar salvamento sem editar
                        try:
                            btn_nao = page.locator("button:has-text('N√£o'), button:has-text('Nao'), button:has-text('NAO')").first
                            await btn_nao.click(timeout=2000)
                            log(f"[MODAL] ‚úÖ Salvamento confirmado!")
                            
                            # Marcar como sucesso
                            signals['toast_ok'] = True
                            signals['toast_level'] = 'success'
                            signals['toast_text'] = "Processo salvo (data confirmada)"
                            await short_sleep_ms(500)
                        except Exception as e:
                            log(f"[MODAL] ‚ö†Ô∏è Erro ao clicar em 'N√£o': {e}")
                    
                    # CASO 3: Qualquer outro modal de confirma√ß√£o gen√©rico
                    else:
                        log(f"[MODAL] ‚ÑπÔ∏è Modal gen√©rico detectado - tentando confirmar...")
                        
                        # Tentar clicar em bot√£o de confirma√ß√£o gen√©rico DENTRO do modal
                        try:
                            btn = page.locator(".modal.in button:has-text('OK'), .modal.in button:has-text('Sim'), .modal.in button:has-text('Confirmar'), .modal.in .btn-primary").first
                            if await btn.count() > 0:
                                await btn.click(timeout=2000)
                                log(f"[MODAL] ‚úÖ Modal confirmado!")
                                
                                # Se conseguiu fechar, assumir sucesso
                                signals['toast_ok'] = True
                                signals['toast_level'] = 'success'
                                signals['toast_text'] = f"Confirmado: {modal_text_clean[:100]}"
                                await short_sleep_ms(500)
                        except:
                            pass
            except Exception as e:
                log(f"[MODAL] ‚ö†Ô∏è Erro ao processar modal: {e}")
    except Exception:
        pass
    
    # DETEC√á√ÉO 2: Toast (apenas se modal n√£o detectou) - OTIMIZADO com Promise.race
    if not signals['already_exists']:
        toast_selectors = [
            ".toast.show",
            ".toast-message",
            ".toast-container .toast",
            ".k-notification",
            ".k-notification-success",
            ".k-notification-error",
            ".alert.show",
            "[role='alert']",
            ".swal2-container",
            ".toast-success",
            ".alert-success",
            ".alert-danger"
        ]
        
        try:
            # Usar helper otimizado: timeout √∫nico de 1.5s para TODOS os seletores em paralelo
            toast_result = await _first_visible(page, toast_selectors, timeout_ms=1500)
            
            if toast_result:
                toast_loc, toast_sel = toast_result
                
                # Toast encontrado! Ler texto e classificar
                try:
                    toast_text = await toast_loc.text_content()
                    if toast_text:
                        signals['toast_text'] = toast_text.strip()
                        text_lower = signals['toast_text'].lower()
                        
                        # Classificar n√≠vel pelo texto OU classes CSS
                        classes = await toast_loc.get_attribute("class") or ""
                        classes_lower = classes.lower()
                        
                        # Palavras que indicam SUCESSO (no texto ou classes)
                        success_keywords_text = ['sucesso', 'salvo com sucesso', 'cadastrado', 'gravado']
                        success_keywords_class = ['success', 'sucesso']
                        
                        # Palavras que indicam ERRO (no texto ou classes)
                        error_keywords_text = ['erro', 'preencha', 'obrigat√≥rio', 'inv√°lido', 'incorreto', 'falha', 'n√£o pode', 'verifique']
                        error_keywords_class = ['danger', 'error', 'erro']
                        
                        # Classificar por CLASSES primeiro (mais confi√°vel)
                        if any(term in classes_lower for term in success_keywords_class):
                            signals['toast_level'] = 'success'
                            signals['toast_ok'] = True
                        elif any(term in classes_lower for term in error_keywords_class):
                            signals['toast_level'] = 'error'
                        # Se classes n√£o ajudaram, classificar por TEXTO
                        elif any(term in text_lower for term in success_keywords_text):
                            signals['toast_level'] = 'success'
                            signals['toast_ok'] = True
                        elif any(term in text_lower for term in error_keywords_text):
                            signals['toast_level'] = 'error'
                        elif any(term in classes_lower for term in ['warning', 'aviso']):
                            signals['toast_level'] = 'warning'
                        
                        log(f"[TOAST] Detectado ({signals['toast_level']}) via {toast_sel}: {signals['toast_text'][:100]}")
                except Exception:
                    pass
        except Exception:
            pass
    
    # DETEC√á√ÉO 3: Erros de valida√ß√£o (r√°pido, sem timeout)
    try:
        error_locs = await page.locator(".field-validation-error, .input-validation-error, .validation-summary-errors li").all()
        for loc in error_locs:
            try:
                text = await loc.text_content()
                if text and text.strip():
                    signals['validation_errors'].append(text.strip())
            except Exception:
                pass
    except Exception:
        pass
    
    return signals

async def click_salvar_and_wait(page, cnj_expected: str = "") -> Dict[str, Any]:
    """
    Clica no bot√£o Salvar com retry seguro e aguarda resposta (sucesso ou erro).
    
    Estrat√©gia de 2 tentativas:
    - 1¬™ tentativa: clicar e aguardar 20s por navega√ß√£o
    - Se n√£o confirmar sucesso E bot√£o estiver habilitado: 2¬™ tentativa
    
    Returns:
        dict: {
            'success': bool,
            'url_before': str,
            'url_after': str,
            'message': str,
            'url_changed': bool,
            'attempts': int
        }
    """
    result = {
        'success': False,
        'url_before': '',
        'url_after': '',
        'message': '',
        'url_changed': False,
        'attempts': 0
    }
    
    try:
        result['url_before'] = page.url
        log(f"[SALVAR] URL inicial: {result['url_before']}")
    except Exception:
        pass
    
    try:
        page.once("dialog", lambda d: asyncio.create_task(d.accept()))
    except Exception:
        pass

    btn = await _find_salvar_button(page)
    if not btn:
        result['message'] = "Bot√£o 'Salvar' n√£o encontrado"
        log(f"[SALVAR][ERRO] {result['message']}")
        try:
            png = _get_screenshot_path("salvar_nao_encontrado.png", process_id=process_id)  # 2025-11-21: Corrigido
            await page.screenshot(path=str(png), full_page=True)
            log(f"[SALVAR] Screenshot: {png}")
        except Exception:
            pass
        return result

    # M√°ximo de 2 tentativas
    max_attempts = 2
    navigation_succeeded = False
    
    for attempt in range(1, max_attempts + 1):
        result['attempts'] = attempt
        log(f"[SALVAR] ‚ïê‚ïê‚ïê TENTATIVA {attempt}/{max_attempts} ‚ïê‚ïê‚ïê")
        
        await _scroll_into_view(btn)
        
        # Verificar se bot√£o est√° habilitado antes de tentar
        try:
            is_enabled = await btn.is_enabled()
            log(f"[SALVAR][T{attempt}] Bot√£o est√° {'HABILITADO' if is_enabled else 'DESABILITADO'}")
            if not is_enabled and attempt > 1:
                log(f"[SALVAR][T{attempt}] Bot√£o desabilitado - processo pode estar sendo salvo, aguardando...")
                await short_sleep_ms(3000)
                continue
        except Exception:
            pass

        # Tentar clicar
        ok = await robust_click(f"Bot√£o 'Salvar' (tentativa {attempt})", btn, timeout_ms=DEFAULT_TIMEOUT_MS)
        if not ok:
            try:
                await page.evaluate("() => document.querySelector('form')?.requestSubmit?.()")
                log(f"[SALVAR][T{attempt}] requestSubmit() acionado como fallback")
                ok = True
            except Exception:
                pass
        
        if not ok:
            result['message'] = f"N√£o consegui acionar o bot√£o Salvar (tentativa {attempt})"
            log(f"[SALVAR][ERRO] {result['message']}")
            if attempt < max_attempts:
                await short_sleep_ms(2000)
                continue
            return result
        
        log(f"[SALVAR][T{attempt}] Clique executado. Aguardando resposta do servidor...")
        
        # Aguardar rede estabilizar ap√≥s clique
        await wait_network_quiet(page, timeout_ms=max(SETTLE_NET_MS, 1500))
        await short_sleep_ms(500)
        
        # Aguardar navega√ß√£o ou toast de sucesso com timeout progressivo
        wait_timeout = 20.0 if attempt == 1 else 25.0  # 2¬™ tentativa aguarda mais
        deadline = asyncio.get_event_loop().time() + wait_timeout
        
        log(f"[SALVAR][T{attempt}] Aguardando confirma√ß√£o (at√© {wait_timeout}s)...")
        
        # Polling a cada 1s com logging de progresso
        check_interval = 1.0
        last_check_time = asyncio.get_event_loop().time()
        elapsed = 0
        
        while asyncio.get_event_loop().time() < deadline:
            await short_sleep_ms(500)
            
            current_time = asyncio.get_event_loop().time()
            if current_time - last_check_time >= check_interval:
                elapsed = int(current_time - (deadline - wait_timeout))
                signals = await _check_success_signals(page, result['url_before'])
                
                log(f"[SALVAR][T{attempt}][{elapsed}s] Nav:{signals['navigation_ok']}, Toast:{signals['toast_ok']}, J√°Existe:{signals['already_exists']}, Erros:{len(signals['validation_errors'])}, URL:{signals['current_url']}")
                
                # Sucesso confirmado: navega√ß√£o para /processo/details
                if signals['navigation_ok']:
                    log(f"[SALVAR][T{attempt}] ‚úÖ CONFIRMADO: Navega√ß√£o para {signals['current_url']}")
                    navigation_succeeded = True
                    # Aguardar p√°gina carregar completamente
                    await wait_network_quiet(page, timeout_ms=3000)
                    await short_sleep_ms(800)
                    break
                
                # Sucesso confirmado: processo J√Å EXISTE (n√£o √© erro!)
                if signals['already_exists']:
                    log(f"[SALVAR][T{attempt}] ‚úÖ CONFIRMADO: {signals['toast_text']}")
                    result['message'] = 'Processo foi preenchido mas j√° existe no eLaw'
                    navigation_succeeded = True
                    # ‚úÖ Se capturou URL de detalhes do modal, guardar no resultado
                    if signals.get('detail_url'):
                        result['detail_url'] = signals['detail_url']
                        log(f"[SALVAR] URL de detalhes do modal: {signals['detail_url']}")
                    break
                
                # Sucesso confirmado: toast verde expl√≠cito
                if signals['toast_ok'] and signals['toast_level'] == 'success':
                    log(f"[SALVAR][T{attempt}] ‚úÖ CONFIRMADO: Toast verde - {signals['toast_text'][:50]}")
                    navigation_succeeded = True
                    break
                
                # Erro confirmado: toast vermelho
                if signals['toast_level'] == 'error':
                    log(f"[SALVAR][T{attempt}] ‚ùå ERRO: Toast vermelho - {signals['toast_text']}")
                    result['message'] = f"eLaw rejeitou: {signals['toast_text'][:100]}"
                    navigation_succeeded = False
                    break
                
                # Erro confirmado: mensagens de valida√ß√£o
                if signals['validation_errors']:
                    log(f"[SALVAR][T{attempt}] ‚ùå ERRO: Valida√ß√£o falhou: {signals['validation_errors']}")
                    result['message'] = f"eLaw rejeitou: {'; '.join(signals['validation_errors'][:3])}"
                    navigation_succeeded = False
                    break
                
                # DIAGN√ìSTICO: Se passou 10s sem NENHUMA detec√ß√£o, capturar HTML + Screenshot para debug
                if elapsed == 10 and not (signals['navigation_ok'] or signals['toast_ok'] or signals['already_exists']):
                    log(f"[SALVAR][DEBUG] ‚ö†Ô∏è 10s sem feedback - capturando diagnostics...")
                    try:
                        # Screenshot para debug visual
                        debug_screenshot = SCREENSHOT_DIR / f"debug_10s_sem_feedback_{attempt}.png"
                        await page.screenshot(path=str(debug_screenshot), full_page=True)
                        log(f"[SALVAR][DEBUG] Screenshot salvo: {debug_screenshot.name}")
                        send_screenshot_to_monitor(debug_screenshot, region="DEBUG_10S_SEM_FEEDBACK")
                        
                        # Dump HTML para an√°lise de DOM
                        html_content = await page.content()
                        debug_html = SCREENSHOT_DIR / f"debug_10s_html_{attempt}.html"
                        with open(debug_html, 'w', encoding='utf-8') as f:
                            f.write(html_content)
                        log(f"[SALVAR][DEBUG] HTML salvo: {debug_html.name}")
                        
                        # Verificar se h√° QUALQUER modal vis√≠vel (mesmo sem classes conhecidas)
                        all_modals = await page.locator("[role='dialog'], .modal, .bootbox, .swal2, .k-dialog").all()
                        log(f"[SALVAR][DEBUG] Encontrados {len(all_modals)} elementos de modal na p√°gina")
                        for i, modal in enumerate(all_modals[:3]):  # Apenas os 3 primeiros
                            try:
                                is_vis = await modal.is_visible()
                                text = await modal.text_content()
                                log(f"[SALVAR][DEBUG] Modal {i+1}: Vis√≠vel={is_vis}, Texto={text[:100] if text else 'vazio'}")
                            except:
                                pass
                    except Exception as e:
                        log(f"[SALVAR][DEBUG] ‚ö†Ô∏è Erro ao capturar diagnostics: {e}")
                
                last_check_time = current_time
        
        # Avaliar resultado da tentativa
        if navigation_succeeded:
            log(f"[SALVAR][T{attempt}] ‚úÖ Sucesso confirmado!")
            break
        else:
            log(f"[SALVAR][T{attempt}] ‚ö†Ô∏è Sem confirma√ß√£o ap√≥s {wait_timeout}s")
            
            # Verificar se deve tentar novamente
            if attempt < max_attempts:
                # Verificar se bot√£o voltou a ficar habilitado (sinal de que pode tentar de novo)
                try:
                    btn_enabled_again = await btn.is_enabled()
                    log(f"[SALVAR][T{attempt}] Bot√£o est√° {'HABILITADO' if btn_enabled_again else 'DESABILITADO'} para retry")
                    
                    if not btn_enabled_again:
                        log(f"[SALVAR][T{attempt}] Bot√£o ainda processando - n√£o vou tentar novamente")
                        result['message'] = "Bot√£o ainda processando ap√≥s timeout - poss√≠vel salvamento em andamento"
                        break
                    
                    # Verificar novamente por sinais de sucesso antes de retry
                    final_check = await _check_success_signals(page, result['url_before'])
                    if final_check['navigation_ok'] or final_check['toast_ok']:
                        log(f"[SALVAR][T{attempt}] ‚úÖ Sucesso detectado na verifica√ß√£o final!")
                        navigation_succeeded = True
                        break
                    
                    log(f"[SALVAR][T{attempt}] Preparando retry em 2s...")
                    await short_sleep_ms(2000)
                    
                except Exception as e:
                    log(f"[SALVAR][T{attempt}] Erro ao verificar condi√ß√µes de retry: {e}")
                    break
            else:
                log(f"[SALVAR] ‚ùå Esgotadas {max_attempts} tentativas sem confirma√ß√£o")
                result['message'] = "eLaw n√£o confirmou salvamento ap√≥s m√∫ltiplas tentativas"
    
    # Atualizar URL ap√≥s espera
    try:
        result['url_after'] = page.url
        result['url_changed'] = (result['url_after'] != result['url_before'])
        log(f"[SALVAR] URL final: {result['url_after']} (mudou: {result['url_changed']})")
    except Exception:
        pass
    
    # Captura screenshot AP√ìS navega√ß√£o completa
    try:
        png = _get_screenshot_path("pos_salvar.png", process_id=process_id)  # 2025-11-21: Corrigido
        await page.screenshot(path=str(png), full_page=True)
        log(f"[SALVAR] Screenshot p√≥s-salvar capturado: {png} (URL: {page.url})")
        send_screenshot_to_monitor(png, region="POS_SALVAR")
    except Exception:
        pass

    if cnj_expected:
        try:
            await ensure_cnj_still_present(page, cnj_expected)
        except Exception:
            pass

    # Verifica√ß√£o final de erros de valida√ß√£o
    if await _has_validation_errors(page):
        result['success'] = False
        result['message'] = result.get('message') or "Campos com erro de valida√ß√£o ap√≥s salvar"
        log(f"[SALVAR][ERRO] {result['message']}")
        return result

    # Definir resultado baseado em navigation_succeeded
    if navigation_succeeded:
        result['success'] = True
        result['message'] = f"Processo salvo com sucesso ap√≥s {result['attempts']} tentativa(s)"
        log(f"[SALVAR] ‚úÖ SUCESSO FINAL confirmado ap√≥s {result['attempts']} tentativa(s)")
    else:
        result['success'] = False
        result['message'] = result.get('message') or "N√£o foi poss√≠vel confirmar sucesso no salvamento"
        log(f"[SALVAR] ‚ùå FALHA FINAL ap√≥s {result['attempts']} tentativa(s)")
    
    return result

# =========================
# Fluxo principal do formul√°rio
# =========================
async def _settle(page, tag: str):
    await wait_network_quiet(page, SETTLE_NET_MS)
    await short_sleep_ms(SETTLE_SLEEP_MS)
    dlog(f"[SETTLE] {tag}")

def _must(ok: bool, step: str):
    if not ok:
        raise RuntimeError(f"[FORM] Passo cr√≠tico falhou: {step}")

def parse_roles_from_pdf(pdf_text: str) -> Dict[str, str]:
    RE_TOP_RECLAMANTE = re.compile(r"\bRECLAMANTE\s*[:\-‚Äì]\s*(.+)", re.I)
    RE_TOP_RECLAMADO = re.compile(r"\bRECLAMADO\s*[:\-‚Äì]\s*(.+)", re.I)
    out = {"reclamante": "", "reclamado": ""}
    if not pdf_text:
        return out
    lines = [l.strip() for l in pdf_text.splitlines() if l.strip()]
    for ln in lines[:400]:
        m = RE_TOP_RECLAMANTE.search(ln)
        if m and not out["reclamante"]:
            out["reclamante"] = m.group(1).strip()
        m = RE_TOP_RECLAMADO.search(ln)
        if m and not out["reclamado"]:
            out["reclamado"] = m.group(1).strip()
        if out["reclamante"] and out["reclamado"]:
            break
    return out

def is_probably_pj(name: str) -> bool:
    n = norm(name)
    if re.search(r"\b(s\.?a\.?|ltda|eireli|me|mei|s\/a|s\.a\.)\b", n):
        return True
    if re.search(r"\bcompanhia\b|\bdistribuicao\b|\bdistribui√ß√£o\b|\bgrupo\b|\bholding\b", n):
        return True
    if re.search(r"\b\d{2}\.?\d{3}\.?\d{3}\/?\d{4}\-?\d{2}\b", name):
        return True
    return False

def is_probably_pf(name: str) -> bool:
    return not is_probably_pj(name)

# =========================
# Sistema Universal de Fallback
# =========================
def extract_numero_orgao_from_pdf(pdf_text: str) -> str:
    """Extrai n√∫mero do √≥rg√£o do PDF."""
    if not pdf_text:
        return ""
    patterns = [
        r"(?i)(?:n[√∫u]mero\s+(?:do\s+)?(?:[√≥o]rg[√£a]o|vara|turma|juris(?:di[√ßc][√£a]o)?)[:\s]+)(\d+)",
        r"(?i)(?:vara|turma|juizado)\s+n[√∫u]mero\s+(\d+)",
        r"(?i)(\d+)[¬™¬∫]?\s+vara",
        r"(?i)vara[:\s]+(\d+)",
    ]
    for pat in patterns:
        m = re.search(pat, pdf_text)
        if m:
            return m.group(1).strip()
    return ""

def extract_valor_causa_from_pdf(pdf_text: str) -> str:
    """Extrai valor da causa do PDF."""
    if not pdf_text:
        return ""
    patterns = [
        r"(?i)valor\s+(?:da\s+)?(?:causa|a[√ßc][√£a]o)[:\s]+R?\$?\s*([\d\.,]+)",
        r"(?i)R\$\s*([\d\.,]+)",
        r"(?i)(?:pedido|indeniza[√ßc][√£a]o|d[i√≠]vida)[:\s]+R?\$?\s*([\d\.,]+)",
    ]
    for pat in patterns:
        m = re.search(pat, pdf_text)
        if m:
            valor = m.group(1).strip()
            valor = re.sub(r"[^\d,]", "", valor)
            if valor:
                return valor
    return ""

def extract_instancia_from_pdf(pdf_text: str, dropdown_options: List[str]) -> Optional[str]:
    """
    Extrai inst√¢ncia do PDF usando sistema principal de extra√ß√£o + fuzzy matching.
    
    ‚úÖ FIX ARQUITETURAL: Delega para extractors.regex_utils.detect_orgao_origem_instancia()
    e ent√£o usa _best_match() com detec√ß√£o de ordinais. Single source of truth.
    """
    if not pdf_text or not dropdown_options:
        return None
    
    # Usa sistema principal de extra√ß√£o (j√° corrigido para detectar 1¬™ vs 2¬™ inst√¢ncia)
    try:
        from extractors.regex_utils import detect_orgao_origem_instancia
        _, _, instancia_extraida = detect_orgao_origem_instancia(pdf_text)
        
        if instancia_extraida:
            # Usa fuzzy matching com detec√ß√£o de ordinais
            match = _best_match(dropdown_options, instancia_extraida, threshold=20)
            if match:
                return match
    except Exception as e:
        log(f"[extract_instancia_from_pdf][WARN] Erro ao usar sistema principal: {e}")
    
    # Fallback: detec√ß√£o manual simples baseada em sinais MUITO fortes
    pdf_norm = norm(pdf_text)
    
    # Sinais MUITO FORTES que definem inst√¢ncia
    has_vara = "vara" in pdf_norm
    has_recurso_header = "recurso" in pdf_norm[:300] and "trt" in pdf_norm[:500]
    
    # ‚úÖ FIX: Verifica se "acordao" existe (find != -1) ANTES de comparar posi√ß√£o
    acordao_pos = pdf_norm.find("acordao")
    has_acordao_header = acordao_pos != -1 and acordao_pos < 500
    
    if has_vara and not has_recurso_header and not has_acordao_header:
        # Vara sem recurso/ac√≥rd√£o no header = 1¬™ inst√¢ncia
        for opt in dropdown_options:
            if _detect_ordinal(opt) == 1:
                return opt
    elif has_recurso_header or has_acordao_header:
        # Recurso ou ac√≥rd√£o no header = 2¬™ inst√¢ncia
        for opt in dropdown_options:
            if _detect_ordinal(opt) == 2:
                return opt
    
    return None

def extract_cliente_grupo_from_pdf(pdf_text: str, dropdown_options: List[str]) -> Optional[str]:
    """
    Extrai Cliente/Grupo do PDF comparando com op√ß√µes do dropdown do eLaw.
    
    IMPORTANTE: Usa brand_map.py para identificar clientes cadastrados e
    ent√£o busca a melhor correspond√™ncia nas op√ß√µes do dropdown.
    """
    if not pdf_text or not dropdown_options:
        return None
    
    # 1. Extrai partes do PDF
    pdf_roles = parse_roles_from_pdf(pdf_text)
    reclamado = pdf_roles.get("reclamado", "").strip()
    
    if not reclamado:
        return None
    
    # 2. Usa brand_map para normalizar (agora com accent-insensitive matching!)
    from extractors.brand_map import normalize_cliente
    cliente_normalizado = normalize_cliente(reclamado)
    
    if not cliente_normalizado or cliente_normalizado == reclamado.strip().title():
        # normalize_cliente n√£o encontrou no banco, tenta fuzzy direto com dropdown
        log(f"[CLIENTE_GRUPO] Cliente n√£o identificado no banco: {reclamado[:50]}, tentando fuzzy com dropdown")
        match = _best_match(dropdown_options, reclamado, threshold=15, prefer_words=["pao", "acucar", "gpa", "cbd", "sendas"])
        if match:
            log(f"[CLIENTE_GRUPO] ‚úÖ Match fuzzy com dropdown: {match}")
            return match
    else:
        # Cliente identificado, busca no dropdown
        log(f"[CLIENTE_GRUPO] Cliente identificado: {reclamado[:50]} ‚Üí {cliente_normalizado}")
        match = _best_match(dropdown_options, cliente_normalizado, threshold=12)
        if match:
            log(f"[CLIENTE_GRUPO] ‚úÖ Match no dropdown: {match}")
            return match
        
        # Fallback: tenta nome do grupo tamb√©m
        for grupo in ["Grupo P√£o de A√ß√∫car", "GPA", "Pro Pharma", "CSN", "HAZTEC"]:
            if grupo.lower() in cliente_normalizado.lower():
                match = _best_match(dropdown_options, grupo, threshold=10)
                if match:
                    log(f"[CLIENTE_GRUPO] ‚úÖ Match por grupo: {match}")
                    return match
    
    return None

def extract_assunto_from_pdf(pdf_text: str, dropdown_options: List[str]) -> Optional[str]:
    """Extrai assunto/tema do PDF e compara com op√ß√µes do dropdown."""
    if not pdf_text or not dropdown_options:
        return None
    
    pdf_norm = norm(pdf_text)
    
    # Padr√µes comuns de assunto trabalhista
    keywords = [
        ("reclama√ß√£o trabalhista", ["reclamacao", "trabalhista"]),
        ("a√ß√£o trabalhista", ["acao", "trabalhista"]),
        ("horas extras", ["horas", "extras"]),
        ("verbas rescis√≥rias", ["verbas", "rescisoria"]),
        ("fgts", ["fgts"]),
        ("adicional noturno", ["adicional", "noturno"]),
        ("diferen√ßas salariais", ["diferencas", "salariais"]),
    ]
    
    for label, terms in keywords:
        if all(term in pdf_norm for term in terms):
            match = _best_match(dropdown_options, label, threshold=12)
            if match:
                return match
    
    # Fallback: tenta "Reclama√ß√£o Trabalhista"
    return _best_match(dropdown_options, "Reclama√ß√£o Trabalhista", threshold=10)

def extract_foro_from_pdf(pdf_text: str, dropdown_options: List[str]) -> Optional[str]:
    """Extrai foro/juizado do PDF e compara com op√ß√µes do dropdown."""
    if not pdf_text or not dropdown_options:
        return None
    
    # Busca padr√µes de foro
    patterns = [
        r"(?i)foro\s+(?:de\s+)?([A-Z√á√É√Å√â√ç√ì√ö√Ç√ä√î√Ä√ú][a-z√ß√£√°√©√≠√≥√∫√¢√™√¥√†√º\s]+)",
        r"(?i)juizado\s+(?:de\s+)?([A-Z√á√É√Å√â√ç√ì√ö√Ç√ä√î√Ä√ú][a-z√ß√£√°√©√≠√≥√∫√¢√™√¥√†√º\s]+)",
        r"(?i)comarca\s+(?:de\s+)?([A-Z√á√É√Å√â√ç√ì√ö√Ç√ä√î√Ä√ú][a-z√ß√£√°√©√≠√≥√∫√¢√™√¥√†√º\s]+)",
    ]
    
    for pat in patterns:
        m = re.search(pat, pdf_text)
        if m:
            foro_extraido = m.group(1).strip()
            match = _best_match(dropdown_options, foro_extraido, threshold=10)
            if match:
                return match
    
    return None

def extract_parte_interessada_from_pdf(pdf_text: str, dropdown_options: List[str]) -> Optional[str]:
    """
    Extrai parte interessada do PDF e compara com op√ß√µes do dropdown.
    Usa a l√≥gica de infer_cliente_grupo_and_parte para identificar corretamente.
    """
    if not pdf_text or not dropdown_options:
        return None
    
    # Usa l√≥gica existente para inferir
    pdf_roles = parse_roles_from_pdf(pdf_text)
    reclamado = pdf_roles.get("reclamado", "").strip()
    reclamante = pdf_roles.get("reclamante", "").strip()
    
    # Identifica qual √© PJ (normalmente o cliente)
    parte_interessada = reclamado if is_probably_pj(reclamado) else reclamante
    
    if not parte_interessada:
        return None
    
    # Tenta match com dropdown (autocomplete pode ter sugest√µes)
    match = _best_match(dropdown_options, parte_interessada, threshold=15)
    return match if match else parte_interessada

def extract_npc_from_pdf(pdf_text: str) -> str:
    """Extrai NPC do PDF."""
    if not pdf_text:
        return ""
    
    patterns = [
        r"(?i)\bNPC\b\s*[:\-‚Äì]\s*([A-Z0-9][A-Z0-9\/\.\-\s]{2,60})",
        r"(?i)n[√∫u]mero\s+(?:do\s+)?processo\s+(?:antigo|anterior)[:\s]+([A-Z0-9][A-Z0-9\/\.\-\s]{2,60})",
    ]
    
    for pat in patterns:
        m = re.search(pat, pdf_text)
        if m:
            return m.group(1).strip()
    
    return ""

def extract_field_with_full_fallback(
    field_name: str,
    data: Dict[str, Any],
    pdf_text: str,
    dropdown_options: Optional[List[str]] = None,
    pdf_extractor: Optional[callable] = None,
    data_keys: Optional[List[str]] = None,
    threshold: int = 10
) -> Optional[str]:
    """
    Sistema universal de fallback para TODOS os campos do RPA.
    
    HIERARQUIA DE FALLBACK:
    1. Sistema Jur√≠dico (data dict) - fonte mais confi√°vel
    2. Banco de dados (j√° inclu√≠do em data)
    3. Extra√ß√£o do PDF usando regex customizado
    4. Compara√ß√£o com op√ß√µes do dropdown (se aplic√°vel)
    
    Args:
        field_name: Nome do campo principal a extrair (ex: "numero_orgao")
        data: Dicion√°rio com dados do processo (sistema + banco)
        pdf_text: Texto completo do PDF
        dropdown_options: Lista de op√ß√µes dispon√≠veis no dropdown do eLaw (opcional)
        pdf_extractor: Fun√ß√£o customizada para extrair do PDF (opcional)
        data_keys: Lista alternativa de chaves para buscar no data (opcional)
        threshold: Score m√≠nimo para fuzzy matching (default: 10)
        
    Returns:
        Valor extra√≠do ou None
        
    Examples:
        # Campo de input (sem dropdown)
        num_orgao = extract_field_with_full_fallback(
            "numero_orgao",
            data,
            pdf_text,
            pdf_extractor=extract_numero_orgao_from_pdf,
            data_keys=["numero_orgao", "numero_jurisdicao", "orgao_numero"]
        )
        
        # Campo dropdown
        instancia = extract_field_with_full_fallback(
            "instancia",
            data,
            pdf_text,
            dropdown_options=inst_opts,
            pdf_extractor=extract_instancia_from_pdf
        )
    """
    # 1. PRIORIDADE M√ÅXIMA: Dados do sistema/banco
    keys_to_try = data_keys or [field_name]
    for key in keys_to_try:
        value = (data.get(key) or "").strip()
        if value:
            log(f"[FALLBACK][{field_name}] ‚úÖ Usando valor do SISTEMA/BANCO: {value}")
            # Se tem dropdown, valida se valor existe nas op√ß√µes
            if dropdown_options:
                match = _best_match(dropdown_options, value, threshold=threshold)
                if match:
                    log(f"[FALLBACK][{field_name}] ‚úÖ Valor validado no dropdown: {match}")
                    return match
            return value
    
    # 2. FALLBACK: Extra√ß√£o do PDF
    if pdf_extractor and pdf_text:
        try:
            if dropdown_options:
                # Se tem dropdown, passa as op√ß√µes para o extractor
                pdf_value = pdf_extractor(pdf_text, dropdown_options)
            else:
                pdf_value = pdf_extractor(pdf_text)
            
            if pdf_value:
                log(f"[FALLBACK][{field_name}] ‚úÖ Extra√≠do do PDF: {pdf_value}")
                # Se tem dropdown, valida fuzzy matching
                if dropdown_options:
                    match = _best_match(dropdown_options, pdf_value, threshold=threshold)
                    if match:
                        log(f"[FALLBACK][{field_name}] ‚úÖ Matched com dropdown: {match}")
                        return match
                return pdf_value
        except Exception as e:
            log(f"[FALLBACK][{field_name}][WARN] Erro ao extrair do PDF: {e}")
    
    # 3. √öLTIMO RECURSO: Primeira op√ß√£o do dropdown
    if dropdown_options and len(dropdown_options) > 0:
        log(f"[FALLBACK][{field_name}] ‚ö†Ô∏è  Usando primeira op√ß√£o do dropdown: {dropdown_options[0]}")
        return dropdown_options[0]
    
    log(f"[FALLBACK][{field_name}] ‚ùå Nenhum valor encontrado")
    return None

def infer_cliente_grupo_and_parte(pdf_text: str, data: Dict[str, Any]) -> Dict[str, str]:
    """
    PRIORIZA dados do BANCO DE DADOS, s√≥ usa PDF para campos vazios.
    Isso evita sobrescrever dados corretos do banco com dados errados de PDFs misturados.
    """
    # PRIORIDADE 1: Dados do banco de dados (fonte can√¥nica)
    db_recl = str(data.get("parte_reclamante") or data.get("reclamante") or "").strip()
    db_reld = str(data.get("parte_reclamado") or data.get("reclamado") or "").strip()
    db_parte_adversa = str(data.get("parte_adversa_nome") or "").strip()
    
    # PRIORIDADE 2: S√≥ extrai do PDF se campos estiverem vazios
    pdf_roles = parse_roles_from_pdf(pdf_text or "") if pdf_text else {}
    pdf_recl = pdf_roles.get("reclamante", "").strip()
    pdf_reld = pdf_roles.get("reclamado", "").strip()
    
    # Usa dados do banco primeiro, PDF s√≥ como fallback
    recl = db_recl or pdf_recl
    reld = db_reld or pdf_reld
    
    # Log diverg√™ncias para auditoria
    if db_recl and pdf_recl and db_recl != pdf_recl:
        log(f"[INFER][WARN] Reclamante divergente - DB: '{db_recl}' vs PDF: '{pdf_recl}' - usando DB!")
    if db_reld and pdf_reld and db_reld != pdf_reld:
        log(f"[INFER][WARN] Reclamado divergente - DB: '{db_reld}' vs PDF: '{pdf_reld}' - usando DB!")

    cliente_grupo = data.get("grupo") or data.get("cliente") or ""
    
    # PRIORIDADE 1: Usa posicao_parte_interessada do banco se existir E for espec√≠fica
    db_posicao = str(data.get("posicao_parte_interessada") or "").strip()
    
    # üîí CRITICAL: Ignora placeholders gen√©ricos/inv√°lidos do banco (dados antigos corrompidos)
    # "PARTES" √© um label gen√©rico do eLaw (ID 63) que n√£o especifica QUEM √© a parte
    INVALID_POSICOES = {"PARTES", "PARTE", ""}  # Placeholders que devem ser re-inferidos
    
    if db_posicao and db_posicao.upper() not in INVALID_POSICOES:
        log(f"[INFER] Usando posicao_parte_interessada do BANCO: {db_posicao}")
        posicao = normalize_posicao(db_posicao)  # ‚úÖ PRIORIZA BANCO (valores v√°lidos)
    else:
        if db_posicao and db_posicao.upper() in INVALID_POSICOES:
            log(f"[INFER][WARN] Posi√ß√£o gen√©rica/inv√°lida no banco ('{db_posicao}') - for√ßando re-infer√™ncia do PDF")
        # Infere baseado na l√≥gica de PJ/PF
        if is_probably_pj(reld):
            posicao = normalize_posicao("RECLAMADO")
        else:
            posicao = normalize_posicao("RECLAMANTE")
        log(f"[INFER] Posi√ß√£o INFERIDA (banco vazio ou inv√°lido): {posicao}")
    
    # Se parte_adversa_nome j√° est√° no banco, usa direto (fonte mais confi√°vel)
    if db_parte_adversa:
        log(f"[INFER] Usando parte_adversa_nome do BANCO: {db_parte_adversa}")
        parte_adversa_nome = db_parte_adversa
        # Determina parte_interessada_nome baseado na posi√ß√£o
        if posicao == "RECLAMADO":
            parte_interessada_nome = reld
        else:
            parte_interessada_nome = recl
    else:
        # Inferir pela l√≥gica antiga se n√£o tiver no banco
        if is_probably_pj(reld):
            parte_interessada_nome = reld
            parte_adversa_nome = recl
        else:
            parte_interessada_nome = recl
            parte_adversa_nome = reld

    parte_adversa_tipo = "FISICA" if is_probably_pf(parte_adversa_nome) else "JURIDICA"

    if not cliente_grupo and is_probably_pj(parte_interessada_nome):
        cliente_grupo = "Grupo P√£o de A√ß√∫car"

    return {
        "cliente_grupo": (cliente_grupo or "Grupo P√£o de A√ß√∫car").strip(),
        "parte_interessada_nome": parte_interessada_nome.strip(),
        "posicao_parte_interessada": posicao,
        "parte_adversa_nome": parte_adversa_nome.strip(),
        "parte_adversa_tipo": parte_adversa_tipo,
    }

# IDs p√≥s-Tipo de A√ß√£o
GRUPO_CLIENTE_SELECT_ID = "GrupoClienteId"
POSICAO_CLIENTE_SELECT_ID = "PosicaoClienteId"
PARTE_INTERESSADA_SELECT_ID = "ClienteId"
PARTE_ADVERSA_TIPO_NAME = "TipoPessoaAdverso"   # 1=F√≠sica, 2=Jur√≠dica
PARTE_ADVERSA_NOME_INPUT_ID = "AdversoAutoComplete"
VALOR_CAUSA_INPUT_ID = "ValorCausa"
ESTRATEGIA_SELECT_ID = "EstrategiaId"

async def fill_new_process_form(page, data: Dict[str, Any], process_id: int):  # 2025-11-21: process_id OBRIGAT√ìRIO
    update_status("navegando_formulario", "Navegando para formul√°rio de novo processo...", process_id=process_id)
    log("[FORM] aguardando /Processo/form")
    try:
        await page.wait_for_url(re.compile(r"/Processo/form"), timeout=NAV_TIMEOUT_MS)
    except Exception:
        pass
    await _settle(page, "form aberto")
    update_status("formulario_aberto", "Formul√°rio aberto - iniciando preenchimento", process_id=process_id)

    # üîß DEBUGGING: Logar process_id e dados cr√≠ticos do banco
    # 2025-12-02: Logs expandidos para diagnosticar data bleeding entre workers
    log(f"[FORM][DEBUG] ‚ïê‚ïê‚ïê PROCESSO #{process_id} ‚ïê‚ïê‚ïê")
    log(f"[FORM][DEBUG] data['numero_processo'] = {data.get('numero_processo')}")
    log(f"[FORM][DEBUG] data['cnj'] = {data.get('cnj')}")
    log(f"[FORM][DEBUG] data['parte_adversa_nome'] = {data.get('parte_adversa_nome')}")
    log(f"[FORM][DEBUG] data['cargo_funcao'] = {data.get('cargo_funcao')}")
    log(f"[FORM][DEBUG] data['cargo'] = {data.get('cargo')}")
    log(f"[FORM][DEBUG] data['pis'] = {data.get('pis')}")
    log(f"[FORM][DEBUG] data['ctps'] = {data.get('ctps')}")
    log(f"[FORM][DEBUG] data['salario'] = {data.get('salario')}")
    log(f"[FORM][DEBUG] data['data_admissao'] = {data.get('data_admissao')}")
    log(f"[FORM][DEBUG] data['data_demissao'] = {data.get('data_demissao')}")
    log(f"[FORM][DEBUG] len(data) = {len(data)} campos")
    log(f"[FORM][DEBUG] ‚ïê‚ïê‚ïê FIM DEBUG #{process_id} ‚ïê‚ïê‚ïê")

    # ORDEM CORRETA: Tipo ‚Üí CNJ ‚Üí N√∫mero
    # O campo #ProtocoloInicial √© CRIADO pelo eLaw quando marcamos Tipo=Eletr√¥nico
    import re as regex_module  # Force reimport to avoid async scope issues
    cnj = extract_cnj_from_anywhere(data)
    cnj_digits = regex_module.sub(r'\D', '', cnj or '')
    log(f"[CNJ][DEBUG] ‚úÖ CNJ extra√≠do para processo #{process_id}: '{cnj}' ({len(cnj_digits)} d√≠gitos)")
    
    if RPA_EXPECT_CNJ:
        exp = re.sub(r"\D", "", RPA_EXPECT_CNJ)
        got = re.sub(r"\D", "", cnj)
        if exp and got and exp != got:
            log(f"[CNJ][WARN] detectado '{cnj}' difere de RPA_EXPECT_CNJ='{RPA_EXPECT_CNJ}' ‚Äî usando o EXPECT")
            cnj = _cnj_normalize(RPA_EXPECT_CNJ)
    _must(bool(cnj), "numero_processo vazio")

    # 1) Tipo do processo = Eletr√¥nico
    update_status("tipo_processo", "Selecionando tipo: Eletr√¥nico", process_id=process_id)
    _ = await set_tipo_processo_virtual(page, want_virtual=True)
    await _settle(page, "radio:tipo")
    
    # 2) CNJ
    update_status("preenchendo_cnj", f"Preenchendo n√∫mero do processo (CNJ, process_id=process_id): {cnj}")
    log(f"[CNJ] ‚ïê‚ïê‚ïê INICIANDO PREENCHIMENTO CNJ PARA PROCESSO #{process_id} ‚ïê‚ïê‚ïê")
    await ensure_cnj_flag_on(page)
    
    # üîß FIX CR√çTICO: Aguardar campo CNJ aparecer no DOM ap√≥s AJAX do tipo Eletr√¥nico
    await _settle(page, "cnj_flag_settle")  # Espera adicional ap√≥s marcar flag CNJ
    _must(await wait_for_cnj_container(page), "Campo CNJ n√£o apareceu no DOM ap√≥s AJAX")
    
    _must(await set_cnj_value(page, cnj), "N√∫mero do Processo (CNJ)")
    await _settle(page, "input:cnj")
    await ensure_cnj_still_present(page, cnj)
    log(f"‚úÖ [FORM] CNJ preenchido: {cnj}")
    update_status("cnj_preenchido", f"CNJ preenchido com sucesso: {cnj}", process_id=process_id)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # FIM DO FLUXO CNJ (2 etapas conclu√≠das: Radio Sim + Textbox preenchido)
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    # üîß 2025-11-27: AGUARDAR AUTOFILL - O eLaw preenche Estado/Comarca automaticamente via AJAX
    # Isso substitui o wait fixo de 2.5s por uma espera inteligente que verifica os campos
    autofill_ok = await wait_for_cnj_autofill(page, timeout_ms=12000, process_id=process_id)
    if not autofill_ok:
        log(f"[FORM][WARN] Campos autom√°ticos n√£o preenchidos - continuando mesmo assim...")
        # Espera adicional como fallback se autofill n√£o detectou nada
        await page.wait_for_timeout(2000)

    # 3) Sistema Eletr√¥nico
    update_status("aguardando_sistema_eletronico", "Aguardando dropdown Sistema Eletr√¥nico ficar pronto...", process_id=process_id)
    await wait_for_select_ready(page, "SistemaEletronicoId", 1, 15000)  # Aumentado de 7s para 15s
    update_status("abrindo_sistema_eletronico", "Abrindo dropdown Sistema Eletr√¥nico...", process_id=process_id)
    btn, cont = await _open_bs_and_get_container(page, "SistemaEletronicoId")
    sys_options = _clean_choices(await _collect_options_from_container(cont)) if cont else []
    if btn:
        try:
            await btn.press("Escape")
        except Exception:
            pass
    wanted_sys = (
        _best_match(sys_options, resolve_sistema_eletronico(data), prefer_words=["pje", "juizo 100", "e-proc", "projudi"], threshold=10)
        if sys_options
        else resolve_sistema_eletronico(data)
    )
    _must(
        await set_select_fuzzy_any(
            page,
            "SistemaEletronicoId",
            wanted_sys,
            fallbacks=sys_options[:6] if sys_options else ["PJE", "Ju√≠zo 100% Digital - PJE", "E-PROC", "PROJUDI"],
            prefer_words=["pje", "juizo", "e-proc", "projudi"],
        ),
        "Sistema Eletr√¥nico",
    )
    await _settle(page, "select:sistema")
    await ensure_cnj_still_present(page, cnj)
    update_field_status("sistema_eletronico", "Sistema Eletr√¥nico", wanted_sys)

    # 4) N√∫mero Processo Antigo
    old_num = (data.get("numero_processo_antigo") or "").strip()
    if old_num:
        await set_input_by_id(page, "NumeroProcessoAntigo", old_num, "N√∫mero Processo Antigo")
        await _settle(page, "input:cnj_old")
        update_field_status("numero_processo_antigo", "N√∫mero Processo Antigo", old_num)

    # 5) √Årea do Direito
    update_status("area_direito", "Preenchendo √Årea do Direito...", process_id=process_id)
    await wait_for_select_ready(page, "AreaDireitoId", 1, 15000)
    btn, cont = await _open_bs_and_get_container(page, "AreaDireitoId")
    area_options = _clean_choices(await _collect_options_from_container(cont)) if cont else []
    if btn:
        try:
            await btn.press("Escape")
        except Exception:
            pass
    wanted_area = _best_match(area_options, resolve_area_direito(data), threshold=10) if area_options else resolve_area_direito(data)
    _must(
        await set_select_fuzzy_any(page, "AreaDireitoId", wanted_area, fallbacks=(area_options[:8] if area_options else AREA_LIST)),
        "√Årea do Direito",
    )
    await _settle(page, "select:area")
    await ensure_cnj_still_present(page, cnj)
    update_field_status("area_direito", "√Årea do Direito", wanted_area)

    # 6) Estado/Comarca (auto OU manual se autofill falhou)
    # üîß 2025-11-27: Refatorado para usar helper robusto force_select_bootstrap_by_text
    estado = ""
    comarca = ""
    
    # Primeiro, verificar se o autofill do eLaw preencheu Estado/Comarca
    if await wait_for_select_ready(page, "EstadoId", 1, 9000):
        estado = await _get_selected_text(page, "EstadoId")
        log(f"[FORM] Estado (autofill): '{estado}'")
    
    if await wait_for_select_ready(page, "CidadeId", 1, 5000):
        comarca = await _get_selected_text(page, "CidadeId")
        log(f"[FORM] Comarca (autofill): '{comarca}'")
    
    # Se autofill n√£o preencheu, usar helper manual robusto
    estado_vazio = not estado or estado.lower() in ["selecione", "--", "---", ""]
    comarca_vazia = not comarca or comarca.lower() in ["selecione", "--", "---", ""]
    
    if estado_vazio or comarca_vazia:
        log(f"[FORM] Autofill falhou (Estado vazio: {estado_vazio}, Comarca vazia: {comarca_vazia}) - usando preenchimento manual...")
        estado_manual, comarca_manual = await select_estado_comarca_manual(page, cnj, data, process_id)
        
        # Usar valores manuais se autofill estava vazio
        if estado_vazio and estado_manual:
            estado = estado_manual
        if comarca_vazia and comarca_manual:
            comarca = comarca_manual
    
    # Log e status final
    if estado and comarca:
        update_status("localizacao_preenchida", f"‚úÖ Localiza√ß√£o: {estado} - {comarca}", process_id=process_id)
        update_field_status("estado", "Estado", estado)
        update_field_status("comarca", "Comarca", comarca)
    elif estado:
        update_status("localizacao_parcial", f"‚ö†Ô∏è Estado: {estado} (Comarca n√£o preenchida)", process_id=process_id)
        update_field_status("estado", "Estado", estado)
    else:
        log(f"[FORM][WARN] Estado e Comarca n√£o foram preenchidos - poss√≠vel problema com o CNJ")

    # 7) Origem
    try:
        await wait_for_select_ready(page, "OrigemId", 1, 7000)
        btn, cont = await _open_bs_and_get_container(page, "OrigemId")
        origem_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
        if btn:
            try:
                await btn.press("Escape")
            except Exception:
                pass
        area_sel = (await _get_selected_text(page, "AreaDireitoId")) or ""
        pdf_text = data.get("_pdf_text", "")
        heur = resolve_origem_final(data, area_sel, pdf_text)
        wanted = (
            _best_match(origem_opts, heur, prefer_words=(["trt"] if heur == "TRT" else ["tst"]), threshold=10) if origem_opts else heur
        )
        _must(
            await set_select_fuzzy_any(
                page,
                "OrigemId",
                wanted,
                fallbacks=(origem_opts[:8] if origem_opts else ["TRT", "TST", "TRF", "JF", "PROCON", "PREFEITURA", "RECEITA FEDERAL", "STJ", "STF", "√ìRG√ÉO ADMINISTRATIVO"]),
            ),
            "Origem",
        )
        await _settle(page, "select:origem")
    except Exception as e:
        log(f"[Origem][WARN] {e}")
    await ensure_cnj_still_present(page, cnj)

    # 8) N√∫mero do √ìrg√£o - COM FALLBACK COMPLETO
    try:
        pdf_text = data.get("_pdf_text", "")
        
        # üîß NOVO: Sistema universal de fallback (data ‚Üí PDF extraction)
        num_orgao_raw = extract_field_with_full_fallback(
            field_name="numero_orgao",
            data=data,
            pdf_text=pdf_text,
            pdf_extractor=extract_numero_orgao_from_pdf,
            data_keys=["numero_orgao", "numero_jurisdicao", "orgao_numero"]
        )
        
        num_orgao = _coerce_numero_orgao(num_orgao_raw) if num_orgao_raw else ""
        
        if num_orgao:
            _must(await set_input_by_id(page, "NumeroJurisdicao", num_orgao, "N√∫mero do √ìrg√£o"), "N√∫mero do √ìrg√£o")
            try:
                await page.locator("#NumeroJurisdicao").press("Enter")
            except Exception:
                await page.evaluate(
                    """() => {
                  const el=document.getElementById('NumeroJurisdicao'); if(!el) return;
                  el.dispatchEvent(new KeyboardEvent('keydown',{key:'Enter',bubbles:true}));
                  el.dispatchEvent(new KeyboardEvent('keyup',{key:'Enter',bubbles:true}));
                  el.dispatchEvent(new Event('change',{bubbles:true}));
                  el.dispatchEvent(new Event('input',{bubbles:true}));
                }"""
                )
            await _settle(page, "input:num_orgao")
        else:
            log("[Num√ìrg√£o][WARN] N√∫mero do √≥rg√£o n√£o encontrado em data nem PDF")
    except Exception as e:
        log(f"[Num√ìrg√£o][WARN] {e}")

    # 9) √ìrg√£o (NaturezaId)
    try:
        await wait_for_select_ready(page, "NaturezaId", 1, 7000)
        btn, cont = await _open_bs_and_get_container(page, "NaturezaId")
        org_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
        if btn:
            try:
                await btn.press("Escape")
            except Exception:
                pass
        origem_sel = (await _get_selected_text(page, "OrigemId")) or ""
        prefer = (
            ["Vara do Trabalho", "CEJUSC", "N√∫cleo de Justi√ßa 4.0", "Turma"]
            if "trt" in norm(origem_sel)
            else ["Turma", "SDI", "√ìrg√£o Especial", "Tribunal Pleno", "Presid√™ncia"]
        )
        wanted = None
        for p in prefer:
            m = _best_match(org_opts, p, threshold=10)
            if m:
                wanted = m
                break
        if not wanted:
            wanted = org_opts[0] if org_opts else "Vara do Trabalho"
        _must(
            await set_select_fuzzy_any(page, "NaturezaId", wanted, fallbacks=org_opts[:8] if org_opts else None),
            "√ìrg√£o (NaturezaId)",
        )
        await _settle(page, "select:orgao")
    except Exception as e:
        log(f"[√ìrg√£o][WARN] {e}")

    # 10) C√©lula (EscritorioId)
    try:
        await wait_for_select_ready(page, "EscritorioId", 1, 8000)
        btn, cont = await _open_bs_and_get_container(page, "EscritorioId")
        cel_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
        if btn:
            try:
                await btn.press("Escape")
            except Exception:
                pass

        pdf_text = data.get("_pdf_text", "")
        wanted, why = decide_celula_from_sources(data, pdf_text, cel_opts)
        if not cel_opts:
            try:
                btn2, cont2 = await _open_bs_and_get_container(page, "EscritorioId")
                cel_opts = _clean_choices(await _collect_options_from_container(cont2)) if cont2 else []
                if btn2:
                    try:
                        await btn2.press("Escape")
                    except Exception:
                        pass
                if cel_opts:
                    wanted, why = decide_celula_from_sources(data, pdf_text, cel_opts)
            except Exception:
                pass
        ok = await set_select_fuzzy_any(
            page,
            "EscritorioId",
            wanted,
            fallbacks=cel_opts[:8] if cel_opts else ["Trabalhista GPA", "Trabalhista Outros Clientes", "Em Segredo"],
        )
        _must(ok, "C√©lula")
        await _settle(page, "select:celula")
        sel_final = (await _get_selected_text(page, "EscritorioId") or "").strip()
        log(f"[C√âLULA] alvo='{wanted}' | selecionada='{sel_final}' | motivo: {why}")
    except Exception as e:
        log(f"[C√©lula][WARN] {e}")

    # 11) Foro (JuizadoId) - COM FALLBACK COMPLETO
    try:
        await wait_for_select_ready(page, "JuizadoId", 1, 7000)
        raw_opts = await page.evaluate(
            """sid=>{
          const el=document.getElementById(sid); if(!el||!el.options) return [];
          return [...el.options].map(o=>({text:(o.textContent||'').trim(), value:(o.value||'').trim()}));
        }""",
            "JuizadoId",
        ) or []
    except Exception:
        raw_opts = []
    
    try:
        foro_opts = _clean_choices([o["text"] for o in raw_opts])
        comarca = (await _get_selected_text(page, "CidadeId")) or ""
        
        # üîß NOVO: Sistema universal de fallback (data ‚Üí PDF ‚Üí dropdown options)
        pdf_text = data.get("_pdf_text", "")
        wanted = extract_field_with_full_fallback(
            field_name="foro",
            data=data,
            pdf_text=pdf_text,
            dropdown_options=foro_opts,
            pdf_extractor=extract_foro_from_pdf,
            data_keys=["foro", "juizado"],
            threshold=10
        )
        
        # Fallback: usa comarca se dispon√≠vel
        if not wanted and comarca:
            wanted = _best_match(foro_opts, comarca, threshold=5) or comarca
            log(f"[Foro] Usando comarca: {wanted}")
        
        # √öltimo fallback
        if not wanted:
            wanted = foro_opts[0] if foro_opts else "Foro Central"
            log(f"[Foro] Usando fallback final: {wanted}")
        
        # Preencher dropdown normalmente
        ok = await set_select_fuzzy_any(page, "JuizadoId", wanted, fallbacks=foro_opts[:8] if foro_opts else [comarca, "Foro Central"])
        if not ok:
            ok = await _set_native_select_fuzzy(page, "JuizadoId", wanted)
        _must(ok, "Foro (JuizadoId)")
        await _settle(page, "select:foro")
        
    except Exception as e:
        log(f"[Foro][WARN] {e}")

    # 12) Assunto (AreaProcessoId) - COM FALLBACK COMPLETO E GARANTIA DE PREENCHIMENTO
    assunto_preenchido = False
    assunto_wanted = None
    try:
        log(f"[Assunto] Iniciando preenchimento do Assunto (AreaProcessoId)...")
        await wait_for_select_ready(page, "AreaProcessoId", 1, 7000)
        btn, cont = await _open_bs_and_get_container(page, "AreaProcessoId")
        assunto_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
        log(f"[Assunto] Op√ß√µes do dropdown: {len(assunto_opts)} itens")
        if btn:
            try:
                await btn.press("Escape")
            except Exception:
                pass
        
        pdf_text = data.get("_pdf_text", "")
        assunto_wanted = extract_field_with_full_fallback(
            field_name="assunto",
            data=data,
            pdf_text=pdf_text,
            dropdown_options=assunto_opts,
            pdf_extractor=extract_assunto_from_pdf,
            data_keys=["assunto", "tema", "materia", "assunto_processo"],
            threshold=14
        )
        
        if not assunto_wanted and assunto_opts:
            assunto_wanted = _best_match(assunto_opts, "Reclama√ß√£o Trabalhista", threshold=10) or assunto_opts[0]
            log(f"[Assunto] Usando fallback final: {assunto_wanted}")
        
        if assunto_wanted:
            ok = await set_select_fuzzy_any(page, "AreaProcessoId", assunto_wanted, fallbacks=assunto_opts[:8] if assunto_opts else None)
            if ok:
                await _settle(page, "select:assunto")
                update_field_status("assunto", "Assunto", assunto_wanted)
                assunto_preenchido = True
                log(f"[Assunto] ‚úÖ Preenchido: {assunto_wanted}")
            else:
                log(f"[Assunto][WARN] Falha ao preencher com set_select_fuzzy_any")
    except Exception as e:
        log(f"[Assunto][WARN] Erro durante preenchimento: {e}")
    
    if not assunto_preenchido:
        log(f"[Assunto][RETRY] Tentando preenchimento de emerg√™ncia...")
        try:
            await wait_for_select_ready(page, "AreaProcessoId", 1, 5000)
            fallback_assunto = data.get("assunto") or "Reclama√ß√£o Trabalhista"
            ok = await set_select_fuzzy_any(page, "AreaProcessoId", fallback_assunto, 
                fallbacks=["Reclama√ß√£o Trabalhista No Rito Sumar√≠ssimo", "Reclama√ß√£o Trabalhista", "A√ß√£o Trabalhista"])
            if ok:
                await _settle(page, "select:assunto")
                update_field_status("assunto", "Assunto", fallback_assunto)
                assunto_preenchido = True
                log(f"[Assunto] ‚úÖ Preenchido via emerg√™ncia: {fallback_assunto}")
        except Exception as e2:
            log(f"[Assunto][ERROR] Falha total: {e2}")

    # 13) Inst√¢ncia - COM FALLBACK COMPLETO
    try:
        ready = await wait_for_select_ready(page, INSTANCIA_SELECT_ID, 1, 9000)
        if not ready:
            try:
                await page.evaluate(
                    """(sid)=>{
                  const btn = document.querySelector(`button.btn.dropdown-toggle[data-id="${sid}"]`);
                  if(!btn) return;
                  const root = btn.closest('.input-group') || btn.closest('.bootstrap-select')?.parentElement;
                  const refresh = root && root.querySelector('.input-group-append .btn, .fa-sync, .fa-refresh, .fa-rotate-right');
                  if(refresh) (refresh.closest('.btn')||refresh).click();
                }""",
                    INSTANCIA_SELECT_ID,
                )
            except Exception:
                pass
            ready = await wait_for_select_ready(page, INSTANCIA_SELECT_ID, 1, 4000)

        inst_opts = []
        if ready:
            btn, cont = await _open_bs_and_get_container(page, INSTANCIA_SELECT_ID)
            inst_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
            if btn:
                try:
                    await btn.press("Escape")
                except Exception:
                    pass
        
        # üîß NOVO: Sistema universal de fallback (data ‚Üí PDF ‚Üí dropdown options)
        pdf_text = data.get("_pdf_text", "")
        pick = extract_field_with_full_fallback(
            field_name="instancia",
            data=data,
            pdf_text=pdf_text,
            dropdown_options=inst_opts,
            pdf_extractor=extract_instancia_from_pdf,
            data_keys=["instancia", "grau"],
            threshold=10
        )

        # Fallback antigo: usar prefer list se nada funcionou
        if not pick and inst_opts:
            prefs = ["Primeira Inst√¢ncia", "1¬∫ Grau", "Primeiro Grau", "2¬∫ Grau", "Segunda Inst√¢ncia", "Superior"]
            for ptxt in prefs:
                m = _best_match(inst_opts, ptxt, threshold=10)
                if m:
                    pick = m
                    log(f"[Inst√¢ncia] Usando prefer list: {pick}")
                    break

        if not pick:
            for label_txt in ("Inst√¢ncia", "Instancia"):
                ok = await set_select_by_label_contains(page, label_txt, "Primeira Inst√¢ncia", fallbacks=["Primeira Inst√¢ncia", "1¬∫ Grau", "Primeiro Grau"])
                if ok:
                    pick = "Primeira Inst√¢ncia"
                    break

        if pick:
            _must(
                await set_select_fuzzy_any(page, INSTANCIA_SELECT_ID, pick, fallbacks=["Primeira Inst√¢ncia", "1¬∫ Grau", "Primeiro Grau", "2¬∫ Grau"]),
                "Inst√¢ncia",
            )
            await _settle(page, "select:instancia")
            update_field_status("instancia", "Inst√¢ncia", pick)
        else:
            log("[Inst√¢ncia][WARN] n√£o foi poss√≠vel determinar; mantendo em branco")
    except Exception as e:
        log(f"[Inst√¢ncia][WARN] {e}")

    # 14) NPC (opcional) - COM FALLBACK COMPLETO
    try:
        pdf_text = data.get("_pdf_text", "")
        
        # üîß NOVO: Sistema universal de fallback (data ‚Üí PDF extraction)
        npc = extract_field_with_full_fallback(
            field_name="npc",
            data=data,
            pdf_text=pdf_text,
            pdf_extractor=extract_npc_from_pdf,
            data_keys=["npc", "numero_processo_antigo"]
        )
        
        if npc:
            await set_input_by_id(page, "NPC", npc, "NPC")
            await _settle(page, "input:npc")
    except Exception as e:
        log(f"[NPC][WARN] {e}")

    # 15) Classe/Objeto (quando houver campo √† parte)
    try:
        ready = await wait_for_select_ready(page, "ClasseId", 1, 7000)
        if ready:
            btn, cont = await _open_bs_and_get_container(page, "ClasseId")
            obj_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
            if btn:
                try:
                    await btn.press("Escape")
                except Exception:
                    pass
            wanted = None
            for k in ["objeto", "classe", "classe_processual"]:
                v = (data.get(k) or "").strip()
                if not v:
                    continue
                m = _best_match(obj_opts, v, threshold=15)
                if m:
                    wanted = m
                    break
            if wanted:
                ok = await set_select_fuzzy_any(page, "ClasseId", wanted, fallbacks=obj_opts[:6] if obj_opts else None)
                if ok:
                    await _settle(page, "select:classe")
    except Exception as e:
        log(f"[Classe][WARN] {e}")

    # 16) Tipo de A√ß√£o (‚≠ê garante execu√ß√£o) - COM GARANTIA DE PREENCHIMENTO
    tipo_acao_preenchido = False
    try:
        log(f"[TipoA√ß√£o] Iniciando preenchimento do Tipo de A√ß√£o (TipoAcaoId)...")
        await wait_for_select_ready(page, "TipoAcaoId", 1, 9000)
        btn, cont = await _open_bs_and_get_container(page, "TipoAcaoId")
        tp_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
        log(f"[TipoA√ß√£o] Op√ß√µes do dropdown: {len(tp_opts)} itens")
        if not tp_opts:
            try:
                await page.evaluate(
                    """(sid)=>{
                  const btn = document.querySelector(`button.btn.dropdown-toggle[data-id="${sid}"]`);
                  if(!btn) return;
                  const root = btn.closest('.input-group') || btn.closest('.bootstrap-select')?.parentElement;
                  const refresh = root && root.querySelector('.input-group-append .btn, .fa-sync, .fa-refresh, .fa-rotate-right');
                  if(refresh) (refresh.closest('.btn')||refresh).click();
                }""",
                    "TipoAcaoId",
                )
            except Exception:
                pass
            btn, cont = await _open_bs_and_get_container(page, "TipoAcaoId")
            tp_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
            log(f"[TipoA√ß√£o] Ap√≥s refresh: {len(tp_opts)} itens")
        if btn:
            try:
                await btn.press("Escape")
            except Exception:
                pass

        assunto_sel = (await _get_selected_text(page, "AreaProcessoId")) or ""
        pdf_text = data.get("_pdf_text", "")
        wanted = pick_tipo_acao_smart(tp_opts, data, pdf_text, assunto_sel) if tp_opts else None
        if not wanted and tp_opts:
            wanted = tp_opts[0]
        if not wanted:
            wanted = data.get("sub_area_direito") or "A√ß√£o Trabalhista - Rito Sumar√≠ssimo"

        if wanted:
            ok = await set_select_fuzzy_any(page, "TipoAcaoId", wanted, fallbacks=tp_opts[:10] if tp_opts else None)
            if ok:
                await _settle(page, "select:tipo_acao")
                update_field_status("tipo_acao", "Tipo de A√ß√£o", wanted)
                tipo_acao_preenchido = True
                log(f"[TipoA√ß√£o] ‚úÖ Preenchido: {wanted}")
            else:
                log(f"[TipoA√ß√£o][WARN] Falha ao preencher com set_select_fuzzy_any")
        else:
            log("[TipoA√ß√£o][WARN] n√£o foi poss√≠vel determinar valor")
    except Exception as e:
        log(f"[TipoA√ß√£o][WARN] Erro durante preenchimento: {e}")
    
    if not tipo_acao_preenchido:
        log(f"[TipoA√ß√£o][RETRY] Tentando preenchimento de emerg√™ncia...")
        try:
            await wait_for_select_ready(page, "TipoAcaoId", 1, 5000)
            fallback_tipo = data.get("sub_area_direito") or "A√ß√£o Trabalhista - Rito Sumar√≠ssimo"
            ok = await set_select_fuzzy_any(page, "TipoAcaoId", fallback_tipo,
                fallbacks=["A√ß√£o Trabalhista - Rito Sumar√≠ssimo", "A√ß√£o Trabalhista", "Reclama√ß√£o Trabalhista"])
            if ok:
                await _settle(page, "select:tipo_acao")
                update_field_status("tipo_acao", "Tipo de A√ß√£o", fallback_tipo)
                tipo_acao_preenchido = True
                log(f"[TipoA√ß√£o] ‚úÖ Preenchido via emerg√™ncia: {fallback_tipo}")
        except Exception as e2:
            log(f"[TipoA√ß√£o][ERROR] Falha total: {e2}")

    # 16.b) Objeto/Classe correlata (ObjetoId/Objeto/ClasseId) - COM GARANTIA DE PREENCHIMENTO
    objeto_preenchido = False
    try:
        log(f"[Objeto] Iniciando preenchimento do Objeto...")
        candidatos = ["ObjetoId", "Objeto", "ClasseId"]
        alvo_id = ""
        opts = []
        for sid in candidatos:
            if await wait_for_select_ready(page, sid, 1, 3000):
                btn, cont = await _open_bs_and_get_container(page, sid)
                opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
                if btn:
                    try:
                        await btn.press("Escape")
                    except Exception:
                        pass
                if opts:
                    alvo_id = sid
                    log(f"[Objeto] Encontrado campo: {alvo_id} com {len(opts)} op√ß√µes")
                    break
        if alvo_id:
            assunto_sel = (await _get_selected_text(page, "AreaProcessoId")) or ""
            tipo_sel = (await _get_selected_text(page, "TipoAcaoId")) or ""
            pdf_text = data.get("_pdf_text", "")
            wanted = pick_objeto_smart(opts, data, pdf_text, assunto_sel, tipo_sel)
            if not wanted:
                wanted = data.get("objeto") or "Verbas rescis√≥rias"
            ok = await set_select_fuzzy_any(page, alvo_id, wanted, fallbacks=opts[:10] if opts else None)
            if ok:
                await _settle(page, "select:objeto")
                update_field_status("objeto", "Objeto", wanted)
                objeto_preenchido = True
                log(f"[Objeto] ‚úÖ Preenchido: {wanted}")
            else:
                log(f"[Objeto][WARN] Falha ao preencher com set_select_fuzzy_any")
        else:
            log(f"[Objeto][INFO] Nenhum campo de objeto encontrado (pode n√£o existir neste formul√°rio)")
    except Exception as e:
        log(f"[Objeto][WARN] Erro durante preenchimento: {e}")
    
    if not objeto_preenchido and alvo_id:
        log(f"[Objeto][RETRY] Tentando preenchimento de emerg√™ncia...")
        try:
            fallback_objeto = data.get("objeto") or "Verbas rescis√≥rias"
            ok = await set_select_fuzzy_any(page, alvo_id, fallback_objeto,
                fallbacks=["Verbas rescis√≥rias", "Verbas Salariais", "Verbas Rescis√≥rias e Salariais"])
            if ok:
                await _settle(page, "select:objeto")
                update_field_status("objeto", "Objeto", fallback_objeto)
                objeto_preenchido = True
                log(f"[Objeto] ‚úÖ Preenchido via emerg√™ncia: {fallback_objeto}")
        except Exception as e2:
            log(f"[Objeto][ERROR] Falha total: {e2}")

    # 17) A PARTIR DAQUI: ordem pedida (cliente‚Üíparte etc.)
    pdf_text = data.get("_pdf_text", "")
    inferred = infer_cliente_grupo_and_parte(pdf_text, data)

    # 17.1) Cliente (GrupoClienteId) - COM FALLBACK COMPLETO
    try:
        await wait_for_select_ready(page, GRUPO_CLIENTE_SELECT_ID, 1, 7000)
        btn, cont = await _open_bs_and_get_container(page, GRUPO_CLIENTE_SELECT_ID)
        grp_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
        if btn:
            try:
                await btn.press("Escape")
            except Exception:
                pass
        
        # üîß NOVO: Sistema universal de fallback (data ‚Üí PDF ‚Üí dropdown options)
        target_group = extract_field_with_full_fallback(
            field_name="cliente",
            data=data,
            pdf_text=pdf_text,
            dropdown_options=grp_opts,
            pdf_extractor=extract_cliente_grupo_from_pdf,
            data_keys=["grupo", "cliente", "empresa"],
            threshold=12
        )
        
        # Fallback final se nada funcionou
        if not target_group:
            target_group = inferred.get("cliente_grupo") or "Grupo P√£o de A√ß√∫car"
            log(f"[CLIENTE] Usando fallback final: {target_group}")
        
        ok = await set_select_fuzzy_any(
            page, GRUPO_CLIENTE_SELECT_ID, target_group, fallbacks=grp_opts[:6] if grp_opts else ["Grupo P√£o de A√ß√∫car"]
        )
        if ok:
            log(f"‚úÖ [CLIENTE] {GRUPO_CLIENTE_SELECT_ID}: '{target_group}'")
            update_status("cliente_preenchido", f"‚úÖ Cliente preenchido: {target_group}", process_id=process_id)
            update_field_status("cliente", "Cliente/Grupo", target_group)
        await _settle(page, "select:grupo_cliente")
    except Exception as e:
        log(f"[Cliente (Grupo)][WARN] {e}")

    # 17.2) Parte Adversa (Tipo) ‚Äî radio (1=F√≠sica, 2=Jur√≠dica)
    try:
        tipo = inferred["parte_adversa_tipo"]
        val = "1" if norm(tipo) == "fisica" else "2"
        await set_radio_by_name(page, PARTE_ADVERSA_TIPO_NAME, val, "Parte Adversa (Tipo)")
        await _settle(page, "radio:adverso_tipo")
        update_field_status("parte_adversa_tipo", "Tipo Parte Adversa", tipo)
    except Exception as e:
        log(f"[Adverso Tipo][WARN] {e}")

    # 17.3) Posi√ß√£o Parte Interessada (PosicaoClienteId)
    try:
        await wait_for_select_ready(page, POSICAO_CLIENTE_SELECT_ID, 1, 7000)
        
        # üîí CRITICAL: Filtra placeholders inv√°lidos ANTES de usar fallback do banco
        # Sincronizado com filtro em infer_cliente_grupo_and_parte() (linhas 2821-2836)
        INVALID_POSICOES = {"PARTES", "PARTE", ""}
        
        # Obt√©m posi√ß√£o inferida primeiro
        pos_from_inferred = inferred.get("posicao_parte_interessada", "")
        
        # Sanitiza fallback do banco (remove placeholders gen√©ricos)
        pos_from_db = str(data.get("posicao_parte_interessada") or "").strip()
        if pos_from_db.upper() in INVALID_POSICOES:
            log(f"[POSI√á√ÉO][WARN] Placeholder gen√©rico/inv√°lido no banco ('{pos_from_db}') - ignorando fallback do DB")
            pos_from_db = ""  # ‚ùå Ignora "PARTES" do banco
        
        # Usa infer√™ncia ‚Üí banco sanitizado ‚Üí fallback "RECLAMADO"
        pos_raw = pos_from_inferred or pos_from_db or "RECLAMADO"
        
        # Normaliza para o label oficial do eLaw
        pos_target = normalize_posicao(pos_raw)
        log(f"[POSI√á√ÉO] Raw: '{pos_raw}' -> Normalizado: '{pos_target}'")
        
        # Tenta obter o ID do eLaw diretamente do mapeamento
        pos_id = get_posicao_id(pos_target)
        
        if pos_id:
            # Se temos o ID, tenta selecionar diretamente
            log(f"[POSI√á√ÉO] Usando ID do mapeamento: {pos_id} ({pos_target})")
            try:
                sel = f"#{POSICAO_CLIENTE_SELECT_ID}"
                await page.select_option(sel, value=pos_id, timeout=SHORT_TIMEOUT_MS)
                log(f"‚úÖ [POSI√á√ÉO] Selecionado diretamente: ID={pos_id} ({pos_target})")
                update_field_status("posicao", "Posi√ß√£o Cliente", pos_target)
                ok = True
            except Exception as e:
                log(f"[POSI√á√ÉO][WARN] Falha ao selecionar por ID, tentando fuzzy: {e}")
                ok = False
        else:
            ok = False
        
        # Fallback: usa fuzzy matching se n√£o conseguiu por ID
        if not ok:
            btn, cont = await _open_bs_and_get_container(page, POSICAO_CLIENTE_SELECT_ID)
            pos_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
            if btn:
                try:
                    await btn.press("Escape")
                except Exception:
                    pass
            ok = await set_select_fuzzy_any(
                page, POSICAO_CLIENTE_SELECT_ID, pos_target, 
                fallbacks=pos_opts[:8] if pos_opts else ["RECLAMADO", "RECLAMANTE"]
            )
            if ok:
                log(f"[POSI√á√ÉO] Posi√ß√£o Parte Interessada (fuzzy): '{pos_target}'")
                update_field_status("posicao", "Posi√ß√£o Cliente", pos_target)
        
        await _settle(page, "select:posicao_cliente")
    except Exception as e:
        log(f"[Posi√ß√£o Interessada][WARN] {e}")

    # 17.4) Parte Adversa (Nome)
    try:
        adv_nome = inferred["parte_adversa_nome"] or data.get("parte_adversa_nome") or ""
        if adv_nome:
            await set_input_by_id(page, PARTE_ADVERSA_NOME_INPUT_ID, adv_nome, "Parte Adversa (Nome)")
            log(f"‚úÖ [PARTE ADVERSA] Nome preenchido: {adv_nome}")
            update_status("parte_adversa_preenchida", f"‚úÖ Parte adversa preenchida: {adv_nome}", process_id=process_id)
            update_field_status("parte_adversa_nome", "Nome Parte Adversa", adv_nome)
            await _settle(page, "input:adverso_nome")
    except Exception as e:
        log(f"[Adverso Nome][WARN] {e}")

    # 17.4.1) UF OAB Advogado Adverso (dropdown)
    try:
        # Mapeamento de UFs para valores do dropdown AdvogadoAdversoEstadoOAB
        UF_OAB_MAP = {
            "AC": "27", "ACRE": "27",
            "AL": "23", "ALAGOAS": "23",
            "AP": "26", "AMAPA": "26", "AMAP√Å": "26",
            "AM": "21", "AMAZONAS": "21",
            "BA": "8", "BAHIA": "8",
            "CE": "19", "CEARA": "19", "CEAR√Å": "19",
            "DF": "12", "DISTRITO FEDERAL": "12",
            "ES": "20", "ESPIRITO SANTO": "20", "ESP√çRITO SANTO": "20",
            "GO": "15", "GOIAS": "15", "GOI√ÅS": "15",
            "MA": "25", "MARANHAO": "25", "MARANH√ÉO": "25",
            "MT": "14", "MATO GROSSO": "14",
            "MS": "13", "MATO GROSSO DO SUL": "13",
            "MG": "7", "MINAS GERAIS": "7",
            "PA": "22", "PARA": "22", "PAR√Å": "22",
            "PB": "10", "PARAIBA": "10", "PARA√çBA": "10",
            "PR": "5", "PARANA": "5", "PARAN√Å": "5",
            "PE": "9", "PERNAMBUCO": "9",
            "PI": "24", "PIAUI": "24", "PIAU√ç": "24",
            "RJ": "3", "RIO DE JANEIRO": "3",
            "RN": "11", "RIO GRANDE DO NORTE": "11",
            "RS": "4", "RIO GRANDE DO SUL": "4",
            "RO": "16", "RONDONIA": "16", "ROND√îNIA": "16",
            "RR": "17", "RORAIMA": "17",
            "SC": "6", "SANTA CATARINA": "6",
            "SP": "18", "SAO PAULO": "18", "S√ÉO PAULO": "18",
            "SE": "28", "SERGIPE": "28",
            "TO": "2", "TOCANTINS": "2",
        }
        
        # Tentar obter UF do advogado adverso do data (se extra√≠do)
        uf_adv = data.get("advogado_adverso_uf", "") or data.get("uf_oab_adverso", "")
        
        # Se n√£o tiver UF espec√≠fica, usar a UF do processo como fallback
        if not uf_adv:
            uf_processo = data.get("uf", "") or data.get("estado", "")
            if uf_processo:
                uf_adv = uf_processo.upper().strip()
                log(f"[UF OAB Adverso] Usando UF do processo como fallback: {uf_adv}")
        
        # Se ainda n√£o tiver, usar SP como default (mais comum em trabalhistas)
        if not uf_adv:
            uf_adv = "SP"
            log("[UF OAB Adverso] Usando SP como default")
        
        uf_adv_upper = uf_adv.upper().strip()
        uf_value = UF_OAB_MAP.get(uf_adv_upper, "18")  # Default SP (18)
        
        log(f"[UF OAB Adverso] Selecionando UF: {uf_adv_upper} (value={uf_value})")
        
        # Tentar selecionar por value no dropdown bootstrap-select
        try:
            dropdown_id = "AdvogadoAdversoEstadoOAB"
            
            # Primeiro, clicar para abrir o dropdown
            btn_selector = f"button[data-id='{dropdown_id}'], .bootstrap-select[data-id='{dropdown_id}'] button"
            btn = page.locator(btn_selector).first
            if await btn.count() > 0 and await btn.is_visible(timeout=2000):
                await btn.click()
                await short_sleep_ms(500)
                
                # Procurar pela op√ß√£o com o texto da UF
                uf_text = uf_adv_upper if len(uf_adv_upper) == 2 else uf_adv_upper
                # Tentar encontrar por texto parcial
                for search_text in [uf_text, "S√ÉO PAULO", "SAO PAULO", "SP"]:
                    opt_selector = f".dropdown-menu li a:has-text('{search_text}')"
                    opt = page.locator(opt_selector).first
                    if await opt.count() > 0 and await opt.is_visible(timeout=500):
                        await opt.click()
                        log(f"[UF OAB Adverso] ‚úÖ Selecionado: {search_text}")
                        update_field_status("uf_oab_adverso", "UF OAB Advogado Adverso", search_text)
                        break
                else:
                    # Fallback: tentar selecionar por value diretamente
                    await page.evaluate(f"""
                        const sel = document.getElementById('{dropdown_id}');
                        if (sel) {{
                            sel.value = '{uf_value}';
                            sel.dispatchEvent(new Event('change', {{bubbles: true}}));
                        }}
                    """)
                    log(f"[UF OAB Adverso] ‚úÖ Selecionado por value: {uf_value}")
                    update_field_status("uf_oab_adverso", "UF OAB Advogado Adverso", uf_adv_upper)
            else:
                # Fallback direto via JavaScript
                await page.evaluate(f"""
                    const sel = document.getElementById('{dropdown_id}');
                    if (sel) {{
                        sel.value = '{uf_value}';
                        sel.dispatchEvent(new Event('change', {{bubbles: true}}));
                        // Atualizar bootstrap-select se dispon√≠vel
                        if (window.jQuery && window.jQuery.fn.selectpicker) {{
                            window.jQuery(sel).selectpicker('refresh');
                        }}
                    }}
                """)
                log(f"[UF OAB Adverso] ‚úÖ Selecionado via JS: {uf_value} ({uf_adv_upper})")
                update_field_status("uf_oab_adverso", "UF OAB Advogado Adverso", uf_adv_upper)
            
            await _settle(page, f"#{dropdown_id}")
        except Exception as e:
            log(f"[UF OAB Adverso][WARN] Erro ao selecionar dropdown: {e}")
    except Exception as e:
        log(f"[UF OAB Adverso][WARN] {e}")

    # 17.5) Parte Interessada (ClienteId) - COM FALLBACK COMPLETO
    try:
        await wait_for_select_ready(page, PARTE_INTERESSADA_SELECT_ID, 1, 8000)
        btn, cont = await _open_bs_and_get_container(page, PARTE_INTERESSADA_SELECT_ID)
        cli_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
        if btn:
            try:
                await btn.press("Escape")
            except Exception:
                pass
        
        # üîß NOVO: Sistema universal de fallback (data ‚Üí PDF ‚Üí dropdown options)
        pick = extract_field_with_full_fallback(
            field_name="parte_interessada",
            data=data,
            pdf_text=pdf_text,
            dropdown_options=cli_opts,
            pdf_extractor=extract_parte_interessada_from_pdf,
            data_keys=["parte_interessada", "cliente", "empresa"],
            threshold=15
        )
        
        # Fallback: usa inferred se nada funcionou
        if not pick:
            pit = inferred.get("parte_interessada_nome", "")
            if pit:
                pick = _best_match(cli_opts, pit, threshold=10) or pit
                log(f"[Parte Interessada] Usando inferred: {pick}")
        
        # √öltimo fallback: cliente_grupo ou primeira op√ß√£o
        if not pick and cli_opts:
            g = inferred.get("cliente_grupo", "")
            if g:
                pick = _best_match(cli_opts, g, threshold=10)
                log(f"[Parte Interessada] Tentando cliente_grupo: {pick}")
            if not pick:
                pick = cli_opts[0]
                log(f"[Parte Interessada] Usando primeira op√ß√£o: {pick}")
        
        if pick:
            ok = await set_select_fuzzy_any(
                page, PARTE_INTERESSADA_SELECT_ID, pick, fallbacks=cli_opts[:10] if cli_opts else None
            )
            if ok:
                log(f"[PARTE INTERESSADA] {PARTE_INTERESSADA_SELECT_ID}: '{pick}'")
                update_field_status("parte_interessada", "Parte Interessada", pick)
        await _settle(page, "select:parte_interessada")
    except Exception as e:
        log(f"[Parte Interessada][WARN] {e}")

    # 17.5.1) Data de Distribui√ß√£o
    try:
        data_distribuicao = data.get("data_distribuicao", "")
        log(f"[DEBUG][Data Distribui√ß√£o] Valor recebido: {repr(data_distribuicao)} (tipo: {type(data_distribuicao).__name__})")
        if data_distribuicao and isinstance(data_distribuicao, str) and data_distribuicao.strip():
            log(f"[DEBUG][Data Distribui√ß√£o] Tentando preencher...")
            # Tentar m√∫ltiplos IDs poss√≠veis para o campo de data de distribui√ß√£o
            date_field_ids = ["DataDistribuicao", "DataRecebimento", "DataAuditoria", "DataCadastro"]
            filled = False
            for field_id in date_field_ids:
                try:
                    field = page.locator(f"#{field_id}").first
                    if await field.count() > 0:
                        ok = await set_date_field_by_id(page, field_id, data_distribuicao, f"Data de Distribui√ß√£o ({field_id})")
                        if ok:
                            update_field_status("data_distribuicao", "Data de Distribui√ß√£o", data_distribuicao)
                            filled = True
                            log(f"[Data Distribui√ß√£o] ‚úÖ Preenchido em #{field_id}: {data_distribuicao}")
                            await _settle(page, f"#{field_id}")
                            break
                except Exception as e:
                    log(f"[Data Distribui√ß√£o][WARN] Tentativa {field_id}: {e}")
                    continue
            
            if not filled:
                log(f"[Data Distribui√ß√£o][WARN] Nenhum campo de data de distribui√ß√£o encontrado")
        else:
            log(f"[DEBUG][Data Distribui√ß√£o] Pulado - valida√ß√£o falhou")
    except Exception as e:
        log(f"[Data Distribui√ß√£o][WARN] {e}")

    # 17.6) Campos Trabalhistas
    update_status("preenchendo_dados_trabalhistas", "Preenchendo dados trabalhistas...", process_id=process_id)
    
    # 17.6.1) Data de Admiss√£o
    try:
        data_admissao = data.get("data_admissao", "")
        log(f"[DEBUG][Data Admiss√£o] Valor recebido: {repr(data_admissao)} (tipo: {type(data_admissao).__name__})")
        if data_admissao and isinstance(data_admissao, str) and data_admissao.strip():
            log(f"[DEBUG][Data Admiss√£o] Tentando preencher...")
            ok = await set_date_field_by_id(page, "DataAdmissao", data_admissao, "Data de Admiss√£o")
            if ok:
                update_field_status("data_admissao", "Data de Admiss√£o", data_admissao)
            await _settle(page, "#DataAdmissao")
        else:
            log(f"[DEBUG][Data Admiss√£o] Pulado - valida√ß√£o falhou")
    except Exception as e:
        log(f"[Data Admiss√£o][WARN] {e}")
    
    # 17.6.2) Data de Demiss√£o
    try:
        data_demissao = data.get("data_demissao", "")
        log(f"[DEBUG][Data Demiss√£o] Valor recebido: {repr(data_demissao)} (tipo: {type(data_demissao).__name__})")
        if data_demissao and isinstance(data_demissao, str) and data_demissao.strip():
            log(f"[DEBUG][Data Demiss√£o] Tentando preencher...")
            ok = await set_date_field_by_id(page, "DataDemissao", data_demissao, "Data de Demiss√£o")
            if ok:
                update_field_status("data_demissao", "Data de Demiss√£o", data_demissao)
            await _settle(page, "#DataDemissao")
        else:
            log(f"[DEBUG][Data Demiss√£o] Pulado - valida√ß√£o falhou")
    except Exception as e:
        log(f"[Data Demiss√£o][WARN] {e}")
    
    # 17.6.3) Motivo de Demiss√£o
    try:
        motivo_demissao = data.get("motivo_demissao", "")
        if motivo_demissao and isinstance(motivo_demissao, str) and motivo_demissao.strip():
            ok = await set_text_field_by_id(page, "MotivoDemissao", motivo_demissao, "Motivo de Demiss√£o")
            if ok:
                update_field_status("motivo_demissao", "Motivo de Demiss√£o", motivo_demissao)
            await _settle(page, "#MotivoDemissao")
    except Exception as e:
        log(f"[Motivo Demiss√£o][WARN] {e}")
    
    # 17.6.4) Sal√°rio (opcional - usa fun√ß√£o de texto direto sem convers√£o para inteiro)
    try:
        salario = data.get("salario", "")
        log(f"[DEBUG][Sal√°rio] Valor recebido: {repr(salario)} (tipo: {type(salario).__name__})")
        # Validar se √© string n√£o vazia antes de tentar preencher
        if salario and isinstance(salario, str) and salario.strip() and not salario.strip().startswith('{'):
            # Normalizar: remover "R$" e espa√ßos, manter formato brasileiro "1.516,00"
            salario_clean = salario.strip().replace("R$", "").replace(" ", "").strip()
            log(f"[DEBUG][Sal√°rio] Valor normalizado: {repr(salario_clean)}")
            
            # Usar fun√ß√£o de texto direto (N√ÉO usar set_valor_causa_any que converte para d√≠gitos)
            ok = await set_text_field_by_id(page, "Salario", salario_clean, "Sal√°rio")
            
            if ok:
                # Verificar se valor foi preenchido corretamente (n√£o zerado)
                try:
                    el = page.locator("#Salario").first
                    if await el.count() > 0:
                        valor_preenchido = await el.input_value()
                        log(f"[Sal√°rio] Valor preenchido no campo: {repr(valor_preenchido)}")
                        
                        # Warning se foi zerado incorretamente
                        if valor_preenchido and valor_preenchido.strip() in ("0", "0,00", "0.00") and re.search(r"[1-9]", salario_clean):
                            log(f"[Sal√°rio][WARN] ‚ö†Ô∏è Campo foi zerado! Esperado: {salario_clean}, Obtido: {valor_preenchido}")
                except Exception as e:
                    log(f"[Sal√°rio][WARN] Erro ao verificar valor preenchido: {e}")
                
                update_field_status("salario", "Sal√°rio", salario_clean)
            await _settle(page, "#Salario")
        else:
            log("[Sal√°rio] Campo vazio ou inv√°lido - pulando")
    except Exception as e:
        log(f"[Sal√°rio][WARN] {e}")
    
    # 17.6.5) Cargo
    try:
        cargo = data.get("cargo_funcao", "") or data.get("cargo", "")
        log(f"[DEBUG][Cargo] Valor recebido: {repr(cargo)} (tipo: {type(cargo).__name__})")
        if cargo and isinstance(cargo, str) and cargo.strip():
            log(f"[DEBUG][Cargo] Tentando preencher...")
            ok = await set_text_field_by_id(page, "Cargo", cargo, "Cargo")
            if ok:
                update_field_status("cargo", "Cargo", cargo)
            await _settle(page, "#Cargo")
        else:
            log(f"[DEBUG][Cargo] Pulado - valida√ß√£o falhou")
    except Exception as e:
        log(f"[Cargo][WARN] {e}")
    
    # 17.6.6) Empregador
    try:
        empregador = data.get("empregador", "")
        if empregador and isinstance(empregador, str) and empregador.strip():
            ok = await set_text_field_by_id(page, "Empregador", empregador, "Empregador")
            if ok:
                update_field_status("empregador", "Empregador", empregador)
            await _settle(page, "#Empregador")
    except Exception as e:
        log(f"[Empregador][WARN] {e}")
    
    # 17.6.7) Local de Presta√ß√£o de Servi√ßo
    try:
        local_trabalho = data.get("local_trabalho", "")
        if local_trabalho and isinstance(local_trabalho, str) and local_trabalho.strip():
            ok = await set_text_field_by_id(page, "LocalPrestacaoServico", local_trabalho, "Local de Presta√ß√£o de Servi√ßo")
            if ok:
                update_field_status("local_trabalho", "Local de Presta√ß√£o de Servi√ßo", local_trabalho)
            await _settle(page, "#LocalPrestacaoServico")
    except Exception as e:
        log(f"[Local Trabalho][WARN] {e}")
    
    # 17.6.8) PIS
    try:
        pis = data.get("pis", "")
        if pis and isinstance(pis, str) and pis.strip():
            ok = await set_text_field_by_id(page, "Pis", pis, "PIS")
            if ok:
                update_field_status("pis", "PIS", pis)
            await _settle(page, "#Pis")
    except Exception as e:
        log(f"[PIS][WARN] {e}")
    
    # 17.6.9) CTPS
    try:
        ctps = data.get("ctps", "")
        if ctps and isinstance(ctps, str) and ctps.strip():
            ok = await set_text_field_by_id(page, "Cts", ctps, "CTPS")
            if ok:
                update_field_status("ctps", "CTPS", ctps)
            await _settle(page, "#Cts")
    except Exception as e:
        log(f"[CTPS][WARN] {e}")

    # 17.7) Valor da Causa - COM FALLBACK COMPLETO
    try:
        # üîß NOVO: Sistema universal de fallback (data ‚Üí PDF extraction)
        valor = extract_field_with_full_fallback(
            field_name="valor_causa",
            data=data,
            pdf_text=pdf_text,
            pdf_extractor=extract_valor_causa_from_pdf,
            data_keys=["valor_causa", "valor"]
        )
        
        # Fallback final: valor padr√£o do ambiente
        if not valor:
            valor = os.getenv("RPA_VALOR_CAUSA_DEFAULT", "1.000,00")
            log(f"[Valor Causa] Usando valor padr√£o do ambiente: {valor}")
        
        if valor:
            ok_vc = await set_valor_causa_any(page, valor)
            if not ok_vc:
                await set_input_by_id(page, VALOR_CAUSA_INPUT_ID, valor, "Valor da Causa")
            await _settle(page, "input:valor_causa")
            update_field_status("valor_causa", "Valor da Causa", valor)
    except Exception as e:
        log(f"[Valor Causa][WARN] {e}")

    # 17.8) Cadastro de Primeira Audi√™ncia (condicional)
    try:
        cadastrar_audiencia = data.get("cadastrar_primeira_audiencia", False)
        audiencia_inicial = data.get("audiencia_inicial", "")
        
        # Debug: Log dos valores recebidos
        log(f"[AUDI√äNCIA][DEBUG] cadastrar_primeira_audiencia={cadastrar_audiencia} (type: {type(cadastrar_audiencia).__name__})")
        log(f"[AUDI√äNCIA][DEBUG] audiencia_inicial='{audiencia_inicial}' (type: {type(audiencia_inicial).__name__})")
        
        if cadastrar_audiencia and audiencia_inicial:
            update_status("cadastrando_audiencia", "Cadastrando primeira audi√™ncia...", process_id=process_id)
            log(f"[AUDI√äNCIA] Cadastrando primeira audi√™ncia: {audiencia_inicial}")
            
            # Marcar r√°dio "Sim" para "Deseja cadastrar a primeira Audi√™ncia?"
            # IMPORTANTE: O formul√°rio usa iCheck, que esconde o input real (opacity: 0)
            # Precisamos clicar no label ou for√ßar click no input
            try:
                # Estrat√©gia 1: Tentar clicar no label que cont√©m o input "Sim"
                label_selector = 'label.radio-inline:has(input[name="IsDesejaCadastrarPrimeiraAudiencia"][value="True"])'
                
                try:
                    await page.wait_for_selector(label_selector, state="visible", timeout=5000)
                    await page.locator(label_selector).click(timeout=3000)
                    log("[AUDI√äNCIA] R√°dio 'Sim' marcado via label")
                except Exception as e_label:
                    # Estrat√©gia 2: For√ßar click no input invis√≠vel do iCheck
                    log(f"[AUDI√äNCIA][WARN] Falha ao clicar no label: {e_label}, tentando force click...")
                    input_selector = 'input[name="IsDesejaCadastrarPrimeiraAudiencia"][value="True"]'
                    await page.locator(input_selector).click(force=True, timeout=3000)
                    log("[AUDI√äNCIA] R√°dio 'Sim' marcado via force click")
                
                update_field_status("cadastrar_audiencia", "Deseja cadastrar primeira audi√™ncia?", "Sim")
                
                # Aguardar campos de data e hora aparecerem (aumentado para 1.5 segundos)
                await page.wait_for_timeout(1500)  # 1.5s para garantir que iCheck processe e mostre os campos
                
                # Extrair data e hora da audi√™ncia inicial (formato esperado: "15/02/2025 √†s 10:00h" ou "15/02/2025 10:00")
                import re
                audiencia_str = str(audiencia_inicial)
                
                # Regex para extrair data (DD/MM/YYYY)
                match_data = re.search(r'(\d{1,2}[/-]\d{1,2}[/-]\d{4})', audiencia_str)
                data_audiencia = match_data.group(1).replace('-', '/') if match_data else ""
                
                # Regex para extrair hora (HH:MM)
                match_hora = re.search(r'(\d{1,2}):(\d{2})', audiencia_str)
                hora_audiencia = f"{match_hora.group(1)}:{match_hora.group(2)}" if match_hora else ""
                
                # Preencher campo Data da Audi√™ncia usando calend√°rio
                if data_audiencia:
                    data_input_id = "DataPrimeiraAudiencia"
                    
                    # Extrair dia, m√™s e ano da data (formato DD/MM/YYYY)
                    parts = data_audiencia.split('/')
                    if len(parts) == 3:
                        dia = int(parts[0])
                        mes = int(parts[1])
                        ano = int(parts[2])
                        
                        # Clicar no campo para abrir o calend√°rio
                        await page.locator(f"#{data_input_id}").click(timeout=3000)
                        log(f"[AUDI√äNCIA] Calend√°rio aberto para data: {data_audiencia}")
                        await page.wait_for_timeout(500)  # Aguardar calend√°rio aparecer
                        
                        # Mapear n√∫mero do m√™s para nome em portugu√™s
                        meses_pt = {
                            1: "Janeiro", 2: "Fevereiro", 3: "Mar√ßo", 4: "Abril",
                            5: "Maio", 6: "Junho", 7: "Julho", 8: "Agosto",
                            9: "Setembro", 10: "Outubro", 11: "Novembro", 12: "Dezembro"
                        }
                        mes_nome = meses_pt.get(mes, "")
                        
                        # Tentar navegar at√© o m√™s/ano correto no calend√°rio
                        # Verifica se o cabe√ßalho do calend√°rio mostra o m√™s/ano correto
                        max_tentativas = 12
                        for tentativa in range(max_tentativas):
                            try:
                                # Verifica o m√™s/ano atual mostrado no calend√°rio
                                # O formato pode ser "Novembro 2025", "Dezembro 2025", etc.
                                calendario_header = await page.locator(".datepicker-days th.datepicker-switch").text_content(timeout=2000)
                                
                                if calendario_header and mes_nome in calendario_header and str(ano) in calendario_header:
                                    # M√™s/ano correto, podemos clicar no dia
                                    log(f"[AUDI√äNCIA] Calend√°rio no m√™s correto: {calendario_header}")
                                    break
                                else:
                                    # Precisa navegar - clica na seta direita para avan√ßar m√™s
                                    await page.locator(".datepicker-days th.next").click(timeout=2000)
                                    await page.wait_for_timeout(200)
                            except Exception:
                                break  # Se falhar, tenta clicar no dia mesmo assim
                        
                        # Clicar no dia espec√≠fico no calend√°rio
                        # O calend√°rio usa <td class="day"> com o n√∫mero do dia
                        dia_selector = f".datepicker-days td.day:has-text(\"{dia}\"):not(.old):not(.new)"
                        try:
                            await page.locator(dia_selector).first.click(timeout=3000)
                            log(f"[AUDI√äNCIA] Data selecionada no calend√°rio: {dia}/{mes}/{ano}")
                            update_field_status("data_audiencia", "Data da Audi√™ncia", data_audiencia)
                            await page.wait_for_timeout(300)
                        except Exception as e_dia:
                            log(f"[AUDI√äNCIA][WARN] Erro ao clicar no dia {dia}: {e_dia}")
                            # Fallback: tentar preencher diretamente o campo
                            await page.locator(f"#{data_input_id}").fill(data_audiencia)
                            await page.locator(f"#{data_input_id}").press("Tab")
                            log(f"[AUDI√äNCIA] Data preenchida via fallback: {data_audiencia}")
                            update_field_status("data_audiencia", "Data da Audi√™ncia", data_audiencia)
                    else:
                        log(f"[AUDI√äNCIA][WARN] Formato de data inv√°lido: {data_audiencia}")
                        update_field_status("data_audiencia", "Data da Audi√™ncia", f"ERRO: formato inv√°lido {data_audiencia}")
                
                # Preencher campo Hora da Audi√™ncia
                if hora_audiencia:
                    hora_input_id = "HoraPrimeiraAudiencia"
                    await page.locator(f"#{hora_input_id}").click(timeout=3000)
                    await page.locator(f"#{hora_input_id}").fill(hora_audiencia)
                    log(f"[AUDI√äNCIA] Hora preenchida: {hora_audiencia}")
                    update_field_status("hora_audiencia", "Hora da Audi√™ncia", hora_audiencia)
                    
                    await page.wait_for_timeout(200)
                
                # ‚úÖ Preencher Link da Audi√™ncia (Zoom/Meet/Teams)
                link_audiencia_val = data.get("link_audiencia", "")
                if link_audiencia_val:
                    try:
                        link_input_id = "LinkAudiencia"
                        await page.locator(f"#{link_input_id}").click(timeout=3000)
                        await page.locator(f"#{link_input_id}").fill(link_audiencia_val)
                        log(f"[AUDI√äNCIA] Link preenchido: {link_audiencia_val[:60]}...")
                        update_field_status("link_audiencia", "Link da Audi√™ncia", "‚úì")
                        await page.wait_for_timeout(200)
                    except Exception as e_link:
                        log(f"[AUDI√äNCIA][WARN] Erro ao preencher link: {e_link}")
                
                # ‚úÖ Selecionar SubTipo da Audi√™ncia (dropdown) - OBRIGAT√ìRIO no eLaw
                subtipo_audiencia_val = data.get("subtipo_audiencia", "")
                
                # Se n√£o tiver subtipo extra√≠do, usar valor default (mais comum em processos trabalhistas)
                if not subtipo_audiencia_val:
                    subtipo_audiencia_val = "Audi√™ncia Inicial Una (IU)"
                    log(f"[AUDI√äNCIA] Subtipo n√£o extra√≠do do PDF - usando default: {subtipo_audiencia_val}")
                
                try:
                    await select_from_bootstrap_dropdown(
                        page,
                        select_id="SubTipoPrimeiraAudienciaId",
                        search_text=subtipo_audiencia_val,
                        field_label="SubTipo da Audi√™ncia"
                    )
                    log(f"[AUDI√äNCIA] Subtipo selecionado: {subtipo_audiencia_val}")
                    update_field_status("subtipo_audiencia", "SubTipo da Audi√™ncia", subtipo_audiencia_val)
                except Exception as e_subtipo:
                    log(f"[AUDI√äNCIA][WARN] Erro ao selecionar subtipo: {e_subtipo}")
                
                # ‚úÖ Selecionar Envolvidos da Audi√™ncia (dropdown)
                envolvido_audiencia_val = data.get("envolvido_audiencia", "")
                if envolvido_audiencia_val:
                    try:
                        await select_from_bootstrap_dropdown(
                            page,
                            select_id="EnvolvidoPrimeiraAudienciaId",
                            search_text=envolvido_audiencia_val,
                            field_label="Envolvidos da Audi√™ncia"
                        )
                        log(f"[AUDI√äNCIA] Envolvidos selecionado: {envolvido_audiencia_val}")
                        update_field_status("envolvido_audiencia", "Envolvidos da Audi√™ncia", envolvido_audiencia_val)
                    except Exception as e_envolvido:
                        log(f"[AUDI√äNCIA][WARN] Erro ao selecionar envolvido: {e_envolvido}")
                
                log("[AUDI√äNCIA] Primeira audi√™ncia cadastrada com sucesso")
                
            except Exception as e_radio:
                log(f"[AUDI√äNCIA][WARN] Erro ao marcar r√°dio ou preencher campos: {e_radio}")
                update_field_status("cadastrar_audiencia", "Deseja cadastrar primeira audi√™ncia?", f"ERRO: {e_radio}")
        else:
            # Se n√£o h√° audi√™ncia para cadastrar, deixar "N√£o" marcado (padr√£o)
            log("[AUDI√äNCIA] Sem audi√™ncia inicial para cadastrar - mantendo 'N√£o' marcado")
            
    except Exception as e:
        log(f"[AUDI√äNCIA][WARN] {e}")

    # 18) Estrat√©gia (opcional)
    try:
        if await page.locator(f"button.btn.dropdown-toggle[data-id='{ESTRATEGIA_SELECT_ID}']").count() > 0:
            btn, cont = await _open_bs_and_get_container(page, ESTRATEGIA_SELECT_ID)
            est_opts = _clean_choices(await _collect_options_from_container(cont)) if cont else []
            if btn:
                try:
                    await btn.press("Escape")
                except Exception:
                    pass
            est_txt = (data.get("estrategia") or "")
            if not est_txt and pdf_text:
                m = re.search(r"(?i)\bestrat√©gia\b[:\-‚Äì]\s*([^\n]{3,80})", pdf_text)
                if m:
                    est_txt = m.group(1)
            if est_txt:
                await set_select_fuzzy_any(page, ESTRATEGIA_SELECT_ID, est_txt, fallbacks=est_opts[:6] if est_opts else None)
                await _settle(page, "select:estrategia")
    except Exception as e:
        log(f"[Estrat√©gia][WARN] {e}")

    # snapshot parcial
    try:
        png = SCREENSHOT_DIR / "form_parcial_preenchido.png"
        await page.screenshot(path=str(png), full_page=True)
        log(f"[SHOT] parcial: {png}")
    except Exception:
        pass

    # sanity final: CNJ ligado + presente
    try:
        await ensure_cnj_flag_on(page)
        await ensure_cnj_still_present(page, cnj)
    except Exception:
        pass

    # Screenshot ANTES de salvar para preservar formul√°rio preenchido
    screenshot_before_path = None
    try:
        update_status("capturando_screenshot_before", "Capturando screenshot do formul√°rio preenchido...", process_id=process_id)
        if process_id:
            # üîß 2025-11-27: Aguardar p√°gina estabilizar ANTES de capturar screenshot
            try:
                await page.wait_for_function("document.readyState === 'complete'", timeout=5000)
                await page.wait_for_timeout(500)  # Extra buffer para elementos visuais
            except Exception:
                pass  # Continuar mesmo se timeout
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            screenshot_filename = f"process_{process_id}_{timestamp}_before.png"
            
            # Salvar em static/rpa_screenshots para servir via Flask
            screenshot_static_dir = Path("static") / "rpa_screenshots"
            screenshot_static_dir.mkdir(parents=True, exist_ok=True)
            screenshot_full_path = screenshot_static_dir / screenshot_filename
            
            await page.screenshot(path=str(screenshot_full_path), full_page=True)
            log(f"[SCREENSHOT BEFORE] Formul√°rio preenchido salvo em: {screenshot_full_path}")
            send_screenshot_to_monitor(screenshot_full_path, region="FORMULARIO_ANTES")
            
            # Enviar screenshot diretamente via rpa_log
            if RPA_LOG_AVAILABLE and rpa_log:
                try:
                    rpa_log.screenshot(
                        filename=f"screen_{int(time.time())}.png",
                        regiao="screenshot_periodica",
                    )
                    log(f"[SCREENSHOT BEFORE] Screenshot enviado via rpa_log.screenshot()")
                except Exception as e:
                    log(f"[SCREENSHOT BEFORE][WARN] Erro ao enviar via rpa_log: {e}")
            
            # Salvar caminho no banco de dados (caminho relativo a static/)
            if not flask_app:
                error_msg = "[SCREENSHOT BEFORE] ‚ùå CRITICAL: flask_app √© None! Caller deve configurar rpa.flask_app ANTES de executar RPA!"
                log(error_msg)
                raise RuntimeError(error_msg)
            
            try:
                from models import Process, db
                with flask_app.app_context():
                    proc = Process.query.get(process_id)
                    if proc:
                        # ‚úÖ FIX: Salvar APENAS o nome do arquivo. O prefixo √© adicionado na rota/template.
                        proc.elaw_screenshot_before_path = screenshot_filename
                        proc.elaw_screenshot_path = screenshot_filename  # backwards compat
                        log(f"[SCREENSHOT BEFORE] ANTES de commit: {proc.elaw_screenshot_before_path}")
                        db.session.commit()
                        log(f"[SCREENSHOT BEFORE] ‚úÖ Caminho commitado no banco: {proc.elaw_screenshot_before_path}")
                        screenshot_before_path = proc.elaw_screenshot_before_path
                    else:
                        log(f"[SCREENSHOT BEFORE][ERRO] Processo #{process_id} n√£o encontrado no banco!")
            except Exception as e:
                log(f"[SCREENSHOT BEFORE][ERRO] Erro ao salvar caminho no banco: {e}")
            
            update_status("screenshot_before_captured", f"Screenshot do formul√°rio preenchido salvo ‚úì", process_id=process_id)
    except Exception as e:
        log(f"[SCREENSHOT BEFORE][WARN] Erro ao capturar screenshot: {e}")

    if RPA_SKIP_SAVE:
        try:
            png = _get_screenshot_path("form_parcial_preenchido.png", process_id=process_id)  # 2025-11-21: Corrigido
            await page.screenshot(path=str(png), full_page=True)
            log(f"[SHOT] parcial: {png}")
        except Exception:
            pass
        log(f"[FLOW] SKIP SAVE (RPA_SKIP_SAVE=1) ‚Äî somente pr√©-visualiza√ß√£o.")
        if RPA_PREVIEW_SECONDS > 0:
            await asyncio.sleep(RPA_PREVIEW_SECONDS)
        return
    else:
        # Clicar em Salvar e capturar resultado
        update_status("salvando_processo", "Clicando em Salvar...", process_id=process_id)
        save_result = await click_salvar_and_wait(page, cnj_expected=cnj)
        
        # ‚úÖ SCREENSHOT IMEDIATO: Capturar toast ANTES de esperar (toasts somem em 3-5s!)
        # Screenshot DEPOIS de salvar (sucesso ou erro)
        screenshot_after_path = None
        try:
            if process_id:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                screenshot_filename = f"process_{process_id}_{timestamp}_after.png"
                
                screenshot_static_dir = Path("static") / "rpa_screenshots"
                screenshot_static_dir.mkdir(parents=True, exist_ok=True)
                screenshot_full_path = screenshot_static_dir / screenshot_filename
                
                await page.screenshot(path=str(screenshot_full_path), full_page=True)
                
                status_label = "SUCESSO" if save_result['success'] else "ERRO"
                log(f"[SCREENSHOT AFTER] Screenshot p√≥s-save ({status_label}) salvo em: {screenshot_full_path}")
                send_screenshot_to_monitor(screenshot_full_path, region=f"FORMULARIO_DEPOIS_{status_label}")
                
                # Enviar screenshot diretamente via rpa_log
                if RPA_LOG_AVAILABLE and rpa_log:
                    try:
                        rpa_log.screenshot(
                            filename=f"screen_{int(time.time())}.png",
                            regiao="screenshot_periodica",
                        )
                        log(f"[SCREENSHOT AFTER] Screenshot enviado via rpa_log.screenshot()")
                    except Exception as e:
                        log(f"[SCREENSHOT AFTER][WARN] Erro ao enviar via rpa_log: {e}")
                
                # Salvar caminho no banco de dados
                if not flask_app:
                    error_msg = "[SCREENSHOT AFTER] ‚ùå CRITICAL: flask_app √© None! Caller deve configurar rpa.flask_app ANTES de executar RPA!"
                    log(error_msg)
                    raise RuntimeError(error_msg)
                
                try:
                    from models import Process, db
                    with flask_app.app_context():
                        proc = Process.query.get(process_id)
                        if proc:
                            # ‚úÖ FIX: Salvar APENAS o nome do arquivo.
                            proc.elaw_screenshot_after_path = screenshot_filename
                            
                            # ‚ö†Ô∏è N√ÉO definir 'success' aqui - ainda falta inserir reclamadas, marca√ß√µes e pedidos
                            # O status 'success' ser√° definido no FINAL do fluxo completo
                            if proc.elaw_status not in ('success', 'error'):
                                if save_result['success']:
                                    # Status intermedi√°rio: formul√°rio salvo, mas fluxo ainda n√£o conclu√≠do
                                    proc.elaw_status = 'processing'  # Status intermedi√°rio
                                    proc.status = 'processing'
                                    proc.elaw_filled_at = datetime.now()
                                    proc.elaw_error_message = None
                                    
                                    # ‚úÖ M√öLTIPLAS RECLAMADAS: Salvar URL de detalhes do processo
                                    # Esta URL √© necess√°ria para o fluxo de adicionar reclamadas extras
                                    url_after = save_result.get('url_after', '')
                                    if url_after and ('detail' in url_after.lower() or 'id=' in url_after.lower()):
                                        proc.elaw_detail_url = url_after
                                        log(f"[RECLAMADAS] URL de detalhes salva: {url_after}")
                                else:
                                    proc.elaw_status = 'error'
                                    proc.status = 'error'
                                    proc.elaw_error_message = save_result['message']
                                log(f"[STATUS] Processo marcado como: {proc.elaw_status} / {proc.status}")
                            else:
                                log(f"[STATUS] Processo j√° tinha status: {proc.elaw_status} - mantendo")
                            
                            log(f"[SCREENSHOT AFTER] ANTES de commit: {proc.elaw_screenshot_after_path}")
                            db.session.commit()
                            log(f"[SCREENSHOT AFTER] ‚úÖ Caminho commitado no banco: {proc.elaw_screenshot_after_path}")
                            screenshot_after_path = proc.elaw_screenshot_after_path
                        else:
                            log(f"[SCREENSHOT AFTER][ERRO] Processo #{process_id} n√£o encontrado no banco!")
                except Exception as e:
                    log(f"[SCREENSHOT AFTER][ERRO] Erro ao salvar caminho no banco: {e}")
                
                update_status("screenshot_after_captured", f"Screenshot p√≥s-save ({status_label}, process_id=process_id) capturado ‚úì")
        except Exception as e:
            log(f"[SCREENSHOT AFTER][WARN] Erro ao capturar screenshot: {e}")
        
        # Log final do resultado
        if save_result['success']:
            log(f"[FLOW] ‚úÖ Formul√°rio salvo com sucesso! URL: {save_result['url_after']}")
            update_status("processo_salvo", f"‚úÖ Processo salvo com sucesso no eLaw!", process_id=process_id)
            
            # ‚úÖ M√öLTIPLAS RECLAMADAS: Verificar se h√° reclamadas extras para adicionar
            reclamadas = data.get("reclamadas", [])
            # üîß DEBUG 2025-12-02: Log detalhado para verificar reclamadas
            log(f"[RECLAMADAS][DEBUG] process_id={process_id}")
            log(f"[RECLAMADAS][DEBUG] Total reclamadas: {len(reclamadas)}")
            for idx, rec in enumerate(reclamadas):
                log(f"[RECLAMADAS][DEBUG]   [{idx}] nome={rec.get('nome', 'N/A')[:50]}, posicao={rec.get('posicao', 'N/A')}")
            if len(reclamadas) > 1:
                log(f"[RECLAMADAS] Detectadas {len(reclamadas)} reclamadas - iniciando inser√ß√£o de extras")
                
                # Verificar se temos URL de detalhes dispon√≠vel
                has_detail_url = False
                current_url = page.url
                
                # Caso 1: J√° est√° na tela de detalhes
                if 'detail' in current_url.lower() or 'id=' in current_url.lower():
                    log("[RECLAMADAS] J√° na tela de detalhes")
                    has_detail_url = True
                else:
                    # Caso 2: Temos URL de detalhes no resultado do save (via url_after ou modal)
                    url_after = save_result.get('url_after', '')
                    detail_url_from_modal = save_result.get('detail_url', '')
                    
                    # Priorizar URL capturada do modal "j√° existe" (mais confi√°vel)
                    if detail_url_from_modal:
                        log(f"[RECLAMADAS] Usando URL de detalhes do modal: {detail_url_from_modal}")
                        await page.goto(detail_url_from_modal, wait_until="load", timeout=NAV_TIMEOUT_MS)
                        await short_sleep_ms(1000)
                        has_detail_url = True
                    elif url_after and ('detail' in url_after.lower() or 'id=' in url_after.lower()):
                        log(f"[RECLAMADAS] Navegando para tela de detalhes: {url_after}")
                        await page.goto(url_after, wait_until="load", timeout=NAV_TIMEOUT_MS)
                        await short_sleep_ms(1000)
                        has_detail_url = True
                    else:
                        # Caso 3: FALLBACK - Processo j√° existia mas n√£o temos URL
                        # Buscar via Relat√≥rio de Andamentos
                        log("[RECLAMADAS][FALLBACK] URL de detalhes n√£o dispon√≠vel - acionando busca via Relat√≥rio")
                        fallback_ok = await ensure_elaw_detail_url_via_relatorio(page, process_id, data)
                        if fallback_ok:
                            log("[RECLAMADAS][FALLBACK] ‚úÖ URL encontrada via relat√≥rio - continuando com reclamadas extras")
                            has_detail_url = True
                        else:
                            log("[RECLAMADAS][FALLBACK] ‚ùå Falha ao obter URL de detalhes - pulando inser√ß√£o de reclamadas extras")
                
                # S√≥ tenta adicionar reclamadas extras se temos a URL de detalhes
                if has_detail_url:
                    try:
                        await handle_extra_reclamadas(page, data, process_id)
                    except Exception as e:
                        log(f"[RECLAMADAS][WARN] Erro ao adicionar reclamadas extras (processo principal OK): {e}")
                else:
                    log("[RECLAMADAS][SKIP] Sem URL de detalhes - reclamadas extras n√£o ser√£o adicionadas")
            else:
                log("[RECLAMADAS] Apenas 1 reclamada - nenhuma extra para adicionar")
            
            # ‚úÖ NOVO: Verificar e processar pedidos para TODOS os processos (com ou sem reclamadas extras)
            # 2025-12-03: Corrigido para tratar pedidos_json como string JSON e parsear corretamente
            raw_pedidos_json = data.get("pedidos_json")
            raw_pedidos = data.get("pedidos", [])
            
            # Se pedidos_json √© uma string, parsear
            if isinstance(raw_pedidos_json, str) and raw_pedidos_json.strip():
                try:
                    import json
                    parsed_pedidos = json.loads(raw_pedidos_json)
                    if isinstance(parsed_pedidos, list):
                        pedidos = parsed_pedidos
                    else:
                        log(f"[PEDIDOS][WARN] pedidos_json parseado n√£o √© lista: {type(parsed_pedidos)}")
                        pedidos = raw_pedidos if isinstance(raw_pedidos, list) else []
                except Exception as e:
                    log(f"[PEDIDOS][WARN] Erro ao parsear pedidos_json: {e}")
                    pedidos = raw_pedidos if isinstance(raw_pedidos, list) else []
            elif isinstance(raw_pedidos_json, list):
                pedidos = raw_pedidos_json
            elif isinstance(raw_pedidos, list):
                pedidos = raw_pedidos
            else:
                pedidos = []
            
            # üîß DEBUG 2025-12-03: Log detalhado para identificar por que pedidos n√£o est√£o sendo inseridos
            log(f"[PEDIDOS][DEBUG] process_id={process_id}")
            log(f"[PEDIDOS][DEBUG] raw_pedidos_json type={type(raw_pedidos_json).__name__}, raw_pedidos type={type(raw_pedidos).__name__}")
            log(f"[PEDIDOS][DEBUG] pedidos final: {len(pedidos)} itens")
            if pedidos:
                log(f"[PEDIDOS] Detectados {len(pedidos)} pedidos para inserir")
                
                # Garantir que estamos na tela de detalhes antes de inserir pedidos
                current_url = page.url
                if 'detail' not in current_url.lower() and 'id=' not in current_url.lower():
                    # Precisamos navegar para a tela de detalhes
                    log("[PEDIDOS] N√£o est√° na tela de detalhes - verificando URL...")
                    
                    # Tentar obter URL de detalhes do banco
                    detail_url = None
                    if flask_app:
                        from models import Process, db
                        with flask_app.app_context():
                            proc = Process.query.get(process_id)
                            if proc and proc.elaw_detail_url:
                                detail_url = proc.elaw_detail_url
                    
                    if detail_url:
                        log(f"[PEDIDOS] Navegando para tela de detalhes: {detail_url}")
                        await page.goto(detail_url, wait_until="load", timeout=NAV_TIMEOUT_MS)
                        await short_sleep_ms(1000)
                    else:
                        # Fallback: buscar via relat√≥rio
                        log("[PEDIDOS][FALLBACK] URL de detalhes n√£o dispon√≠vel - acionando busca via Relat√≥rio")
                        fallback_ok = await ensure_elaw_detail_url_via_relatorio(page, process_id, data)
                        if not fallback_ok:
                            log("[PEDIDOS][SKIP] N√£o foi poss√≠vel obter URL de detalhes - pulando pedidos")
                            pedidos = []  # Limpar para pular o fluxo de pedidos
                
                # Processar marca√ß√µes e pedidos se estamos na tela de detalhes
                if pedidos:
                    # 1. Editar marca√ß√µes baseado no cliente/reclamada
                    try:
                        log("[PEDIDOS][FLOW] Iniciando fluxo de marca√ß√µes...")
                        await handle_marcacoes(page, data, process_id)
                    except Exception as e:
                        log(f"[PEDIDOS][FLOW][WARN] Erro ao editar marca√ß√µes: {e}")
                    
                    # 2. Adicionar pedidos
                    try:
                        log("[PEDIDOS][FLOW] Iniciando inser√ß√£o de pedidos...")
                        await handle_novo_pedido(page, data, process_id)
                    except Exception as e:
                        log(f"[PEDIDOS][FLOW][WARN] Erro ao adicionar pedidos: {e}")
            else:
                log("[PEDIDOS] Nenhum pedido detectado para este processo")
            
            # Navegar de volta ao dashboard
            try:
                dashboard_url = BASE_URL.rstrip("/") + "/Home/Index"
                log(f"[FLOW] Navegando de volta ao dashboard: {dashboard_url}")
                update_status("voltando_dashboard", "Retornando ao dashboard...", process_id=process_id)
                await page.goto(dashboard_url, wait_until="domcontentloaded", timeout=30000)  # 30s - tolerante a navega√ß√£o lenta
                await asyncio.sleep(0.5)  # Otimizado: 1s‚Üí0.5s (economia 0.5s)
                log(f"[FLOW] ‚úÖ Retornado ao dashboard com sucesso")
                update_status("dashboard_ok", "‚úÖ Retornado ao dashboard", process_id=process_id)
            except Exception as e:
                log(f"[FLOW][WARN] Erro ao retornar ao dashboard: {e}")
        else:
            log(f"[FLOW] ‚ùå Erro ao salvar: {save_result['message']}")
            update_status("erro_ao_salvar", f"‚ùå Erro: {save_result['message']}", status="error", process_id=process_id)


# ============================================================================
# FALLBACK: Buscar URL de detalhes via Relat√≥rio de Andamentos
# ============================================================================

async def ensure_elaw_detail_url_via_relatorio(page, process_id: int, data: dict) -> bool:
    """
    Fallback para buscar a URL de detalhes do processo via Relat√≥rio de Andamentos.
    
    Usado quando:
    - O eLaw mostra modal "processo j√° existe"
    - Mas n√£o temos a URL de detalhes gravada no banco
    
    Args:
        page: Playwright Page object j√° logado no eLaw
        process_id: ID do processo no banco de dados
        data: Dicion√°rio com dados extra√≠dos do PDF (para pegar o n√∫mero do processo)
        
    Returns:
        bool: True se a URL foi encontrada e salva com sucesso
    """
    log(f"[FALLBACK_URL][INICIO] process_id={process_id}")
    
    # 1. Verificar se j√° existe URL gravada
    if flask_app:
        from models import Process, db
        with flask_app.app_context():
            proc = Process.query.get(process_id)
            if proc and proc.elaw_detail_url:
                log(f"[FALLBACK_URL][SKIP] URL j√° existe: {proc.elaw_detail_url}")
                return True
    
    # 2. Determinar o n√∫mero do processo a pesquisar
    numero_processo = extract_cnj_from_anywhere(data)
    if not numero_processo:
        log("[FALLBACK_URL][SEM_NUMERO] N√∫mero do processo n√£o encontrado no data")
        return False
    
    log(f"[FALLBACK_URL][NUMERO] Buscando processo: {numero_processo}")
    update_status("fallback_url", f"Buscando detalhes do processo {numero_processo}...", process_id=process_id)
    
    try:
        # 3. Navegar para a tela de Relat√≥rio de Andamentos
        relatorio_url = BASE_URL.rstrip("/") + "/processo/ListRelatorio?cache=false"
        log(f"[FALLBACK_URL][NAV] Navegando para: {relatorio_url}")
        await page.goto(relatorio_url, wait_until="load", timeout=NAV_TIMEOUT_MS)
        await short_sleep_ms(1000)
        
        # Verificar se chegou na p√°gina correta
        title = await page.title()
        if "Relat√≥rio" not in title and "Relatorio" not in title:
            log(f"[FALLBACK_URL][WARN] T√≠tulo inesperado: {title}")
        
        # 4. Preencher o filtro "N√∫mero Processo"
        log(f"[FALLBACK_URL][FILTER] Preenchendo filtro com: {numero_processo}")
        
        # Lista de seletores poss√≠veis para o campo de n√∫mero do processo
        numero_selectors = [
            '#Filters_Protocolo',
            '#Filters_NumeroProcesso', 
            'input[name="Filters.Protocolo"]',
            'input[name="Filters.NumeroProcesso"]',
            'input[placeholder*="N"]',  # Campo com placeholder contendo "N" (N√∫mero)
        ]
        
        # Tentar buscar com n√∫mero completo e tamb√©m s√≥ com d√≠gitos
        numeros_para_tentar = [
            numero_processo,  # Formato completo: 0101569-94.2025.5.01.0202
            re.sub(r'\D', '', numero_processo)  # S√≥ d√≠gitos: 01015699420255010202
        ]
        
        for tentativa_numero in numeros_para_tentar:
            log(f"[FALLBACK_URL][TENTATIVA] Buscando com: {tentativa_numero}")
            
            filter_filled = False
            for sel in numero_selectors:
                try:
                    elem = page.locator(sel).first
                    if await elem.is_visible(timeout=1000):
                        await elem.clear()
                        await elem.fill(tentativa_numero)
                        await short_sleep_ms(300)
                        filter_filled = True
                        log(f"[FALLBACK_URL][FILTER] Preenchido via: {sel}")
                        break
                except Exception:
                    continue
            
            if not filter_filled:
                log("[FALLBACK_URL][ERRO] N√£o encontrou campo de filtro para n√∫mero do processo")
                continue
            
            # 5. Clicar no bot√£o "Localizar"
            log("[FALLBACK_URL][CLICK] Clicando em Localizar...")
            
            # Lista de seletores poss√≠veis para o bot√£o
            button_selectors = [
                '#buttonSubmit',
                '#btnSearch',
                'button[type="submit"]',
                'input[type="submit"]',
                'button:has-text("Localizar")',
                'button:has-text("Pesquisar")',
                'button:has-text("Buscar")',
            ]
            
            button_clicked = False
            for sel in button_selectors:
                try:
                    btn = page.locator(sel).first
                    if await btn.is_visible(timeout=1000):
                        await btn.click()
                        button_clicked = True
                        log(f"[FALLBACK_URL][CLICK] Clicado via: {sel}")
                        break
                except Exception:
                    continue
            
            if not button_clicked:
                log("[FALLBACK_URL][ERRO] N√£o encontrou bot√£o de Localizar")
                continue
            
            # 6. Aguardar o carregamento dos resultados (AJAX)
            log("[FALLBACK_URL][WAIT] Aguardando resultados...")
            await short_sleep_ms(2000)  # Esperar AJAX carregar
            
            try:
                await page.wait_for_selector('#processoRelatorioList', state='visible', timeout=20000)  # 20s - tolerante a tabela lenta
            except Exception:
                log("[FALLBACK_URL][ERRO] Container de resultados n√£o ficou vis√≠vel")
                continue
            
            # 7. Verificar se h√° resultados
            try:
                html = await page.inner_text('#processoRelatorioList')
                if "Nenhum registro localizado" in html:
                    log(f"[FALLBACK_URL][NENHUM_REGISTRO] N√£o encontrado com: {tentativa_numero}")
                    continue  # Tentar pr√≥ximo formato
                log("[FALLBACK_URL][TABELA_OK] Resultados encontrados")
                break  # Sucesso! Sair do loop
            except Exception as e:
                log(f"[FALLBACK_URL][ERRO] Falha ao ler resultados: {e}")
                continue
        else:
            # Nenhuma tentativa funcionou
            log(f"[FALLBACK_URL][NENHUM_REGISTRO] Processo {numero_processo} n√£o encontrado no relat√≥rio (nenhum formato)")
            return False
        
        # 8. Encontrar o link do n√∫mero do processo e clicar
        log(f"[FALLBACK_URL][CLICK_NUMERO] Buscando link para: {numero_processo}")
        numero_digits = re.sub(r'\D', '', numero_processo)
        
        try:
            # Tentar m√∫ltiplas estrat√©gias para encontrar o link
            link_found = False
            
            # Estrat√©gia 1: Buscar link na primeira coluna da tabela (td:first-child a)
            try:
                log("[FALLBACK_URL][CLICK_NUMERO] Tentando Estrat√©gia 1: primeira coluna da tabela")
                first_col_links = page.locator('#processoRelatorioList tbody tr td:first-child a')
                count = await first_col_links.count()
                log(f"[FALLBACK_URL][CLICK_NUMERO] Encontrados {count} links na primeira coluna")
                
                for i in range(min(count, 20)):
                    link = first_col_links.nth(i)
                    text = await link.text_content()
                    if text:
                        text_digits = re.sub(r'\D', '', text)
                        if text_digits == numero_digits:
                            log(f"[FALLBACK_URL][CLICK_NUMERO] Match na coluna 1: '{text}'")
                            await link.click()
                            link_found = True
                            break
            except Exception as e:
                log(f"[FALLBACK_URL][WARN] Estrat√©gia 1 falhou: {e}")
            
            # Estrat√©gia 2: Buscar pelo texto exato em qualquer lugar
            if not link_found:
                try:
                    log("[FALLBACK_URL][CLICK_NUMERO] Tentando Estrat√©gia 2: texto exato")
                    link_locator = page.locator(f'a:has-text("{numero_processo}")')
                    count = await link_locator.count()
                    if count > 0:
                        log(f"[FALLBACK_URL][CLICK_NUMERO] Encontrado(s) {count} link(s) com texto exato")
                        await link_locator.first.click()
                        link_found = True
                except Exception as e:
                    log(f"[FALLBACK_URL][WARN] Estrat√©gia 2 falhou: {e}")
            
            # Estrat√©gia 3: Buscar por link com texto contendo d√≠gitos similares
            if not link_found:
                try:
                    log("[FALLBACK_URL][CLICK_NUMERO] Tentando Estrat√©gia 3: d√≠gitos similares")
                    links = page.locator('#processoRelatorioList a')
                    links_count = await links.count()
                    log(f"[FALLBACK_URL][CLICK_NUMERO] Verificando {links_count} links na tabela")
                    
                    for i in range(min(links_count, 30)):
                        link = links.nth(i)
                        text = await link.text_content()
                        if text:
                            text_digits = re.sub(r'\D', '', text)
                            if text_digits == numero_digits:
                                log(f"[FALLBACK_URL][CLICK_NUMERO] Match por d√≠gitos: '{text}'")
                                await link.click()
                                link_found = True
                                break
                except Exception as e:
                    log(f"[FALLBACK_URL][WARN] Estrat√©gia 3 falhou: {e}")
            
            # Estrat√©gia 4: Clicar diretamente na primeira linha se s√≥ houver 1 resultado
            if not link_found:
                try:
                    log("[FALLBACK_URL][CLICK_NUMERO] Tentando Estrat√©gia 4: primeiro link da tabela")
                    first_link = page.locator('#processoRelatorioList tbody tr:first-child a').first
                    if await first_link.is_visible(timeout=1000):
                        text = await first_link.text_content()
                        log(f"[FALLBACK_URL][CLICK_NUMERO] Clicando no primeiro link: '{text}'")
                        await first_link.click()
                        link_found = True
                except Exception as e:
                    log(f"[FALLBACK_URL][WARN] Estrat√©gia 4 falhou: {e}")
            
            if not link_found:
                log(f"[FALLBACK_URL][ERRO] Link para processo {numero_processo} n√£o encontrado na tabela")
                return False
                
        except Exception as e:
            log(f"[FALLBACK_URL][ERRO] Falha ao clicar no link do processo: {e}")
            return False
        
        # 9. Aguardar navega√ß√£o para a tela de detalhes
        log("[FALLBACK_URL][WAIT_NAV] Aguardando tela de detalhes...")
        await short_sleep_ms(2000)
        
        try:
            await page.wait_for_load_state('load', timeout=15000)
            title = await page.title()
            
            if "Detalhes do Processo" not in title:
                log(f"[FALLBACK_URL][WARN] T√≠tulo n√£o cont√©m 'Detalhes do Processo': {title}")
                # Tentar continuar mesmo assim se a URL parece correta
                current_url = page.url
                if 'detail' not in current_url.lower() and 'id=' not in current_url.lower():
                    log(f"[FALLBACK_URL][ERRO] URL n√£o parece ser de detalhes: {current_url}")
                    return False
        except Exception as e:
            log(f"[FALLBACK_URL][ERRO] Falha ao aguardar navega√ß√£o: {e}")
            return False
        
        # 10. Gravar a URL de detalhes no banco
        detail_url = page.url
        log(f"[FALLBACK_URL][DETALHES_OK] title={title}, url={detail_url}")
        
        if flask_app:
            from models import Process, db
            with flask_app.app_context():
                proc = Process.query.get(process_id)
                if proc:
                    proc.elaw_detail_url = detail_url
                    db.session.commit()
                    log(f"[FALLBACK_URL][SUCESSO] process_id={process_id}, numero={numero_processo}, url={detail_url}")
                    update_status("fallback_url_ok", f"URL de detalhes encontrada!", process_id=process_id)
                    return True
                else:
                    log(f"[FALLBACK_URL][ERRO] Processo {process_id} n√£o encontrado no banco")
                    return False
        
        return False
        
    except Exception as e:
        log(f"[FALLBACK_URL][ERRO] Erro inesperado: {e}")
        return False


# ============================================================================
# M√öLTIPLAS RECLAMADAS - Adicionar partes extras na aba "Partes e Advogados"
# ============================================================================

async def handle_extra_reclamadas(page, data: dict, process_id: int) -> bool:
    """
    Adiciona reclamadas extras na aba "Partes e Advogados" do eLaw.
    
    Prerequisito: Deve estar na tela de detalhes do processo (ap√≥s cadastro com sucesso).
    
    Args:
        page: Playwright Page object
        data: Dicion√°rio com dados extra√≠dos do PDF (deve conter 'reclamadas')
        process_id: ID do processo no banco de dados
        
    Returns:
        bool: True se todas as reclamadas extras foram adicionadas com sucesso
    """
    reclamadas = data.get("reclamadas", [])
    
    # Se tem 1 ou menos reclamada, n√£o h√° extras para adicionar
    if len(reclamadas) <= 1:
        log(f"[RECLAMADAS][RPA] Nenhuma reclamada extra para adicionar (total: {len(reclamadas)})")
        return True
    
    extras = reclamadas[1:]  # Pula a primeira (j√° foi cadastrada como principal)
    log(f"[RECLAMADAS][RPA][ENTROU_HANDLE] Iniciando inser√ß√£o de {len(extras)} reclamadas extras")
    update_status("reclamadas_extras", f"Adicionando {len(extras)} reclamadas extras...", process_id=process_id)
    
    try:
        # Garantir que est√° na tela de detalhes
        title = await page.title()
        if "Detalhes do Processo" not in title:
            log(f"[RECLAMADAS][RPA] N√£o est√° na tela de detalhes (t√≠tulo: {title})")
            
            # Tentar navegar para a URL de detalhes salva no banco
            if flask_app:
                from models import Process, db
                with flask_app.app_context():
                    proc = Process.query.get(process_id)
                    if proc and proc.elaw_detail_url:
                        log(f"[RECLAMADAS][RPA] Navegando para URL de detalhes: {proc.elaw_detail_url}")
                        await page.goto(proc.elaw_detail_url, wait_until="load", timeout=NAV_TIMEOUT_MS)
                        await short_sleep_ms(1000)
                    else:
                        log(f"[RECLAMADAS][RPA][ERRO] URL de detalhes n√£o dispon√≠vel")
                        return False
        
        # Abrir aba "Partes e Advogados"
        log("[RECLAMADAS][RPA] Abrindo aba 'Partes e Advogados'...")
        update_status("reclamadas_aba", "Abrindo aba Partes e Advogados...", process_id=process_id)
        
        # Lista de seletores poss√≠veis para a aba (o eLaw pode usar diferentes estruturas)
        tab_selectors = [
            'a[href="#box-outraspartes"]',
            'a[data-toggle="tab"][href="#box-outraspartes"]',
            'a:has-text("Partes e Advogados")',
            'li a:has-text("Partes")',
            '.nav-tabs a:has-text("Partes")',
            '#tabs-processo a:has-text("Partes")',
            'ul.nav-tabs li a:has-text("Partes")',
        ]
        
        tab_clicked = False
        for tab_sel in tab_selectors:
            try:
                log(f"[RECLAMADAS][RPA] Tentando seletor de aba: {tab_sel}")
                tab_elem = page.locator(tab_sel).first
                if await tab_elem.is_visible(timeout=1000):
                    await tab_elem.click()
                    await short_sleep_ms(1500)
                    tab_clicked = True
                    log(f"[RECLAMADAS][RPA] ‚úÖ Clicou na aba com: {tab_sel}")
                    break
            except Exception as e:
                log(f"[RECLAMADAS][RPA] Seletor {tab_sel} n√£o funcionou: {e}")
                continue
        
        if not tab_clicked:
            log("[RECLAMADAS][RPA][ERRO] N√£o encontrou a aba 'Partes e Advogados'")
            return False
        
        try:
            # Aguardar container ficar vis√≠vel
            container_selectors = ['#box-outraspartes', '#partes-advogados', '.tab-pane#box-outraspartes']
            container_visible = False
            for cont_sel in container_selectors:
                try:
                    await page.wait_for_selector(cont_sel, state='visible', timeout=3000)
                    log(f"[RECLAMADAS][RPA] Container {cont_sel} vis√≠vel")
                    container_visible = True
                    break
                except:
                    continue
            
            if not container_visible:
                log("[RECLAMADAS][RPA][WARN] Container da aba n√£o ficou vis√≠vel, tentando continuar...")
            
            # Esperar um pouco mais para o conte√∫do da aba carregar
            await short_sleep_ms(2000)
            
            # O bot√£o "Nova Parte" est√° dentro de um dropdown "A√ß√µes"
            # O dropdown tem 2 bot√µes: um com texto "A√ß√µes" e outro com seta (dropdown-toggle)
            # Precisamos clicar no bot√£o com dropdown-toggle para abrir o menu
            dropdown_selectors = [
                '#box-outraspartes button.dropdown-toggle',
                '#box-outraspartes button[data-toggle="dropdown"]',
                '#box-outraspartes .btn-group button.dropdown-toggle',
                '#box-outraspartes .btn-group button[data-toggle="dropdown"]',
                '.btn-group button.dropdown-toggle',
                'button[data-toggle="dropdown"].btn-acoes',
            ]
            
            dropdown_found = None
            for dd_sel in dropdown_selectors:
                try:
                    dd = page.locator(dd_sel).first
                    if await dd.count() > 0 and await dd.is_visible(timeout=1000):
                        log(f"[RECLAMADAS][RPA] ‚úÖ Dropdown toggle encontrado: {dd_sel}")
                        dropdown_found = dd_sel
                        break
                except:
                    continue
            
            if not dropdown_found:
                log("[RECLAMADAS][RPA][WARN] Dropdown toggle n√£o encontrado, usando fallback...")
                dropdown_found = '#box-outraspartes .btn-group button:nth-child(2)'
            else:
                log(f"[RECLAMADAS][RPA] Dropdown toggle encontrado, ser√° usado para cada inser√ß√£o")
                
            log("[RECLAMADAS][RPA] ‚úÖ Aba 'Partes e Advogados' aberta com sucesso")
        except Exception as e:
            log(f"[RECLAMADAS][RPA][ERRO] Falha ao abrir aba Partes e Advogados: {e}")
            return False
        
        # Guardar o seletor do dropdown para usar no loop
        acoes_dropdown_selector = dropdown_found
        
        # ‚úÖ VERIFICAR DUPLICATAS: Ler partes j√° existentes na tabela "Outras Partes"
        existing_names = set()
        try:
            log("[RECLAMADAS][RPA] Verificando partes j√° existentes para evitar duplicatas...")
            rows = await page.locator('#box-outraspartes table tbody tr').all()
            for row in rows:
                try:
                    # Pegar o nome da parte (geralmente na 3¬™ coluna - "Nome")
                    nome_cell = row.locator('td:nth-child(3), td:nth-child(4)')
                    nome_text = await nome_cell.text_content() if await nome_cell.count() > 0 else ""
                    if nome_text:
                        # Normalizar para compara√ß√£o
                        nome_norm = nome_text.strip().upper()
                        if nome_norm and len(nome_norm) > 3:
                            existing_names.add(nome_norm)
                except:
                    continue
            log(f"[RECLAMADAS][RPA] Partes j√° cadastradas: {len(existing_names)} - {list(existing_names)[:5]}")
        except Exception as e:
            log(f"[RECLAMADAS][RPA][WARN] Erro ao ler partes existentes: {e}")
        
        # Loop para cada reclamada extra
        success_count = 0
        skipped_count = 0
        for idx, reclamada in enumerate(extras):
            # ‚úÖ VERIFICAR DUPLICATA antes de inserir
            nome_reclamada = reclamada.get("nome", "").strip().upper()
            is_duplicate = False
            for existing in existing_names:
                # Verificar se o nome √© igual ou muito similar (um cont√©m o outro)
                if nome_reclamada == existing or nome_reclamada in existing or existing in nome_reclamada:
                    log(f"[RECLAMADAS][RPA][SKIP] Reclamada '{reclamada['nome']}' j√° existe (similar a '{existing}')")
                    is_duplicate = True
                    skipped_count += 1
                    break
            
            if is_duplicate:
                continue
            try:
                log(f"[RECLAMADAS][RPA] ‚ïê‚ïê‚ïê RECLAMADA EXTRA {idx + 1}/{len(extras)} ‚ïê‚ïê‚ïê")
                update_status("reclamadas_inserindo", f"Inserindo reclamada {idx + 1}/{len(extras)}: {reclamada['nome'][:30]}...", process_id=process_id)
                
                # Abrir dropdown "A√ß√µes" e clicar em "Nova Parte"
                if acoes_dropdown_selector:
                    log(f"[RECLAMADAS][RPA] Abrindo dropdown 'A√ß√µes' ({acoes_dropdown_selector})...")
                    await page.click(acoes_dropdown_selector)
                    await short_sleep_ms(1200)  # Esperar mais para o dropdown abrir
                    
                    # Aguardar o menu dropdown ficar vis√≠vel - usar seletor mais espec√≠fico
                    try:
                        await page.wait_for_selector('#box-outraspartes .dropdown-menu.show, #box-outraspartes .open .dropdown-menu, #box-outraspartes .dropdown-menu[style*="display: block"]', state='visible', timeout=2000)
                        log("[RECLAMADAS][RPA] Menu dropdown aberto dentro de #box-outraspartes")
                    except:
                        # Fallback: tentar qualquer dropdown vis√≠vel
                        try:
                            await page.wait_for_selector('.dropdown-menu.show, .open .dropdown-menu', state='visible', timeout=1000)
                            log("[RECLAMADAS][RPA][WARN] Menu dropdown aberto (fallback gen√©rico)")
                        except:
                            log("[RECLAMADAS][RPA][WARN] Menu dropdown pode n√£o ter aberto corretamente")
                    
                    # Debug: listar itens do dropdown - APENAS dentro de #box-outraspartes
                    try:
                        menu_items = await page.locator('#box-outraspartes .dropdown-menu a').all_text_contents()
                        log(f"[RECLAMADAS][RPA][DEBUG] Itens no dropdown #box-outraspartes: {menu_items[:5]}")
                    except Exception as e:
                        log(f"[RECLAMADAS][RPA][DEBUG] Erro ao listar menu: {e}")
                    
                    # Clicar em "Nova Parte" - usar ID espec√≠fico primeiro
                    nova_parte_selectors = [
                        '#buttonNewParte',
                        'a#buttonNewParte',
                        '#box-outraspartes #buttonNewParte',
                        '.dropdown-menu #buttonNewParte',
                        'ul.dropdown-menu li a#buttonNewParte',
                        '.dropdown-menu a[title="Nova Parte"]',
                        '#box-outraspartes .dropdown-menu a:has-text("Nova Parte")',
                        '.dropdown-menu a:has-text("Nova Parte")',
                    ]
                    
                    clicked = False
                    for np_sel in nova_parte_selectors:
                        try:
                            np_btn = page.locator(np_sel).first
                            if await np_btn.count() > 0 and await np_btn.is_visible(timeout=500):
                                log(f"[RECLAMADAS][RPA] ‚úÖ Clicando em 'Nova Parte' ({np_sel})...")
                                await np_btn.click()
                                clicked = True
                                break
                        except Exception as e:
                            log(f"[RECLAMADAS][RPA][DEBUG] Tentativa {np_sel}: {e}")
                            continue
                    
                    if not clicked:
                        # Fallback: tentar via JavaScript
                        log("[RECLAMADAS][RPA][WARN] Seletores falharam, tentando via JavaScript...")
                        try:
                            result = await page.evaluate("""
                                () => {
                                    const links = document.querySelectorAll('.dropdown-menu a, ul.dropdown-menu li a');
                                    for (const link of links) {
                                        if (link.textContent && link.textContent.includes('Nova Parte')) {
                                            link.click();
                                            return 'clicked';
                                        }
                                    }
                                    return 'not_found';
                                }
                            """)
                            if result == 'clicked':
                                log("[RECLAMADAS][RPA] ‚úÖ Clicado via JavaScript!")
                                clicked = True
                            else:
                                log("[RECLAMADAS][RPA][WARN] JavaScript n√£o encontrou 'Nova Parte'")
                        except Exception as js_err:
                            log(f"[RECLAMADAS][RPA][WARN] Erro JavaScript: {js_err}")
                    
                    if not clicked:
                        log("[RECLAMADAS][RPA][WARN] N√£o encontrou 'Nova Parte' no dropdown - pulando reclamada")
                        continue
                else:
                    # Fallback: tentar clicar diretamente no bot√£o
                    log("[RECLAMADAS][RPA] Tentando clicar diretamente em 'Nova Parte'...")
                    await page.click('#buttonNewParte')
                
                await short_sleep_ms(1500)
                
                # Aguardar modal abrir
                modal_selectors = ['#dialog-modal.show', '#dialog-modal.in', '.modal.show', '.modal.in']
                modal_visible = False
                for sel in modal_selectors:
                    try:
                        await page.wait_for_selector(sel, state='visible', timeout=3000)
                        modal_visible = True
                        break
                    except:
                        pass
                
                if not modal_visible:
                    log(f"[RECLAMADAS][RPA][WARN] Modal n√£o detectado para reclamada {idx + 1}")
                    continue
                
                # Aguardar select de Posi√ß√£o
                await page.wait_for_selector('#PosicaoParteId', state='attached', timeout=3000)
                log("[RECLAMADAS][RPA] Modal 'Nova Parte' aberto")
                
                # Selecionar Posi√ß√£o da Parte (RECLAMADO ou REU)
                posicao = reclamada.get("posicao", "RECLAMADO")
                log(f"[RECLAMADAS][RPA][POSICAO] Selecionando posi√ß√£o: {posicao}")
                
                # Mapear posi√ß√£o para value do select
                posicao_value = await _map_posicao_to_select_value(page, posicao)
                if posicao_value:
                    await page.select_option('#PosicaoParteId', value=posicao_value)
                    await short_sleep_ms(500)
                else:
                    # Fallback: tentar selecionar por texto vis√≠vel
                    try:
                        await page.select_option('#PosicaoParteId', label=posicao)
                    except:
                        log(f"[RECLAMADAS][RPA][WARN] N√£o encontrou posi√ß√£o '{posicao}', usando RECLAMADO")
                        await page.select_option('#PosicaoParteId', value='52')  # 52 = RECLAMADO (valor comum no eLaw)
                
                await short_sleep_ms(500)
                
                # Preencher Nome da Parte
                nome = reclamada.get("nome", "")
                log(f"[RECLAMADAS][RPA][NOME_PARTE] Preenchendo nome: {nome}")
                
                # Verificar se campo √© input ou select (depende da posi√ß√£o selecionada)
                nome_input = page.locator('#NomeParte')
                nome_select = page.locator('#IdParteList')
                
                try:
                    if await nome_input.is_visible(timeout=1000):
                        await nome_input.fill(nome)
                        log("[RECLAMADAS][RPA] Nome preenchido via input")
                    elif await nome_select.is_visible(timeout=1000):
                        # Select - tentar encontrar op√ß√£o que contenha o nome
                        log("[RECLAMADAS][RPA] Nome via select - buscando op√ß√£o...")
                        # Tentar selecionar por texto parcial
                        options = await page.query_selector_all('#IdParteList option')
                        for opt in options:
                            opt_text = await opt.text_content()
                            if nome.upper() in (opt_text or "").upper():
                                opt_value = await opt.get_attribute('value')
                                await page.select_option('#IdParteList', value=opt_value)
                                log(f"[RECLAMADAS][RPA] Selecionado: {opt_text}")
                                break
                except Exception as e:
                    log(f"[RECLAMADAS][RPA][WARN] Erro ao preencher nome: {e}")
                
                await short_sleep_ms(300)
                
                # Selecionar Tipo Pessoa (F√≠sica ou Jur√≠dica)
                # NOTA: Usamos JavaScript porque o iCheck coloca overlay <ins> que intercepta cliques
                tipo = reclamada.get("tipo_pessoa", "")
                log(f"[RECLAMADAS][RPA][TIPO_PESSOA] Selecionando tipo: {tipo}")
                
                tipo_value = "2" if tipo == "juridica" else "1"
                try:
                    # Primeiro tentar via JavaScript (contorna overlay do iCheck)
                    await page.evaluate(f'''
                        const radio = document.querySelector('input[name="TipoPessoa"][value="{tipo_value}"]');
                        if (radio) {{
                            radio.checked = true;
                            radio.dispatchEvent(new Event('change', {{ bubbles: true }}));
                            // Trigger iCheck update se existir
                            if (typeof $.fn.iCheck !== 'undefined') {{
                                $(radio).iCheck('update');
                            }}
                        }}
                    ''')
                    log(f"[RECLAMADAS][RPA][TIPO_PESSOA] ‚úÖ Selecionado via JavaScript: {tipo}")
                except Exception as e:
                    log(f"[RECLAMADAS][RPA][TIPO_PESSOA][WARN] Fallback para click: {e}")
                    # Fallback: clicar no label/container do iCheck
                    try:
                        container = page.locator(f'input[name="TipoPessoa"][value="{tipo_value}"]').locator('..')
                        await container.click(force=True)
                    except:
                        pass
                
                await short_sleep_ms(300)
                
                # Clicar em Salvar do modal
                log("[RECLAMADAS][RPA] Clicando em Salvar...")
                save_btn = page.locator('#dialog-modal button.btn.btn-primary.salvar, #dialog-modal button[type="submit"]')
                await save_btn.click()
                await short_sleep_ms(2000)
                
                # Aguardar modal fechar
                try:
                    await page.wait_for_selector('#dialog-modal', state='hidden', timeout=5000)
                    log(f"[RECLAMADAS][RPA] ‚úÖ Reclamada {idx + 1} inserida com sucesso!")
                    success_count += 1
                    # Adicionar ao set para evitar duplicatas no mesmo loop
                    existing_names.add(nome_reclamada)
                except:
                    # Modal pode n√£o ter fechado, mas n√£o necessariamente erro
                    log(f"[RECLAMADAS][RPA][WARN] Modal pode n√£o ter fechado ap√≥s reclamada {idx + 1}")
                
            except Exception as e:
                log(f"[RECLAMADAS][RPA][ERRO] Falha ao inserir reclamada {idx + 1}: {e}")
                # Continuar para as pr√≥ximas
        
        log(f"[RECLAMADAS][RPA] Inseridas {success_count}/{len(extras)} reclamadas extras (puladas: {skipped_count} duplicatas)")
        
        # Screenshot da aba "Partes e Advogados" ap√≥s inserir todas
        if success_count > 0:
            await _take_reclamadas_screenshot(page, process_id)
        
        # ‚ö†Ô∏è NOTA: Marca√ß√µes e pedidos agora s√£o tratados FORA desta fun√ß√£o
        # para permitir que processos sem reclamadas extras tamb√©m tenham pedidos
        # Ver handle_marcacoes_e_pedidos_pos_save()
        
        return success_count == len(extras)
        
    except Exception as e:
        log(f"[RECLAMADAS][RPA][ERRO] Erro geral no handle_extra_reclamadas: {e}")
        return False


async def _map_posicao_to_select_value(page, posicao: str) -> str:
    """
    Mapeia a posi√ß√£o extra√≠da do PDF para o value do select no eLaw.
    
    Args:
        page: Playwright page
        posicao: Posi√ß√£o do PDF (RECLAMADO, REU, etc)
        
    Returns:
        str: Value do option correspondente, ou None se n√£o encontrar
    """
    posicao_upper = posicao.upper().strip()
    
    # Mapeamento de posi√ß√µes comuns para values do eLaw
    # Esses values s√£o os mais comuns no eLaw, mas podem variar por instala√ß√£o
    POSICAO_MAP = {
        "RECLAMADO": "52",
        "RECLAMADA": "52",
        "REU": "2",
        "R√âU": "2",
        "R√â": "2",
        "APELADO": "7",
        "AGRAVADO": "12",
        "EXECUTADO": "21",
        "REQUERIDO": "35",
    }
    
    # Tentar mapeamento direto
    if posicao_upper in POSICAO_MAP:
        return POSICAO_MAP[posicao_upper]
    
    # Fallback: buscar no select da p√°gina
    try:
        options = await page.query_selector_all('#PosicaoParteId option')
        for opt in options:
            opt_text = await opt.text_content()
            if posicao_upper in (opt_text or "").upper():
                return await opt.get_attribute('value')
    except Exception:
        pass
    
    return None


async def _take_reclamadas_screenshot(page, process_id: int):
    """
    Captura screenshot da aba "Partes e Advogados" ap√≥s inserir reclamadas extras.
    Salva o caminho em Process.elaw_screenshot_reclamadas_path.
    """
    log("[RECLAMADAS][RPA][SHOT] Capturando screenshot da aba Partes e Advogados...")
    update_status("reclamadas_screenshot", "Capturando screenshot das reclamadas...", process_id=process_id)
    
    try:
        # Garantir que aba est√° vis√≠vel
        await page.click('a[href="#box-outraspartes"]')
        await short_sleep_ms(500)
        
        # Gerar nome do arquivo
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        screenshot_filename = f"process_{process_id}_{timestamp}_reclamadas.png"
        
        screenshot_dir = Path("static") / "rpa_screenshots"
        screenshot_dir.mkdir(parents=True, exist_ok=True)
        screenshot_path = screenshot_dir / screenshot_filename
        
        await page.screenshot(path=str(screenshot_path), full_page=True)
        log(f"[RECLAMADAS][RPA][SHOT] Screenshot salvo: {screenshot_path}")
        
        # Salvar no banco de dados
        if flask_app:
            from models import Process, db
            with flask_app.app_context():
                proc = Process.query.get(process_id)
                if proc:
                    proc.elaw_screenshot_reclamadas_path = screenshot_filename
                    db.session.commit()
                    log(f"[RECLAMADAS][RPA][SHOT] ‚úÖ Caminho salvo no banco: {screenshot_filename}")
        
        send_screenshot_to_monitor(screenshot_path, region="RECLAMADAS_EXTRAS")
        
    except Exception as e:
        log(f"[RECLAMADAS][RPA][SHOT][ERRO] Falha ao capturar screenshot: {e}")


# =========================
# MARCA√á√ïES - Editar marca√ß√µes do processo
# =========================
async def handle_marcacoes(page, data: dict, process_id: int) -> bool:
    """
    Edita marca√ß√µes do processo na aba Geral.
    
    Fluxo:
    1. Clica na aba "Geral" na sidebar
    2. Abre dropdown "A√ß√µes"
    3. Clica em "Editar Marca√ß√µes"
    4. No modal, marca checkboxes baseados na reclamada (cliente)
    5. Clica em "Salvar"
    
    Args:
        page: Playwright Page object
        data: Dicion√°rio com dados do processo (deve conter 'cliente' ou 'reclamada_principal')
        process_id: ID do processo no banco
        
    Returns:
        bool: True se marca√ß√µes foram editadas com sucesso
    """
    log("[MARCACOES][RPA] Iniciando edi√ß√£o de marca√ß√µes...")
    update_status("marcacoes_inicio", "Abrindo aba Geral para editar marca√ß√µes...", process_id=process_id)
    
    try:
        # 1. Clicar na aba "Geral" na sidebar
        log("[MARCACOES][RPA] Clicando na aba Geral...")
        geral_tab = page.locator('a[href="#box-dadosprincipais"]')
        await geral_tab.click(timeout=5000)
        await short_sleep_ms(1000)
        
        # GUARD: Verificar se a se√ß√£o est√° vis√≠vel com timeout curto
        try:
            await page.wait_for_selector('#box-dadosprincipais', state='visible', timeout=5000)
            log("[MARCACOES][RPA] Aba Geral vis√≠vel, continuando...")
        except Exception:
            log("[MARCACOES][RPA][SKIP] Se√ß√£o Geral n√£o vis√≠vel - pulando marca√ß√µes")
            update_status("marcacoes_skip", "Se√ß√£o de marca√ß√µes n√£o dispon√≠vel", process_id=process_id)
            return False
        
        # 2. Abrir dropdown "A√ß√µes" - com timeout curto para evitar loop infinito
        log("[MARCACOES][RPA] Abrindo dropdown A√ß√µes...")
        acoes_dropdown = page.locator('.btn-group .btn-acoes.dropdown-toggle').first
        try:
            await acoes_dropdown.click(timeout=5000)
        except Exception as e:
            log(f"[MARCACOES][RPA][SKIP] Dropdown A√ß√µes n√£o encontrado: {e}")
            return False
        await short_sleep_ms(500)
        
        # 3. Clicar em "Editar Marca√ß√µes" - com timeout curto
        log("[MARCACOES][RPA] Clicando em Editar Marca√ß√µes...")
        editar_marcacoes = page.locator('#buttonMarcacoesProcesso')
        try:
            await editar_marcacoes.click(timeout=5000)
        except Exception as e:
            log(f"[MARCACOES][RPA][SKIP] Bot√£o Editar Marca√ß√µes n√£o encontrado: {e}")
            return False
        await short_sleep_ms(1500)
        
        # 4. Aguardar modal abrir
        update_status("marcacoes_modal", "Modal de marca√ß√µes aberto, identificando op√ß√µes...", process_id=process_id)
        await page.wait_for_selector('.modal.in, .modal.show, #dialog-modal', state='visible', timeout=5000)
        
        # 5. Identificar o cliente/reclamada para marcar
        cliente = data.get("cliente", "") or data.get("reclamada_principal", "") or data.get("parte_interessada", "")
        log(f"[MARCACOES][RPA] Cliente para marca√ß√£o: {cliente}")
        
        if cliente:
            # Procurar checkboxes no modal que contenham o nome do cliente
            # iCheck usa estrutura: <div class="icheckbox_..."><input type="checkbox"><ins class="iCheck-helper"></div>
            
            # Buscar todos os labels/textos de checkbox no modal
            checkboxes = await page.query_selector_all('.modal input[type="checkbox"], .modal input[type="radio"]')
            
            for checkbox in checkboxes:
                try:
                    # Pegar o texto associado (label ou parent text)
                    parent = await checkbox.evaluate_handle('el => el.closest("label") || el.parentElement')
                    label_text = await parent.text_content() if parent else ""
                    
                    # Verificar se o texto cont√©m o cliente
                    cliente_upper = cliente.upper()
                    label_upper = (label_text or "").upper()
                    
                    # Matching parcial - CSN, CBSI, ORIZON, etc.
                    if any(parte in label_upper for parte in cliente_upper.split()):
                        log(f"[MARCACOES][RPA] ‚úÖ Encontrada marca√ß√£o para: {label_text}")
                        
                        # Marcar via JavaScript (contorna iCheck overlay)
                        await checkbox.evaluate('''el => {
                            el.checked = true;
                            el.dispatchEvent(new Event("change", {bubbles: true}));
                            // Trigger iCheck update se existir
                            if (typeof $ !== "undefined" && typeof $.fn.iCheck !== "undefined") {
                                $(el).iCheck("check");
                            }
                        }''')
                        
                        update_status("marcacoes_check", f"Marcado: {label_text}", process_id=process_id)
                        await short_sleep_ms(300)
                except Exception as e:
                    log(f"[MARCACOES][RPA][WARN] Erro ao processar checkbox: {e}")
        
        # 6. Clicar em Salvar (usar .first para evitar ambiguidade com "Salvar e Fechar")
        log("[MARCACOES][RPA] Clicando em Salvar...")
        save_btn = page.locator('.modal button.btn-primary.salvar:not(.salvarfechar)').first
        await save_btn.click()
        await short_sleep_ms(2000)
        
        # 7. Aguardar modal fechar
        try:
            await page.wait_for_selector('.modal.in, .modal.show', state='hidden', timeout=5000)
            log("[MARCACOES][RPA] ‚úÖ Marca√ß√µes salvas com sucesso!")
            update_status("marcacoes_ok", "Marca√ß√µes salvas com sucesso", process_id=process_id)
            return True
        except:
            log("[MARCACOES][RPA][WARN] Modal pode n√£o ter fechado")
            return True  # Consideramos sucesso mesmo assim
            
    except Exception as e:
        log(f"[MARCACOES][RPA][ERRO] Falha ao editar marca√ß√µes: {e}")
        update_status("marcacoes_erro", f"Erro nas marca√ß√µes: {e}", process_id=process_id)
        return False


# =========================
# PEDIDOS - Adicionar novos pedidos (m√∫ltiplos) - OTIMIZADO 2025-11-27
# =========================

# ‚úÖ Configura√ß√µes de otimiza√ß√£o de pedidos
PEDIDOS_STATUS_UPDATE_INTERVAL = 5  # Atualizar status a cada N pedidos
PEDIDOS_FAST_WAIT_MS = 200  # Wait m√≠nimo ap√≥s a√ß√µes r√°pidas
PEDIDOS_MODAL_WAIT_MS = 500  # Wait ap√≥s abrir/fechar modal
PEDIDOS_SAVE_WAIT_MS = 800  # Wait ap√≥s salvar (reduzido de 2000)

async def handle_novo_pedido(page, data: dict, process_id: int) -> bool:
    """
    Adiciona M√öLTIPLOS pedidos na aba Pedidos.
    
    üöÄ OTIMIZADO 2025-11-27 - Plano Batman:
    - Waits inteligentes ao inv√©s de fixos
    - Atualiza√ß√£o de status agrupada (a cada 5 pedidos)
    - Verifica√ß√£o de duplicatas antes de inserir
    - Aba mantida ativa sem reabrir a cada itera√ß√£o
    
    Fluxo otimizado:
    1. Abre aba "Pedidos" UMA VEZ
    2. L√™ pedidos existentes para evitar duplicatas
    3. Para cada pedido novo:
       - Abre dropdown ‚Üí Novo Pedido ‚Üí Seleciona tipo ‚Üí Preenche valor ‚Üí Salva
    4. Atualiza status a cada 5 pedidos
    5. Captura screenshot final
    
    Args:
        page: Playwright Page object
        data: Dicion√°rio com dados do processo (deve conter 'tipos_pedidos' ou 'pedidos')
        process_id: ID do processo no banco
        
    Returns:
        bool: True se pelo menos um pedido foi adicionado
    """
    import time
    start_time = time.time()
    
    log("[PEDIDOS][RPA] Iniciando adi√ß√£o de pedidos (OTIMIZADO)...")
    update_status("pedidos_inicio", "Abrindo aba Pedidos...", process_id=process_id)
    
    try:
        # 1. Clicar na aba "Pedidos" na sidebar (OTIMIZADO - wait inteligente)
        log("[PEDIDOS][RPA] Clicando na aba Pedidos...")
        pedidos_tab = page.locator('a[href="#box-pedidos"][data-toggle="tab"]')
        
        try:
            # Primeira tentativa: clique normal
            await pedidos_tab.click(timeout=5000)
            
            # ‚úÖ OTIMIZADO: Wait inteligente - esperar aba aparecer ao inv√©s de sleep fixo
            try:
                await page.locator('#box-pedidos').wait_for(state='visible', timeout=3000)
                log("[PEDIDOS][RPA] ‚úÖ Aba Pedidos vis√≠vel (wait inteligente)")
            except:
                # Fallback: usar JavaScript para ativar a aba Bootstrap
                log("[PEDIDOS][RPA] Clique normal n√£o ativou aba - tentando via JavaScript...")
                await page.evaluate("""() => {
                    document.querySelectorAll('.nav-tabs li').forEach(li => li.classList.remove('active'));
                    document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('active', 'in'));
                    const pedidosLink = document.querySelector('a[href="#box-pedidos"]');
                    if (pedidosLink) pedidosLink.parentElement.classList.add('active');
                    const pedidosPane = document.querySelector('#box-pedidos');
                    if (pedidosPane) pedidosPane.classList.add('active', 'in');
                }""")
                await page.locator('#box-pedidos').wait_for(state='visible', timeout=3000)
            
            # ‚úÖ OTIMIZADO: Aguardar dropdown de a√ß√µes ficar vis√≠vel (wait inteligente)
            try:
                await page.locator('#box-pedidos .btn-group button.btn-acoes.dropdown-toggle').first.wait_for(state='visible', timeout=3000)
                log("[PEDIDOS][RPA] ‚úÖ Dropdown A√ß√µes vis√≠vel")
            except:
                log("[PEDIDOS][RPA] Dropdown n√£o vis√≠vel - tentando via JavaScript...")
                await page.evaluate("""() => {
                    const tab = document.querySelector('a[href="#box-pedidos"]');
                    if (tab) tab.click();
                    document.querySelectorAll('.nav-tabs li').forEach(li => li.classList.remove('active'));
                    document.querySelectorAll('.tab-content .tab-pane').forEach(pane => pane.classList.remove('active', 'in'));
                    const pedidosTab = document.querySelector('a[href="#box-pedidos"]');
                    if (pedidosTab && pedidosTab.parentElement) pedidosTab.parentElement.classList.add('active');
                    const pedidosPane = document.querySelector('#box-pedidos');
                    if (pedidosPane) { pedidosPane.classList.add('active', 'in'); pedidosPane.style.display = 'block'; }
                }""")
                await short_sleep_ms(PEDIDOS_MODAL_WAIT_MS)
                
        except Exception as e:
            log(f"[PEDIDOS][RPA][SKIP] Aba Pedidos n√£o dispon√≠vel: {e}")
            update_status("pedidos_skip", "Aba de Pedidos n√£o dispon√≠vel", process_id=process_id)
            return False
        
        # Identificar tipos de pedidos a adicionar
        tipos_pedidos = data.get("tipos_pedidos", [])
        pedidos_list = data.get("pedidos", [])
        objeto = data.get("objeto", "") or data.get("sub_objeto", "")
        
        # Se n√£o tiver tipos_pedidos extra√≠dos, tentar mapear dos pedidos
        if not tipos_pedidos and pedidos_list:
            tipos_pedidos = await _map_pedidos_to_tipos(page, pedidos_list, objeto)
        
        # Se ainda n√£o tiver tipos, usar pedidos padr√£o baseado no tipo de a√ß√£o
        if not tipos_pedidos:
            log("[PEDIDOS][RPA] Nenhum tipo extra√≠do - abrindo modal para buscar tipos padr√£o")
            # CORRIGIDO: Abrir o modal primeiro, pois #TipoPedidoId s√≥ existe dentro dele
            try:
                await short_sleep_ms(500)
                
                # Abrir dropdown A√ß√µes (bot√£o com classe .btn-acoes.dropdown-toggle)
                acoes_dropdown = page.locator('#box-pedidos .btn-group button.btn-acoes.dropdown-toggle').first
                log("[PEDIDOS][RPA] Clicando no dropdown A√ß√µes...")
                await acoes_dropdown.click(timeout=5000)
                await short_sleep_ms(500)
                
                # Clicar em Novo Pedido para abrir modal (id=buttonNewPedido)
                novo_pedido = page.locator('#buttonNewPedido')
                log("[PEDIDOS][RPA] Clicando em Novo Pedido...")
                await novo_pedido.click(timeout=5000)
                await short_sleep_ms(1000)
                
                # Aguardar modal abrir
                await page.wait_for_selector('.modal.in, .modal.show, #dialog-modal', state='visible', timeout=5000)
                
                # ‚úÖ AGUARDAR op√ß√µes do select carregarem (AJAX demora!)
                await short_sleep_ms(1500)  # Dar tempo para AJAX carregar
                
                # Aguardar que o select tenha op√ß√µes (al√©m de "Selecione")
                try:
                    await page.wait_for_function("""() => {
                        const sel = document.querySelector('#TipoPedidoId');
                        return sel && sel.options && sel.options.length > 1;
                    }""", timeout=5000)
                    log("[PEDIDOS][RPA] Select de tipos carregado com op√ß√µes")
                except:
                    log("[PEDIDOS][RPA] Aguardando op√ß√µes do select (timeout)...")
                    await short_sleep_ms(1000)  # Delay extra
                
                # Agora sim, buscar op√ß√µes do select que est√° no modal
                tipo_select = page.locator('#TipoPedidoId')
                options = await tipo_select.locator('option').all()
                log(f"[PEDIDOS][RPA] Total de op√ß√µes no select: {len(options)}")
                
                for opt in options[:4]:  # Pegar at√© 3 op√ß√µes (pulando a primeira que √© "Selecione")
                    opt_value = await opt.get_attribute('value')
                    opt_text = await opt.text_content()
                    if opt_value and opt_value.strip() and opt_text and "selecione" not in opt_text.lower():
                        tipos_pedidos.append({"value": opt_value, "text": opt_text.strip()})
                        log(f"[PEDIDOS][RPA][FALLBACK] Tipo padr√£o encontrado: {opt_text.strip()}")
                        if len(tipos_pedidos) >= 3:
                            break
                
                log(f"[PEDIDOS][RPA] Usando {len(tipos_pedidos)} tipos padr√£o do dropdown")
                
                # Fechar modal ap√≥s capturar op√ß√µes (vai reabrir para cada pedido no loop)
                try:
                    close_btn = page.locator('#dialog-modal button.close, .modal.in button.close').first
                    await close_btn.click(timeout=3000)
                    await short_sleep_ms(500)
                except:
                    # Tentar via JavaScript
                    await page.evaluate("document.querySelector('#dialog-modal')?.querySelector('button.close')?.click()")
                    await short_sleep_ms(500)
                    
            except Exception as e:
                log(f"[PEDIDOS][RPA][WARN] Erro ao buscar tipos padr√£o: {e}")
                # Tentar fechar modal se estiver aberto
                try:
                    await page.evaluate("document.querySelector('#dialog-modal')?.querySelector('button.close')?.click()")
                    await short_sleep_ms(300)
                except:
                    pass
        
        if not tipos_pedidos:
            log("[PEDIDOS][RPA][WARN] Nenhum tipo de pedido dispon√≠vel - pulando")
            return False
        
        # ‚úÖ CR√çTICO: Aplicar limite m√°ximo de pedidos ANTES do loop
        original_count = len(tipos_pedidos)
        if original_count > MAX_PEDIDOS_PARA_INSERIR:
            log(f"[PEDIDOS][RPA] ‚ö†Ô∏è LIMITE: Reduzindo de {original_count} para {MAX_PEDIDOS_PARA_INSERIR} pedidos")
            tipos_pedidos = tipos_pedidos[:MAX_PEDIDOS_PARA_INSERIR]
        
        log(f"[PEDIDOS][RPA] Tipos de pedidos a adicionar: {len(tipos_pedidos)}")
        
        # ‚úÖ VERIFICAR DUPLICATAS: Ler pedidos j√° existentes na tabela
        existing_pedidos = set()
        try:
            log("[PEDIDOS][RPA] Verificando pedidos j√° existentes para evitar duplicatas...")
            await short_sleep_ms(500)
            rows = await page.locator('#box-pedidos table tbody tr').all()
            for row in rows:
                try:
                    # Pegar o tipo do pedido (geralmente na 2¬™ ou 3¬™ coluna)
                    tipo_cell = row.locator('td:nth-child(2), td:nth-child(3)')
                    tipo_text = await tipo_cell.text_content() if await tipo_cell.count() > 0 else ""
                    if tipo_text:
                        tipo_norm = tipo_text.strip().upper()
                        if tipo_norm and len(tipo_norm) > 2:
                            existing_pedidos.add(tipo_norm)
                except:
                    continue
            log(f"[PEDIDOS][RPA] Pedidos j√° cadastrados: {len(existing_pedidos)} - {list(existing_pedidos)[:5]}")
        except Exception as e:
            log(f"[PEDIDOS][RPA][WARN] Erro ao ler pedidos existentes: {e}")
        
        success_count = 0
        skipped_count = 0
        last_status_update = 0  # ‚úÖ Para atualiza√ß√£o agrupada de status
        
        log(f"[PEDIDOS][RPA] ‚ö° Iniciando loop OTIMIZADO para {len(tipos_pedidos)} pedidos")
        
        # Loop para adicionar cada pedido (OTIMIZADO)
        for idx, tipo_info in enumerate(tipos_pedidos):
            # ‚úÖ GUARD: Parar se atingir limite m√°ximo
            if success_count >= MAX_PEDIDOS_PARA_INSERIR:
                log(f"[PEDIDOS][RPA] ‚ö†Ô∏è LIMITE atingido: {success_count} pedidos inseridos - parando loop")
                break
            
            try:
                tipo_value = tipo_info.get("value") if isinstance(tipo_info, dict) else tipo_info
                tipo_text = tipo_info.get("text", tipo_value) if isinstance(tipo_info, dict) else tipo_value
                
                # ‚úÖ VERIFICAR DUPLICATA antes de inserir
                tipo_norm = (tipo_text or str(tipo_value)).strip().upper()
                is_duplicate = False
                for existing in existing_pedidos:
                    if tipo_norm == existing or tipo_norm in existing or existing in tipo_norm:
                        log(f"[PEDIDOS][RPA][SKIP] Pedido '{tipo_text}' j√° existe")
                        is_duplicate = True
                        skipped_count += 1
                        break
                
                if is_duplicate:
                    continue
                
                # ‚úÖ OTIMIZADO: Atualizar status a cada N pedidos (n√£o a cada 1)
                if (idx + 1) - last_status_update >= PEDIDOS_STATUS_UPDATE_INTERVAL:
                    update_status("pedidos_adicionando", f"Adicionando pedidos {idx + 1}/{len(tipos_pedidos)}...", process_id=process_id)
                    last_status_update = idx + 1
                
                # ‚úÖ OTIMIZADO: Verificar modal apenas se necess√°rio (n√£o sempre)
                try:
                    modal_visible = await page.locator('.modal.in, .modal.show').first.is_visible()
                    if modal_visible:
                        await page.evaluate("""() => {
                            document.querySelectorAll('.modal.in button.close, .modal.show button.close').forEach(btn => btn.click());
                            document.querySelectorAll('.modal.in, .modal.show').forEach(m => { m.classList.remove('in', 'show'); m.style.display = 'none'; });
                            document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
                        }""")
                        await page.locator('.modal.in, .modal.show').wait_for(state='hidden', timeout=1500)
                except:
                    pass
                
                # ‚úÖ OTIMIZADO: S√≥ reativar aba se perdeu foco (n√£o sempre)
                try:
                    box_visible = await page.locator('#box-pedidos').is_visible()
                    if not box_visible:
                        await page.evaluate("document.querySelector('a[href=\"#box-pedidos\"]')?.click()")
                        await page.locator('#box-pedidos').wait_for(state='visible', timeout=2000)
                except:
                    pass
                
                # 2. Abrir dropdown "A√ß√µes" e clicar em Novo Pedido (OTIMIZADO - sequ√™ncia r√°pida)
                acoes_dropdown = page.locator('#box-pedidos .btn-group button.btn-acoes.dropdown-toggle').first
                await acoes_dropdown.click(timeout=3000)
                await short_sleep_ms(PEDIDOS_FAST_WAIT_MS)  # 200ms ao inv√©s de 500ms
                
                novo_pedido = page.locator('#buttonNewPedido')
                await novo_pedido.click()
                
                # ‚úÖ OTIMIZADO: Wait inteligente para modal + select carregar
                try:
                    await page.wait_for_selector('.modal.in #TipoPedidoId, .modal.show #TipoPedidoId, #dialog-modal #TipoPedidoId', state='visible', timeout=3000)
                    await page.wait_for_function("document.querySelector('#TipoPedidoId')?.options?.length > 1", timeout=3000)
                except:
                    await short_sleep_ms(PEDIDOS_MODAL_WAIT_MS)  # Fallback com sleep curto
                
                # ‚úÖ VERIFICAR se o value existe no select
                value_exists = await page.evaluate(f"""() => {{
                    const select = document.querySelector('#TipoPedidoId');
                    if (!select) return false;
                    for (let i = 0; i < select.options.length; i++) {{
                        if (select.options[i].value === '{tipo_value}') return true;
                    }}
                    return false;
                }}""")
                
                if not value_exists:
                    log(f"[PEDIDOS][RPA][SKIP] Tipo '{tipo_text}' n√£o encontrado no select")
                    await page.evaluate("document.querySelector('#dialog-modal button.close, .modal.in button.close')?.click()")
                    await short_sleep_ms(PEDIDOS_FAST_WAIT_MS)
                    continue
                
                # 5. Selecionar Tipo do Pedido (OTIMIZADO - direto sem verifica√ß√£o extra)
                await page.locator('#TipoPedidoId').select_option(value=str(tipo_value))
                
                log(f"[PEDIDOS][RPA] Tipo selecionado: {tipo_text}")
                
                # 6. Preencher Valor Pedido com 0,00 (OTIMIZADO - sequ√™ncia r√°pida)
                valor_input = page.locator('#Valor')
                await valor_input.click()
                current_value = await valor_input.input_value()
                if not current_value or current_value.strip() == "":
                    await valor_input.fill("0,00")
                
                # Disparar eventos (compactado)
                await valor_input.evaluate("el => ['input','change','blur'].forEach(ev => el.dispatchEvent(new Event(ev,{bubbles:true})))")
                
                # 7. Salvar (OTIMIZADO - wait inteligente)
                save_btn = page.locator('.modal button.btn-primary.salvar:not(.salvarfechar)').first
                await save_btn.click()
                
                # ‚úÖ OTIMIZADO: Wait inteligente para modal fechar
                try:
                    await page.locator('.modal.in, .modal.show').wait_for(state='hidden', timeout=3000)
                    success_count += 1
                    existing_pedidos.add(tipo_norm)
                    # Log a cada 5 pedidos para n√£o poluir
                    if success_count % 5 == 0:
                        log(f"[PEDIDOS][RPA] ‚ö° {success_count} pedidos adicionados...")
                except:
                    # Modal n√£o fechou = erro de valida√ß√£o
                    try:
                        error_msg = await page.locator('.modal .validation-summary-errors, .modal .field-validation-error').first.text_content()
                        if error_msg:
                            log(f"[PEDIDOS][RPA][WARN] Erro valida√ß√£o: {error_msg.strip()[:50]}")
                    except:
                        pass
                    
                    # Fechar modal rapidamente
                    await page.evaluate("""() => {
                        document.querySelectorAll('.modal.in button.close, .modal.show button.close').forEach(btn => btn.click());
                        document.querySelectorAll('.modal.in, .modal.show').forEach(m => { m.classList.remove('in', 'show'); m.style.display = 'none'; });
                        document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
                    }""")
                    await short_sleep_ms(PEDIDOS_FAST_WAIT_MS)
                
            except Exception as e:
                log(f"[PEDIDOS][RPA][ERRO] Pedido {idx + 1}: {str(e)[:50]}")
                try:
                    await page.evaluate("document.querySelector('.modal.in button.close, #dialog-modal button.close')?.click()")
                    await short_sleep_ms(PEDIDOS_FAST_WAIT_MS)
                except:
                    pass
        
        # ‚úÖ Log de tempo total
        elapsed = time.time() - start_time
        log(f"[PEDIDOS][RPA] ‚ö° Adicionados {success_count}/{len(tipos_pedidos)} pedidos em {elapsed:.1f}s (pulados: {skipped_count} duplicatas)")
        
        # 9. Capturar screenshot da aba Pedidos (com timeout din√¢mico baseado na quantidade)
        if success_count > 0:
            await _take_pedidos_screenshot(page, process_id, success_count=success_count)
            update_status("pedidos_ok", f"‚úÖ {success_count} pedido(s) adicionado(s)", process_id=process_id)
        
        return success_count > 0
            
    except Exception as e:
        log(f"[PEDIDOS][RPA][ERRO] Falha ao adicionar pedidos: {e}")
        update_status("pedidos_erro", f"Erro ao adicionar pedidos: {e}", process_id=process_id)
        return False


# ‚úÖ CAT√ÅLOGO EST√ÅTICO DE TIPOS DE PEDIDOS DO ELAW (481 tipos)
# Gerado em 2025-11-27 a partir do dropdown #TipoPedidoId
# Usado para mapeamento inteligente sem precisar abrir modal

def _load_elaw_tipos_catalogo() -> list:
    """Carrega cat√°logo de tipos de pedidos do eLaw do arquivo JSON."""
    import json
    import os
    try:
        catalog_path = os.path.join(os.path.dirname(__file__), 'data', 'elaw_tipos_pedidos.json')
        with open(catalog_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        log(f"[PEDIDOS][CATALOG] Erro ao carregar cat√°logo: {e}")
        return []

# Cat√°logo em mem√≥ria (carregado uma vez)
_ELAW_TIPOS_CACHE = None

def _get_elaw_tipos_catalogo() -> list:
    """Retorna cat√°logo de tipos de pedidos (com cache)."""
    global _ELAW_TIPOS_CACHE
    if _ELAW_TIPOS_CACHE is None:
        _ELAW_TIPOS_CACHE = _load_elaw_tipos_catalogo()
    return _ELAW_TIPOS_CACHE

# ============================================================================
# üéØ SISTEMA INTELIGENTE DE PRIORIZA√á√ÉO DE PEDIDOS
# ============================================================================
# Estrat√©gia: Pedidos s√£o categorizados por import√¢ncia e priorizados
# quando o total excede o limite, garantindo que os mais relevantes
# sejam sempre inseridos primeiro.
# ============================================================================

# ‚úÖ LIMITE M√ÅXIMO DE PEDIDOS POR BATCH
# Este limite protege a estabilidade do RPA e evita sobrecarga do sistema eLaw.
# Pode ser ajustado conforme necessidade operacional.
MAX_PEDIDOS_PARA_INSERIR = 30  # Aumentado para 30 (limite seguro testado)

# ‚úÖ CATEGORIAS DE PRIORIDADE (peso 1-5, maior = mais importante)
# Verbas rescis√≥rias s√£o obrigat√≥rias em qualquer a√ß√£o trabalhista
CATEGORIA_PRIORIDADE = {
    # PRIORIDADE 5 - VERBAS RESCIS√ìRIAS ESSENCIAIS (sempre incluir)
    "rescisorias_essenciais": 5,
    # PRIORIDADE 4 - VERBAS SALARIAIS B√ÅSICAS
    "salariais_basicas": 4,
    # PRIORIDADE 3 - ADICIONAIS E EXTRAS
    "adicionais": 3,
    # PRIORIDADE 2 - INDENIZA√á√ïES E DANOS
    "indenizatorios": 2,
    # PRIORIDADE 1 - MULTAS E ACESS√ìRIOS
    "acessorios": 1,
}

# ‚úÖ KEYWORDS TRABALHISTAS COM CATEGORIAS E PRIORIDADES
# Cada keyword tem: [lista_de_termos, categoria, prioridade]
PEDIDO_KEYWORDS_PRIORITARIOS = {
    # === PRIORIDADE 5: RESCIS√ìRIAS ESSENCIAIS ===
    "saldo de sal√°rio": {
        "termos": ["saldo de sal√°rio", "saldo sal√°rio", "saldo de salario"],
        "categoria": "rescisorias_essenciais",
        "prioridade": 5
    },
    "aviso pr√©vio": {
        "termos": ["aviso pr√©vio", "aviso-pr√©vio", "aviso previo"],
        "categoria": "rescisorias_essenciais",
        "prioridade": 5
    },
    "13¬∫ sal√°rio": {
        "termos": ["13¬∫", "d√©cimo terceiro", "13 sal√°rio", "gratifica√ß√£o natalina"],
        "categoria": "rescisorias_essenciais",
        "prioridade": 5
    },
    "f√©rias": {
        "termos": ["f√©rias", "ferias", "ter√ßo de f√©rias", "1/3 de f√©rias"],
        "categoria": "rescisorias_essenciais",
        "prioridade": 5
    },
    "fgts": {
        "termos": ["fgts", "fundo de garantia", "multa 40%", "multa do fgts"],
        "categoria": "rescisorias_essenciais",
        "prioridade": 5
    },
    "seguro desemprego": {
        "termos": ["seguro desemprego", "seguro-desemprego", "guias sd"],
        "categoria": "rescisorias_essenciais",
        "prioridade": 5
    },
    
    # === PRIORIDADE 4: SALARIAIS B√ÅSICAS ===
    "horas extras": {
        "termos": ["hora extra", "horas extras", "sobrejornada", "jornada extraordin"],
        "categoria": "salariais_basicas",
        "prioridade": 4
    },
    "adicional noturno": {
        "termos": ["adicional noturno", "hor√°rio noturno"],
        "categoria": "salariais_basicas",
        "prioridade": 4
    },
    "equipara√ß√£o": {
        "termos": ["equipara√ß√£o salarial", "diferen√ßa salarial"],
        "categoria": "salariais_basicas",
        "prioridade": 4
    },
    "v√≠nculo": {
        "termos": ["v√≠nculo", "reconhecimento de v√≠nculo", "anota√ß√£o ctps"],
        "categoria": "salariais_basicas",
        "prioridade": 4
    },
    
    # === PRIORIDADE 3: ADICIONAIS ===
    "insalubridade": {
        "termos": ["insalubridade", "insalubre", "adicional de insalubridade"],
        "categoria": "adicionais",
        "prioridade": 3
    },
    "periculosidade": {
        "termos": ["periculosidade", "periculoso", "adicional de periculosidade"],
        "categoria": "adicionais",
        "prioridade": 3
    },
    "ac√∫mulo de fun√ß√£o": {
        "termos": ["ac√∫mulo de fun√ß√£o", "acumulo de funcao", "desvio de fun√ß√£o"],
        "categoria": "adicionais",
        "prioridade": 3
    },
    
    # === PRIORIDADE 2: INDENIZAT√ìRIOS ===
    "danos morais": {
        "termos": ["dano moral", "danos morais", "indeniza√ß√£o moral", "ass√©dio moral"],
        "categoria": "indenizatorios",
        "prioridade": 2
    },
    "danos materiais": {
        "termos": ["dano material", "danos materiais", "indeniza√ß√£o material"],
        "categoria": "indenizatorios",
        "prioridade": 2
    },
    
    # === PRIORIDADE 1: ACESS√ìRIOS ===
    "multa art 477": {
        "termos": ["multa 477", "art. 477", "artigo 477", "atraso rescis√£o"],
        "categoria": "acessorios",
        "prioridade": 1
    },
    "multa art 467": {
        "termos": ["multa 467", "art. 467", "artigo 467", "verbas incontroversas"],
        "categoria": "acessorios",
        "prioridade": 1
    },
    "honor√°rios": {
        "termos": ["honor√°rios", "honorarios", "sucumb√™ncia"],
        "categoria": "acessorios",
        "prioridade": 1
    },
    "justi√ßa gratuita": {
        "termos": ["justi√ßa gratuita", "gratuidade", "assist√™ncia judici√°ria"],
        "categoria": "acessorios",
        "prioridade": 1
    },
}

def _get_keyword_termos(keyword_name: str) -> list:
    """Retorna lista de termos para uma keyword (compatibilidade)."""
    info = PEDIDO_KEYWORDS_PRIORITARIOS.get(keyword_name, {})
    return info.get("termos", []) if isinstance(info, dict) else info

def _get_keyword_prioridade(keyword_name: str) -> int:
    """Retorna prioridade de uma keyword (1-5)."""
    info = PEDIDO_KEYWORDS_PRIORITARIOS.get(keyword_name, {})
    return info.get("prioridade", 1) if isinstance(info, dict) else 1

def _map_pedidos_with_catalog(pedidos_list: list, objeto: str = "") -> list:
    """
    Mapeia pedidos extra√≠dos do PDF para tipos do cat√°logo eLaw usando keywords.
    
    üöÄ OTIMIZADO 2025-11-27:
    - Usa cat√°logo est√°tico (481 tipos) sem precisar abrir modal
    - Matching por keywords priorit√°rias trabalhistas COM PRIORIZA√á√ÉO
    - Limite m√°ximo de MAX_PEDIDOS_PARA_INSERIR (30)
    - Ordena por prioridade (rescis√≥rias primeiro)
    - Log de pedidos omitidos quando excede limite
    
    Args:
        pedidos_list: Lista de pedidos extra√≠dos do PDF
        objeto: Objeto/assunto do processo
        
    Returns:
        Lista de dicts com {value, text, prioridade} dos tipos a selecionar
    """
    from rapidfuzz import fuzz
    
    catalogo = _get_elaw_tipos_catalogo()
    if not catalogo:
        log("[PEDIDOS][MAP] Cat√°logo vazio - usando fallback")
        return []
    
    texto_busca = " ".join(pedidos_list) + " " + objeto
    texto_busca_lower = texto_busca.lower()
    
    tipos_encontrados = []
    tipos_values_usados = set()
    
    log(f"[PEDIDOS][MAP] Mapeando {len(pedidos_list)} pedidos com cat√°logo de {len(catalogo)} tipos")
    
    # 1. FASE 1: Matching por keywords priorit√°rias (com prioriza√ß√£o)
    keywords_usadas = set()
    
    for tipo in catalogo:
        tipo_text_lower = tipo.get('text_lower', tipo.get('text', '').lower())
        tipo_value = tipo.get('value', '')
        tipo_text = tipo.get('text', '')
        
        if not tipo_value or tipo_value in tipos_values_usados:
            continue
        
        # Verificar match com keywords priorit√°rias
        for keyword_name, keyword_info in PEDIDO_KEYWORDS_PRIORITARIOS.items():
            if keyword_name in keywords_usadas:
                continue
            
            # Obter termos e prioridade da keyword
            termos = keyword_info.get("termos", []) if isinstance(keyword_info, dict) else keyword_info
            prioridade = keyword_info.get("prioridade", 1) if isinstance(keyword_info, dict) else 1
            categoria = keyword_info.get("categoria", "outros") if isinstance(keyword_info, dict) else "outros"
            
            keyword_found_in_pedidos = any(kw in texto_busca_lower for kw in termos)
            keyword_found_in_tipo = any(kw in tipo_text_lower for kw in termos)
            
            if keyword_found_in_pedidos and keyword_found_in_tipo:
                tipos_encontrados.append({
                    "value": tipo_value,
                    "text": tipo_text,
                    "prioridade": prioridade,
                    "categoria": categoria,
                    "score": prioridade * 20,  # Score baseado em prioridade
                    "match_type": "keyword",
                    "keyword": keyword_name
                })
                tipos_values_usados.add(tipo_value)
                keywords_usadas.add(keyword_name)
                log(f"[PEDIDOS][MAP] ‚úÖ P{prioridade} [{categoria}] '{keyword_name}' -> {tipo_text}")
                break
    
    # 2. FASE 2: Se poucos matches, usar fuzzy matching
    if len(tipos_encontrados) < 5 and pedidos_list:
        log(f"[PEDIDOS][MAP] Poucos matches ({len(tipos_encontrados)}) - usando fuzzy matching")
        
        for pedido in pedidos_list[:10]:
            pedido_lower = pedido.lower()[:100]
            
            for tipo in catalogo:
                tipo_value = tipo.get('value', '')
                tipo_text = tipo.get('text', '')
                tipo_text_lower = tipo.get('text_lower', tipo_text.lower())
                
                if tipo_value in tipos_values_usados:
                    continue
                
                score = fuzz.partial_ratio(pedido_lower, tipo_text_lower)
                
                if score >= 75:
                    tipos_encontrados.append({
                        "value": tipo_value,
                        "text": tipo_text,
                        "prioridade": 0,  # Fuzzy tem menor prioridade
                        "categoria": "fuzzy",
                        "score": score,
                        "match_type": "fuzzy"
                    })
                    tipos_values_usados.add(tipo_value)
                    log(f"[PEDIDOS][MAP] ‚úÖ P0 [fuzzy] ({score}%): {tipo_text[:50]}")
                    break
    
    # 3. ORDENAR POR PRIORIDADE (maior primeiro) e depois por score
    tipos_encontrados.sort(key=lambda x: (x.get('prioridade', 0), x.get('score', 0)), reverse=True)
    
    total_encontrado = len(tipos_encontrados)
    
    # 4. APLICAR LIMITE e LOGAR OMITIDOS
    if total_encontrado > MAX_PEDIDOS_PARA_INSERIR:
        tipos_omitidos = tipos_encontrados[MAX_PEDIDOS_PARA_INSERIR:]
        tipos_final = tipos_encontrados[:MAX_PEDIDOS_PARA_INSERIR]
        
        # ‚ö†Ô∏è LOG IMPORTANTE: Pedidos omitidos por exceder limite
        log(f"[PEDIDOS][MAP] ‚ö†Ô∏è LIMITE ATINGIDO: {total_encontrado} encontrados, inserindo {MAX_PEDIDOS_PARA_INSERIR}")
        log(f"[PEDIDOS][MAP] ‚ö†Ô∏è PEDIDOS OMITIDOS ({len(tipos_omitidos)}):")
        for omitido in tipos_omitidos:
            log(f"[PEDIDOS][MAP]    - P{omitido.get('prioridade', '?')} [{omitido.get('categoria', '?')}] {omitido.get('text', '?')}")
    else:
        tipos_final = tipos_encontrados
    
    # 5. Resumo por categoria
    categorias_count = {}
    for t in tipos_final:
        cat = t.get('categoria', 'outros')
        categorias_count[cat] = categorias_count.get(cat, 0) + 1
    
    log(f"[PEDIDOS][MAP] Total mapeado: {len(tipos_final)} tipos (m√°x {MAX_PEDIDOS_PARA_INSERIR})")
    log(f"[PEDIDOS][MAP] Por categoria: {categorias_count}")
    
    return tipos_final

async def _map_pedidos_to_tipos(page, pedidos_list: list, objeto: str) -> list:
    """
    Mapeia pedidos extra√≠dos do PDF para os tipos do select do eLaw.
    
    üöÄ OTIMIZADO 2025-11-27:
    - Primeiro tenta usar cat√°logo est√°tico (r√°pido, sem abrir modal)
    - Fallback para leitura do select se cat√°logo falhar
    - Limite m√°ximo de 25 pedidos
    
    Args:
        page: Playwright page
        pedidos_list: Lista de pedidos extra√≠dos
        objeto: Objeto/assunto do processo
        
    Returns:
        Lista de dicts com {value, text} dos tipos a selecionar
    """
    # ‚úÖ OTIMIZADO: Tentar usar cat√°logo est√°tico primeiro (muito mais r√°pido)
    tipos_from_catalog = _map_pedidos_with_catalog(pedidos_list, objeto)
    
    if tipos_from_catalog:
        log(f"[PEDIDOS][MAP] ‚úÖ Usando {len(tipos_from_catalog)} tipos do cat√°logo est√°tico")
        return tipos_from_catalog
    
    # ‚ùå FALLBACK: Se cat√°logo falhou, ler do select (mais lento)
    log("[PEDIDOS][MAP] Cat√°logo falhou - lendo tipos do select...")
    
    tipos_encontrados = []
    tipos_values_usados = set()
    keywords_usadas = set()  # ‚úÖ Deduplica√ß√£o por keyword tamb√©m no fallback
    
    texto_busca = " ".join(pedidos_list) + " " + objeto
    texto_busca_lower = texto_busca.lower()
    
    try:
        # Abrir modal para ter acesso ao select
        acoes_dropdown = page.locator('#box-pedidos .btn-group button.btn-acoes.dropdown-toggle').first
        await acoes_dropdown.click(timeout=5000)
        await short_sleep_ms(500)
        
        novo_pedido = page.locator('#buttonNewPedido')
        await novo_pedido.click(timeout=5000)
        
        await page.wait_for_selector('.modal.in #TipoPedidoId, .modal.show #TipoPedidoId', state='visible', timeout=5000)
        await page.wait_for_function("document.querySelector('#TipoPedidoId')?.options?.length > 1", timeout=5000)
        
        tipo_select = page.locator('#TipoPedidoId')
        options = await tipo_select.locator('option').all()
        log(f"[PEDIDOS][MAP] Total de op√ß√µes no select: {len(options)}")
        
        for option in options:
            option_text = await option.text_content()
            option_value = await option.get_attribute('value')
            
            if not option_value or option_value == "":
                continue
                
            option_lower = (option_text or "").lower()
            
            # Match por keywords priorit√°rias (com deduplica√ß√£o)
            for keyword_name, keywords in PEDIDO_KEYWORDS_PRIORITARIOS.items():
                # ‚úÖ Pular se j√° usamos essa keyword
                if keyword_name in keywords_usadas:
                    continue
                    
                if any(kw in texto_busca_lower for kw in keywords):
                    if any(kw in option_lower for kw in keywords):
                        if option_value not in tipos_values_usados:
                            tipos_encontrados.append({
                                "value": option_value,
                                "text": option_text
                            })
                            tipos_values_usados.add(option_value)
                            keywords_usadas.add(keyword_name)  # ‚úÖ Marcar keyword
                            log(f"[PEDIDOS][MAP] ‚úÖ Match: {keyword_name} -> {option_text}")
                            break  # ‚úÖ Sair do loop de keywords ap√≥s match
            
            if len(tipos_encontrados) >= MAX_PEDIDOS_PARA_INSERIR:
                break
        
        # Fechar modal
        try:
            await page.evaluate("document.querySelector('#dialog-modal button.close, .modal.in button.close')?.click()")
            await short_sleep_ms(300)
        except:
            pass
        
    except Exception as e:
        log(f"[PEDIDOS][MAP][WARN] Erro ao mapear tipos: {e}")
        try:
            await page.evaluate("document.querySelector('#dialog-modal button.close')?.click()")
        except:
            pass
    
    log(f"[PEDIDOS][MAP] Mapeados {len(tipos_encontrados)} tipos (m√°x {MAX_PEDIDOS_PARA_INSERIR})")
    return tipos_encontrados[:MAX_PEDIDOS_PARA_INSERIR]


def _compute_pedidos_wait_ms(success_count: int) -> int:
    """
    Calcula timeout din√¢mico baseado na quantidade de pedidos.
    F√≥rmula: base_ms + (per_item_ms * max(0, count - base_count))
    Clamped entre min_ms e max_ms.
    """
    base_ms = 1500      # Tempo base para poucos pedidos
    per_item_ms = 200   # 200ms extra por pedido acima do base
    base_count = 3      # Abaixo disso, usa apenas o base
    min_ms = 1500       # M√≠nimo de 1.5s
    max_ms = 15000      # M√°ximo de 15s (para ~60+ pedidos)
    
    extra_items = max(0, success_count - base_count)
    computed = base_ms + (per_item_ms * extra_items)
    result = max(min_ms, min(computed, max_ms))
    
    return result


async def _take_pedidos_screenshot(page, process_id: int, success_count: int = 1):
    """
    Captura screenshot da aba "Pedidos" ap√≥s inserir pedidos.
    Salva o caminho em Process.elaw_screenshot_pedidos_path.
    
    Args:
        page: Playwright page
        process_id: ID do processo
        success_count: Quantidade de pedidos inseridos (para timeout din√¢mico)
    """
    # ‚úÖ DYNAMIC TIMEOUT: Calcular timeout baseado na quantidade de pedidos
    dynamic_wait_ms = _compute_pedidos_wait_ms(success_count)
    log(f"[PEDIDOS][RPA][SHOT] Capturando screenshot da aba Pedidos (pedidos={success_count}, timeout={dynamic_wait_ms}ms)...")
    update_status("pedidos_screenshot", f"Capturando screenshot dos pedidos ({success_count} itens)...", process_id=process_id)
    
    try:
        # ‚úÖ MODAL CHECK: Garantir que nenhum modal est√° aberto antes de continuar
        for modal_attempt in range(3):
            try:
                modal_visible = await page.locator('.modal.in, .modal.show, #dialog-modal.in').first.is_visible()
                if modal_visible:
                    log(f"[PEDIDOS][RPA][SHOT] Modal detectado! Fechando (tentativa {modal_attempt + 1})...")
                    await page.evaluate("""() => {
                        // Fechar todos os modals abertos
                        document.querySelectorAll('.modal.in button.close, .modal.show button.close, #dialog-modal button.close').forEach(btn => btn.click());
                        // Remover backdrop tamb√©m
                        document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
                    }""")
                    await short_sleep_ms(1000)
                else:
                    log("[PEDIDOS][RPA][SHOT] ‚úÖ Nenhum modal aberto")
                    break
            except:
                break
        
        # Aguardar modals desaparecerem completamente
        try:
            await page.wait_for_selector('.modal.in, .modal.show', state='hidden', timeout=3000)
        except:
            pass
        
        # Garantir que aba est√° vis√≠vel (com timeout curto e fallback)
        try:
            await page.click('a[href="#box-pedidos"]', timeout=5000)
        except:
            log("[PEDIDOS][RPA][SHOT] Clique timeout - usando JavaScript...")
            await page.evaluate("""() => {
                const tab = document.querySelector('a[href="#box-pedidos"]');
                if (tab) tab.click();
            }""")
        await short_sleep_ms(1000)
        
        # ‚úÖ WAIT FOR ROWS: Aguardar at√© que a tabela tenha as linhas esperadas
        try:
            await page.wait_for_function(
                """(expectedCount) => {
                    const tbody = document.querySelector('#box-pedidos table tbody');
                    if (!tbody) return false;
                    const rows = tbody.querySelectorAll('tr');
                    return rows.length >= expectedCount;
                }""",
                arg=success_count,
                timeout=dynamic_wait_ms
            )
            log(f"[PEDIDOS][RPA][SHOT] ‚úÖ Tabela tem >= {success_count} linhas")
        except Exception as wait_ex:
            log(f"[PEDIDOS][RPA][SHOT] Timeout aguardando {success_count} linhas, continuando mesmo assim...")
        
        # ‚úÖ HEIGHT STABILIZATION: Aguardar estabiliza√ß√£o da altura da tabela
        try:
            await page.wait_for_function(
                """() => {
                    const container = document.querySelector('#box-pedidos');
                    if (!container) return true;
                    if (!window._lastHeight) {
                        window._lastHeight = container.scrollHeight;
                        return false;
                    }
                    if (container.scrollHeight !== window._lastHeight) {
                        window._lastHeight = container.scrollHeight;
                        return false;
                    }
                    return true;
                }""",
                timeout=3000
            )
            log("[PEDIDOS][RPA][SHOT] ‚úÖ Altura da tabela estabilizada")
        except:
            log("[PEDIDOS][RPA][SHOT] Height stabilization timeout, continuando...")
        
        # Pequeno delay final para garantir renderiza√ß√£o completa
        await short_sleep_ms(500)
        
        # Gerar nome do arquivo
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        screenshot_filename = f"process_{process_id}_{timestamp}_pedidos.png"
        
        screenshot_dir = Path("static") / "rpa_screenshots"
        screenshot_dir.mkdir(parents=True, exist_ok=True)
        screenshot_path = screenshot_dir / screenshot_filename
        
        await page.screenshot(path=str(screenshot_path), full_page=True)
        log(f"[PEDIDOS][RPA][SHOT] Screenshot salvo: {screenshot_path}")
        
        # Salvar no banco de dados
        if flask_app:
            from models import Process, db
            with flask_app.app_context():
                proc = Process.query.get(process_id)
                if proc:
                    proc.elaw_screenshot_pedidos_path = screenshot_filename
                    db.session.commit()
                    log(f"[PEDIDOS][RPA][SHOT] ‚úÖ Caminho salvo no banco: {screenshot_filename}")
        
        send_screenshot_to_monitor(screenshot_path, region="PEDIDOS")
        
    except Exception as e:
        log(f"[PEDIDOS][RPA][SHOT][ERRO] Falha ao capturar screenshot: {e}")


# =========================
# P√≥s-login / Orquestra√ß√£o
# =========================
async def ensure_on_new_process_form(page, process_id: int = None):
    """
    üîß BATCH FIX: Garante que estamos no formul√°rio 'Novo Processo' vazio.
    Critical para batch processing onde o browser √© reutilizado entre processos.
    Usa navega√ß√£o para about:blank para limpar TOTALMENTE o estado JS/DOM.
    """
    current_url = page.url
    form_url_pattern = r"/Processo/form"
    
    log("[BATCH] üßπ Limpando estado do navegador para novo processo...")
    if process_id:
        update_status("limpando_estado", "Limpando estado do navegador...", process_id=process_id)
    
    # 1. Navegar para about:blank para matar qualquer JS/AJAX pendente
    try:
        log("[BATCH][DEBUG] Passo 1: about:blank...")
        await page.goto("about:blank")
        await short_sleep_ms(200)
        log("[BATCH][DEBUG] Passo 1: OK")
    except Exception as e:
        log(f"[BATCH][DEBUG] Passo 1: falhou (ignorando): {e}")
        pass
    
    # 2. Voltar ao dashboard para garantir sess√£o logada (com detec√ß√£o de redirect para login)
    if process_id:
        update_status("verificando_sessao", "Verificando sess√£o logada...", process_id=process_id)
    max_dashboard_attempts = 3  # Aumentado de 2 para 3 tentativas
    for dashboard_attempt in range(max_dashboard_attempts):
        try:
            dashboard_url = BASE_URL.rstrip("/") + "/Home/Index"
            log(f"[BATCH] Navegando para dashboard (tentativa {dashboard_attempt + 1}/{max_dashboard_attempts}): {dashboard_url}")
            log(f"[BATCH][DEBUG] URL atual antes da navega√ß√£o: {page.url}")
            if process_id:
                update_status("navegando_dashboard", f"Acessando dashboard ({dashboard_attempt + 1}/{max_dashboard_attempts})...", process_id=process_id)
            await page.goto(dashboard_url, wait_until="domcontentloaded", timeout=180000)  # 180s (3 min) - igual ao login para produ√ß√£o
            
            # Verificar se fomos redirecionados para login
            current_url = page.url
            log(f"[BATCH][DEBUG] URL ap√≥s navega√ß√£o dashboard: {current_url}")
            if "/Account/Login" in current_url or "/Login" in current_url:
                log(f"[BATCH][WARN] Sess√£o expirada - redirecionado para login. Tentando relogar...")
                # N√£o temos credenciais aqui - precisamos que o caller tenha feito login
                # Lan√ßar erro para que o fluxo superior trate
                raise RuntimeError("Sess√£o expirada - necess√°rio fazer login novamente")
            
            # Verificar se navega√ß√£o foi bem-sucedida
            await page.wait_for_url(re.compile(r"/Home/Index"), timeout=5000)
            await short_sleep_ms(500)
            log(f"[BATCH] ‚úÖ Dashboard carregado com sucesso")
            break  # Sucesso - sair do loop
        except Exception as e:
            log(f"[BATCH][WARN] Tentativa {dashboard_attempt + 1} falhou: {e}")
            log(f"[BATCH][WARN] URL atual: {page.url}")
            
            if dashboard_attempt == max_dashboard_attempts - 1:
                # √öltima tentativa falhou - levantar erro
                log(f"[BATCH][ERROR] Todas as tentativas de navegar para o dashboard falharam")
                log(f"[BATCH][ERROR] √öltimo erro: {str(e)}")
                log(f"[BATCH][ERROR] URL final: {page.url}")
                raise RuntimeError(f"Falha ao garantir sess√£o logada ap√≥s {max_dashboard_attempts} tentativas: Page.goto: Timeout - verifique conex√£o com eLaw")
            
            # Tentar novamente ap√≥s pausa maior (produ√ß√£o pode precisar de mais tempo)
            wait_ms = 2000 * (dashboard_attempt + 1)  # 2s, 4s, 6s...
            log(f"[BATCH] Aguardando {wait_ms}ms antes de retry...")
            await short_sleep_ms(wait_ms)
    
    # 3. Navegar limpo para o formul√°rio
    target = BASE_URL.rstrip("/") + "/Processo/form"
    log(f"[BATCH] Navegando para formul√°rio: {target}")
    if process_id:
        update_status("abrindo_formulario", "Abrindo formul√°rio de novo processo...", process_id=process_id)
    
    try:
        await goto_with_retries(page, target, attempts=3, nav_timeout_ms=90000)  # 90s por tentativa, 3 tentativas
        log(f"[BATCH][DEBUG] Navega√ß√£o para form conclu√≠da, aguardando URL...")
        await page.wait_for_url(re.compile(form_url_pattern), timeout=60000)  # 60s - tolerante a redirecionamento lento
        log(f"[BATCH][DEBUG] URL do form confirmada, ajustando zoom...")
        await ensure_zoom_100(page, "form_batch")
        log("[BATCH] ‚úÖ Formul√°rio 'Novo Processo' aberto e limpo")
        if process_id:
            update_status("formulario_pronto", "Formul√°rio pronto para preenchimento", process_id=process_id)
    except Exception as e:
        log(f"[BATCH][ERROR] Falha ao abrir formul√°rio: {e}")
        raise

async def after_login_flow(page, process_id: int):
    """2025-11-21: process_id OBRIGAT√ìRIO (ZERO shared state)"""
    update_status("navegacao", "Acessando formul√°rio de cadastro", process_id=process_id)
    log(f"[FLOW][DEBUG] after_login_flow iniciado para processo #{process_id}")
    try:
        await page.wait_for_selector("nav, header, .navbar, .navbar-fixed-top", timeout=2500)
        log(f"[FLOW][DEBUG] Navbar detectada - sess√£o parece ativa")
    except Exception:
        log(f"[FLOW][DEBUG] Navbar n√£o encontrada - continuando mesmo assim")
        pass
    
    # üîß BATCH FIX: Garantir que estamos no formul√°rio vazio
    update_status("navegacao_form", "Preparando formul√°rio limpo...", process_id=process_id)
    log(f"[FLOW][DEBUG] Chamando ensure_on_new_process_form...")
    await ensure_on_new_process_form(page, process_id=process_id)
    log(f"[FLOW][DEBUG] ensure_on_new_process_form conclu√≠do")

    # Cat√°logos removidos para otimiza√ß√£o - n√£o s√£o necess√°rios para preenchimento
    log("[CATALOG] Snapshot de cat√°logos desabilitado para otimiza√ß√£o de velocidade")

    data = load_process_data_for_fill(process_id)
    if not data:
        log("[FORM][WARN] sem dados ‚Äî encerrando ap√≥s abrir formul√°rio")
        return

    # Carregar PDF ESPEC√çFICO do processo (evita mistura de dados entre processos)
    # Try/except permite execu√ß√£o com apenas dados do banco se PDF n√£o dispon√≠vel
    try:
        pdf_text = get_process_pdf_text(data, process_id=process_id)
        log(f"[PDF] ‚úÖ Texto do PDF carregado ({len(pdf_text)} chars)")
        data["_pdf_text"] = pdf_text
    except (ValueError, FileNotFoundError) as e:
        log(f"[PDF][WARN] PDF n√£o dispon√≠vel: {e}")
        log(f"[PDF][WARN] Continuando apenas com dados do banco de dados...")
        data["_pdf_text"] = ""  # Vazio - fun√ß√µes v√£o usar apenas dados do banco

    await fill_new_process_form(page, data, process_id=process_id)

# =========================
# Runner
# =========================
async def perform_login(page, user: str, pwd: str, process_id: int):
    """2025-11-21: process_id OBRIGAT√ìRIO"""
    ok = await login_elaw(page, user, pwd, BASE_URL)
    if not ok:
        try:
            png = _get_screenshot_path("elaw_login_form_nao_encontrado.png", process_id=process_id)
            await page.screenshot(path=str(png), full_page=True)
            log(f"[SHOT] login_falha: {png}")
        except Exception:
            pass
        raise RuntimeError("N√£o foi poss√≠vel efetuar o login no eLaw.")

async def run_elaw_login_once(process_id: int):
    """
    2025-11-21: process_id agora OBRIGAT√ìRIO (ZERO shared state)
    
    üîß 2025-12-02: Seta contextvar dentro do async para garantir propaga√ß√£o correta
    em execu√ß√µes paralelas via asyncio.run()
    """
    # ‚úÖ CR√çTICO: Setar contexto DENTRO da fun√ß√£o async para garantir propaga√ß√£o
    # asyncio.run() cria novo event loop, contextvars n√£o propagam automaticamente
    ctx = RPAExecutionContext(process_id=process_id)
    ctx_token = set_rpa_context(ctx)
    log(f"[RPA][ASYNC] Contexto setado dentro de run_elaw_login_once para processo #{process_id}")
    
    try:
        validate_env()
        _init_status(process_id)  # Inicializa sistema de status
        update_status("abrindo_navegador", "Abrindo navegador Chromium em modo headless...", process_id=process_id)
    
        # üîí CRITICAL: try/finally garante que status NUNCA fica 'running' ap√≥s RPA terminar
        async with launch_browser() as page:
            try:
                update_status("fazendo_login", "Fazendo login no eLaw...", process_id=process_id)
                await perform_login(page, ELAW_USER, ELAW_PASS, process_id)
                update_status("login_sucesso", "Login realizado com sucesso!", process_id=process_id)
                await after_login_flow(page, process_id=process_id)
                if KEEP_OPEN_AFTER_LOGIN_SECONDS > 0:
                    log(f"Janela aberta por {KEEP_OPEN_AFTER_LOGIN_SECONDS:.1f}s p/ inspe√ß√£o‚Ä¶")
                    await asyncio.sleep(KEEP_OPEN_AFTER_LOGIN_SECONDS)
            except Exception as e:
                error_msg = f"Erro durante execu√ß√£o do RPA: {str(e)}"
                update_status("erro", error_msg, status="error", process_id=process_id)
                
                # Enviar erro para monitor remoto
                log_error_to_monitor(error_msg, exc=e)
                
                # üîß FIX PROBLEMA 2: Capturar screenshot de erro E salvar em Process.elaw_screenshot_after_path
                screenshot_filename = None
                try:
                    png = _get_screenshot_path("elaw_flow_error.png", process_id=process_id)
                    await page.screenshot(path=str(png), full_page=True)
                    screenshot_filename = png.name  # Apenas nome do arquivo, sem path
                    log(f"[SHOT][ERRO] {png}")
                    send_screenshot_to_monitor(png, region="RPA_ERROR")
                except Exception as screenshot_ex:
                    log(f"[SHOT][ERRO] Falha ao capturar screenshot: {screenshot_ex}")
                
                # Atualizar status de erro no banco de dados + screenshot
                if process_id and flask_app:
                    try:
                        from models import Process, db
                        with flask_app.app_context():
                            proc = Process.query.get(process_id)
                            if proc:
                                proc.elaw_status = 'error'
                                proc.elaw_error_message = error_msg
                                
                                # üéØ CRITICAL: Salvar screenshot de erro para UI exibir bot√£o
                                # ‚úÖ FIX: Salvar APENAS o nome do arquivo.
                                if screenshot_filename:
                                    proc.elaw_screenshot_after_path = screenshot_filename
                                    log(f"[SCREENSHOT ERROR] ‚úÖ Caminho salvo no banco: {proc.elaw_screenshot_after_path}")
                                
                                db.session.commit()
                                log(f"[RPA][ERROR] Processo #{process_id} marcado como 'error': {error_msg}")
                    except Exception as ex:
                        log(f"[RPA][WARN] N√£o foi poss√≠vel atualizar status de erro no banco: {ex}")
                if not HEADLESS:
                    log("[ERRO] Mantendo navegador aberto por 120s para inspe√ß√£o‚Ä¶")
                    try:
                        await asyncio.sleep(120)
                    except Exception:
                        pass
                raise
            
            # Sucesso - atualiza status final (APENAS se n√£o foi marcado como erro antes)
            update_status("concluido", "Processo preenchido com sucesso no eLaw!", status="completed", process_id=process_id)
            
            # Atualizar status do processo no banco de dados - FINAL DO FLUXO COMPLETO
            if process_id and flask_app:
                try:
                    from models import Process, db
                    from datetime import datetime
                    with flask_app.app_context():
                        proc = Process.query.get(process_id)
                        if proc:
                            # ‚úÖ AGORA √© o momento certo de definir 'success'
                            # Status v√°lidos para atualiza√ß√£o: running, processing (intermedi√°rio)
                            if proc.elaw_status in ('running', 'processing'):
                                proc.elaw_status = 'success'
                                proc.status = 'completed'
                                proc.elaw_filled_at = datetime.utcnow()
                                proc.elaw_error_message = None
                                db.session.commit()
                                log(f"[RPA][SUCCESS] ‚úÖ Processo #{process_id} marcado como 'success' / 'completed' (fluxo completo)")
                            elif proc.elaw_status == 'error':
                                log(f"[RPA][SUCCESS] Processo #{process_id} j√° tinha status 'error' - mantendo")
                            else:
                                log(f"[RPA][SUCCESS] Processo #{process_id} j√° tinha status: {proc.elaw_status} - mantendo")
                except Exception as e:
                    log(f"[RPA][WARN] N√£o foi poss√≠vel atualizar status no banco: {e}")
    
    finally:
        # üîí WATCHDOG FINAL: Garante que status NUNCA fica 'running' ou 'processing' se RPA terminou
        # Isso captura crashes, timeouts, SIGKILL, browser crash, etc
        if process_id and flask_app:
            try:
                from models import Process, db
                with flask_app.app_context():
                    proc = Process.query.get(process_id)
                    if proc and proc.elaw_status in ('running', 'processing'):
                        # Se chegou aqui com status intermedi√°rio, algo deu errado
                        proc.elaw_status = 'error'
                        proc.elaw_error_message = proc.elaw_error_message or 'RPA finalizou inesperadamente sem atualizar status'
                        db.session.commit()
                        log(f"[RPA][WATCHDOG] ‚ö†Ô∏è Processo #{process_id} estava '{proc.elaw_status}' ao finalizar - marcado como 'error'")
            except Exception as ex:
                log(f"[RPA][WATCHDOG][ERROR] N√£o foi poss√≠vel executar watchdog final: {ex}")
        
        # ‚úÖ NOTA: N√ÉO fazemos cleanup manual de contextvars aqui!
        # O pr√≥prio asyncio.run() descarta automaticamente o contexto ao finalizar,
        # garantindo isolamento completo entre processos do batch sem race conditions.
        # Cleanup manual causaria que watchdogs/error handlers perdessem o contexto.

def run_elaw_login_sync(process_id: int):
    """
    2025-11-21: process_id OBRIGAT√ìRIO
    Op√ß√£o B: Seta _current_process_id + usa mutex para prevenir concorr√™ncia
    """
    # üîí MUTEX: Prevenir execu√ß√µes concorrentes (CLI pode rodar junto com web/batch)
    with _execute_rpa_lock:
        global _current_process_id
        _current_process_id = process_id
        log(f"[RPA] Lock adquirido + _current_process_id setado para #{process_id} (entry point: run_elaw_login_sync)")
        
        try:
            asyncio.run(run_elaw_login_once(process_id))
        finally:
            _current_process_id = None
            log(f"[RPA] _current_process_id limpo ap√≥s run_elaw_login_sync")


def execute_rpa(process_id: int) -> dict:
    """
    Fun√ß√£o reutiliz√°vel para executar RPA completo em um processo.
    Pode ser chamada por routes.py (interface web) ou celery_tasks.py (batch).
    
    THREAD-SAFE: Usa _execute_rpa_lock para prevenir execu√ß√µes concorrentes (web + batch)
    
    Args:
        process_id: ID do processo no banco de dados
        
    Returns:
        dict com {
            'status': 'success' | 'error',
            'process_id': int,
            'message': str,
            'error': str (opcional)
        }
    """
    # üîí MUTEX: Prevenir execu√ß√µes concorrentes (web + batch simult√¢neos)
    with _execute_rpa_lock:
        log(f"[EXECUTE_RPA] Lock adquirido para processo #{process_id}")
        
        # ‚úÖ OP√á√ÉO B: Setar global no IN√çCIO (isolamento sequencial)
        global _current_process_id
        _current_process_id = process_id
        log(f"[EXECUTE_RPA] _current_process_id setado para #{process_id}")
        
        try:
            # Inicializar RPA Monitor (se habilitado)
            _init_rpa_monitor()
            
            log(f"[EXECUTE_RPA] Iniciando RPA para processo #{process_id} (Op√ß√£o B: global sequencial)")
            
            # ‚ö†Ô∏è CR√çTICO: Chamar asyncio.run diretamente (N√ÉO run_elaw_login_sync) para evitar deadlock de mutex recursivo
            asyncio.run(run_elaw_login_once(process_id))
            
            # Verificar status REAL do processo no banco ap√≥s execu√ß√£o
            if not flask_app:
                raise Exception("Flask app n√£o dispon√≠vel - n√£o √© poss√≠vel verificar status")
            
            from models import Process, db
            
            with flask_app.app_context():
                proc = Process.query.get(process_id)
                if not proc:
                    raise Exception(f"Processo #{process_id} n√£o encontrado ap√≥s RPA")
                
                # Retornar baseado no status REAL gravado pelo RPA
                if proc.elaw_status == 'success':
                    return {
                        'status': 'success',
                        'process_id': process_id,
                        'message': f'Processo #{process_id} preenchido com sucesso no eLaw'
                    }
                elif proc.elaw_status == 'error':
                    return {
                        'status': 'error',
                        'process_id': process_id,
                        'message': proc.elaw_error_message or 'Erro durante execu√ß√£o do RPA',
                        'error': proc.elaw_error_message
                    }
                else:
                    # Status inesperado (running, pending, etc)
                    log(f"[EXECUTE_RPA][WARNING] Status inesperado ap√≥s RPA: {proc.elaw_status}")
                    return {
                        'status': 'error',
                        'process_id': process_id,
                        'message': f'RPA finalizou com status inesperado: {proc.elaw_status}',
                        'error': f'Status final: {proc.elaw_status}'
                    }
        
        except Exception as e:
            error_msg = f"Erro ao executar RPA para processo #{process_id}: {str(e)}"
            log(f"[EXECUTE_RPA][ERROR] {error_msg}")
            log_error_to_monitor(error_msg, exc=e)
            
            # üîí CRITICAL: Atualizar status para error (para n√£o ficar "running")
            # Usa registry lookup para garantir que funciona mesmo fora de async context
            update_status("erro_fatal", f"Erro fatal durante execu√ß√£o: {str(e)[:200]}", status="error", process_id=process_id)
            
            # Tamb√©m atualizar no banco
            if flask_app:
                try:
                    from models import Process, db
                    with flask_app.app_context():
                        proc = Process.query.get(process_id)
                        if proc and proc.elaw_status == 'running':
                            proc.elaw_status = 'error'
                            proc.elaw_error_message = str(e)[:500]
                            db.session.commit()
                            log(f"[EXECUTE_RPA] Processo #{process_id} marcado como 'error' no banco")
                except Exception as ex:
                    log(f"[EXECUTE_RPA][WARN] Erro ao atualizar status no banco: {ex}")
            
            return {
                'status': 'error',
                'process_id': process_id,
                'message': 'Erro durante execu√ß√£o do RPA',
                'error': str(e)
            }
        
        finally:
            # ‚úÖ OP√á√ÉO B: Limpar global ap√≥s execu√ß√£o (isolamento sequencial)
            _current_process_id = None
            log(f"[EXECUTE_RPA] Finalizado para processo #{process_id}, _current_process_id limpo")


def execute_rpa_parallel(process_id: int, worker_id: Optional[int] = None) -> dict:
    """
    üÜï 2025-11-27: Fun√ß√£o para execu√ß√£o PARALELA de RPA.
    
    Diferente de execute_rpa(), esta fun√ß√£o:
    1. Usa contextvars (thread-local) em vez de globals
    2. Usa sem√°foro em vez de mutex (permite N execu√ß√µes simult√¢neas)
    3. Cada worker tem seu pr√≥prio browser isolado
    4. Screenshots usam prefixo √∫nico por worker
    
    Pode ser chamada por m√∫ltiplas threads simultaneamente de forma segura.
    
    Args:
        process_id: ID do processo no banco de dados
        worker_id: ID opcional do worker (para logs e screenshots)
        
    Returns:
        dict com {
            'status': 'success' | 'error',
            'process_id': int,
            'worker_id': int | None,
            'message': str,
            'error': str (opcional)
        }
    """
    # Criar contexto thread-local para esta execu√ß√£o
    ctx = RPAExecutionContext(
        process_id=process_id,
        worker_id=worker_id
    )
    
    # Setar contexto na thread atual
    ctx_token = set_rpa_context(ctx)
    
    log(f"[EXECUTE_RPA_PARALLEL] Worker {worker_id} iniciando processo #{process_id}")
    
    # üîí SEM√ÅFORO: Permite at√© MAX_RPA_WORKERS execu√ß√µes simult√¢neas
    acquired = _execute_rpa_semaphore.acquire(blocking=True, timeout=300)  # 5 min timeout
    if not acquired:
        log(f"[EXECUTE_RPA_PARALLEL] Timeout ao aguardar sem√°foro para processo #{process_id}")
        reset_rpa_context(ctx_token)
        return {
            'status': 'error',
            'process_id': process_id,
            'worker_id': worker_id,
            'message': 'Timeout aguardando slot dispon√≠vel para RPA',
            'error': 'Semaphore timeout'
        }
    
    log(f"[EXECUTE_RPA_PARALLEL] Worker {worker_id} adquiriu sem√°foro para processo #{process_id}")
    
    try:
        # Inicializar RPA Monitor (se habilitado)
        _init_rpa_monitor()
        
        log(f"[EXECUTE_RPA_PARALLEL] Iniciando RPA paralelo para processo #{process_id} (worker={worker_id})")
        
        # Executar RPA - cada thread tem seu pr√≥prio event loop via asyncio.run()
        asyncio.run(run_elaw_login_once(process_id))
        
        # Verificar status REAL do processo no banco ap√≥s execu√ß√£o
        if not flask_app:
            raise Exception("Flask app n√£o dispon√≠vel - n√£o √© poss√≠vel verificar status")
        
        from models import Process, db
        
        with flask_app.app_context():
            proc = Process.query.get(process_id)
            if not proc:
                # Limpar sess√£o antes de lan√ßar exce√ß√£o
                db.session.remove()
                raise Exception(f"Processo #{process_id} n√£o encontrado ap√≥s RPA")
            
            # Capturar dados antes de limpar sess√£o
            elaw_status = proc.elaw_status
            elaw_error_message = proc.elaw_error_message
            
            # ‚úÖ CR√çTICO: Limpar sess√£o IMEDIATAMENTE ap√≥s leitura, ANTES do return
            db.session.remove()
        
        # Retornar baseado no status REAL gravado pelo RPA (fora do app_context)
        if elaw_status == 'success':
            return {
                'status': 'success',
                'process_id': process_id,
                'worker_id': worker_id,
                'message': f'Processo #{process_id} preenchido com sucesso no eLaw'
            }
        elif elaw_status == 'error':
            return {
                'status': 'error',
                'process_id': process_id,
                'worker_id': worker_id,
                'message': elaw_error_message or 'Erro durante execu√ß√£o do RPA',
                'error': elaw_error_message
            }
        else:
            # Status inesperado (running, pending, etc)
            log(f"[EXECUTE_RPA_PARALLEL][WARNING] Status inesperado ap√≥s RPA: {elaw_status}")
            return {
                'status': 'error',
                'process_id': process_id,
                'worker_id': worker_id,
                'message': f'RPA finalizou com status inesperado: {elaw_status}',
                'error': f'Status final: {elaw_status}'
            }
    
    except Exception as e:
        error_msg = f"Erro ao executar RPA paralelo para processo #{process_id}: {str(e)}"
        log(f"[EXECUTE_RPA_PARALLEL][ERROR] {error_msg}")
        log_error_to_monitor(error_msg, exc=e)
        
        # üîí CRITICAL: Atualizar status para error (para n√£o ficar "running")
        update_status("erro_fatal", f"Erro fatal durante execu√ß√£o: {str(e)[:200]}", status="error", process_id=process_id)
        
        # Tamb√©m atualizar no banco
        if flask_app:
            try:
                from models import Process, db
                with flask_app.app_context():
                    proc = Process.query.get(process_id)
                    if proc and proc.elaw_status == 'running':
                        proc.elaw_status = 'error'
                        proc.elaw_error_message = str(e)[:500]
                        db.session.commit()
                        log(f"[EXECUTE_RPA_PARALLEL] Processo #{process_id} marcado como 'error' no banco")
                    # ‚úÖ CR√çTICO: Limpar sess√£o ap√≥s uso
                    db.session.remove()
            except Exception as ex:
                log(f"[EXECUTE_RPA_PARALLEL][WARN] Erro ao atualizar status no banco: {ex}")
        
        return {
            'status': 'error',
            'process_id': process_id,
            'worker_id': worker_id,
            'message': 'Erro durante execu√ß√£o do RPA',
            'error': str(e)
        }
    
    finally:
        # ‚úÖ CR√çTICO: Garantir limpeza da sess√£o DB em TODOS os casos
        # Isso √© uma salvaguarda - as fun√ß√µes acima j√° limpam, mas
        # se houver exce√ß√£o inesperada entre a limpeza e o return, isso protege
        if flask_app:
            try:
                from models import db
                with flask_app.app_context():
                    db.session.remove()
            except Exception:
                pass  # Ignorar erros de limpeza no finally
        
        # ‚úÖ Liberar sem√°foro
        _execute_rpa_semaphore.release()
        log(f"[EXECUTE_RPA_PARALLEL] Worker {worker_id} liberou sem√°foro para processo #{process_id}")
        
        # ‚úÖ Resetar contexto thread-local
        reset_rpa_context(ctx_token)
        log(f"[EXECUTE_RPA_PARALLEL] Contexto resetado para processo #{process_id}")


if __name__ == "__main__":
    try:
        pid = int(ENV_PROCESS_ID) if ENV_PROCESS_ID.isdigit() else None
        log(f"[RPA][IN√çCIO] Iniciando RPA com process_id={pid}, headless={HEADLESS}")
        log(f"[RPA][CONFIG] Timeouts: DEFAULT={DEFAULT_TIMEOUT_MS}ms, NAV={NAV_TIMEOUT_MS}ms")
        run_elaw_login_sync(pid)
    except Exception as e:
        log(f"[RPA][ERRO] {e}")
        import traceback
        log(f"[RPA][TRACEBACK] {traceback.format_exc()}")



================================================================================
FILE: rpa_status.py
================================================================================
"""
Sistema de status compartilhado para acompanhar progresso do RPA em tempo real.
Usa banco de dados SQLite para persist√™ncia robusta e evitar race conditions.
"""
import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any


class RPAStatusManager:
    """Gerencia o status de um processo RPA usando banco de dados"""
    
    def __init__(self, process_id: int):
        self.process_id = process_id
        
    def update(self, step: str, message: str, status: str = "running", data: Optional[Dict[str, Any]] = None):
        """
        Atualiza o status do RPA no banco de dados.
        
        Args:
            step: Nome da etapa (ex: "login", "preenchendo_cnj", "salvando")
            message: Mensagem descritiva (ex: "Fazendo login no eLaw")
            status: Status geral (starting, running, completed, error)
            data: Dados adicionais (valor preenchido, etc)
        """
        # Importa√ß√£o local para evitar circular imports
        from extensions import db
        from models import RPAStatus
        from flask import has_app_context
        
        def _do_update():
            # Busca registro existente ou cria novo
            rpa_status = RPAStatus.query.filter_by(process_id=self.process_id).first()
            
            if not rpa_status:
                rpa_status = RPAStatus(process_id=self.process_id)
                db.session.add(rpa_status)
            
            # Atualiza campos principais
            rpa_status.status = status
            rpa_status.current_step = step
            rpa_status.message = message
            rpa_status.data_json = json.dumps(data or {}, ensure_ascii=False)
            
            # Atualiza hist√≥rico
            history = []
            if rpa_status.history_json:
                try:
                    history = json.loads(rpa_status.history_json)
                except Exception:
                    history = []
            
            history.append({
                "step": step,
                "message": message,
                "timestamp": datetime.now().isoformat(),
                "data": data or {}
            })
            
            rpa_status.history_json = json.dumps(history, ensure_ascii=False)
            
            # Commit no banco
            db.session.commit()
            
            # Log no console
            print(f"‚úÖ [RPA] {step}: {message}")
            if data:
                print(f"   üìä {json.dumps(data, ensure_ascii=False)}")
        
        try:
            # Se j√° estiver em um contexto Flask, executa diretamente
            if has_app_context():
                _do_update()
            else:
                # Cria contexto do Flask para threads isoladas
                from main import app
                with app.app_context():
                    _do_update()
                
        except Exception as e:
            print(f"‚ùå [RPA STATUS ERROR] Falha ao atualizar status: {e}")
            # N√£o falha o RPA se n√£o conseguir atualizar status
            try:
                db.session.rollback()
            except Exception:
                pass
    
    def get_status(self) -> Optional[Dict[str, Any]]:
        """Retorna o status atual do RPA do banco de dados"""
        from models import RPAStatus, Process
        from flask import has_app_context
        
        def _do_get():
            rpa_status = RPAStatus.query.filter_by(process_id=self.process_id).first()
            
            if not rpa_status:
                return None
            
            # Converte para dict
            history = []
            if rpa_status.history_json:
                try:
                    history = json.loads(rpa_status.history_json)
                except Exception:
                    pass
            
            data = {}
            if rpa_status.data_json:
                try:
                    data = json.loads(rpa_status.data_json)
                except Exception:
                    pass
            
            # Busca dados do Process para incluir screenshots
            process = Process.query.get(self.process_id)
            
            # ‚úÖ PRIORIZAR status do Process quando RPA j√° terminou
            final_status = rpa_status.status
            final_message = rpa_status.message
            
            if process:
                if process.elaw_status == 'success':
                    final_status = 'completed'
                    final_message = 'Conclu√≠do com sucesso'
                elif process.elaw_status == 'error':
                    final_status = 'error'
                    final_message = process.elaw_error_message or 'Erro no preenchimento'
                elif process.elaw_status == 'processing':
                    final_status = 'running'
                    final_message = rpa_status.message or 'Preenchendo reclamadas e pedidos...'
            
            result = {
                "process_id": rpa_status.process_id,
                "status": final_status,
                "current_step": rpa_status.current_step,
                "message": final_message,
                "data": data,
                "history": history,
                "timestamp": rpa_status.updated_at.isoformat()
            }
            
            if process:
                result["elaw_screenshot_path"] = process.elaw_screenshot_path
                result["elaw_screenshot_before_path"] = process.elaw_screenshot_before_path
                result["elaw_screenshot_after_path"] = process.elaw_screenshot_after_path
                result["elaw_screenshot_reclamadas_path"] = process.elaw_screenshot_reclamadas_path
                result["elaw_screenshot_pedidos_path"] = process.elaw_screenshot_pedidos_path
                result["elaw_detail_url"] = process.elaw_detail_url
            
            return result
        
        try:
            if has_app_context():
                return _do_get()
            else:
                from main import app
                with app.app_context():
                    return _do_get()
        except Exception as e:
            print(f"‚ùå [RPA STATUS ERROR] Falha ao buscar status: {e}")
            return None
    
    def clear(self):
        """Remove o registro de status do banco"""
        from extensions import db
        from models import RPAStatus
        from flask import has_app_context
        
        def _do_clear():
            rpa_status = RPAStatus.query.filter_by(process_id=self.process_id).first()
            if rpa_status:
                db.session.delete(rpa_status)
                db.session.commit()
        
        try:
            if has_app_context():
                _do_clear()
            else:
                from main import app
                with app.app_context():
                    _do_clear()
        except Exception as e:
            print(f"‚ùå [RPA STATUS ERROR] Falha ao limpar status: {e}")
            try:
                db.session.rollback()
            except Exception:
                pass


def get_rpa_status(process_id: int) -> Optional[Dict[str, Any]]:
    """Fun√ß√£o helper para buscar status de um processo"""
    manager = RPAStatusManager(process_id)
    return manager.get_status()


def update_status(step: str, message: str, status: str = "running", process_id: int = None, data: Optional[Dict[str, Any]] = None):
    """
    Fun√ß√£o utilit√°ria para atualizar status do RPA sem precisar instanciar o manager.
    Compat√≠vel com chamadas legadas que usam process_id como kwarg.
    
    Args:
        step: Nome da etapa (ex: "login", "preenchendo_cnj")
        message: Mensagem descritiva
        status: Status geral (starting, running, completed, error)
        process_id: ID do processo (opcional - se None, apenas loga)
        data: Dados adicionais opcionais
    """
    if process_id:
        manager = RPAStatusManager(process_id)
        manager.update(step, message, status, data)
    else:
        # Se n√£o tem process_id, apenas loga no console
        print(f"‚úÖ [RPA] {step}: {message}")


def cleanup_old_statuses(days_old: int = 7):
    """Remove status RPA antigos (conclu√≠dos h√° mais de X dias)"""
    from extensions import db
    from models import RPAStatus
    
    try:
        cutoff = datetime.now() - timedelta(days=days_old)
        old_statuses = RPAStatus.query.filter(
            RPAStatus.status.in_(["completed", "error"]),
            RPAStatus.updated_at < cutoff
        ).all()
        
        for status in old_statuses:
            db.session.delete(status)
        
        db.session.commit()
        print(f"üßπ Limpeza: removidos {len(old_statuses)} status antigos")
    except Exception as e:
        print(f"‚ùå Erro na limpeza de status: {e}")
        try:
            db.session.rollback()
        except Exception:
            pass



================================================================================
FILE: monitor_integration.py
================================================================================
"""
M√≥dulo de integra√ß√£o global do RPA Monitor Client
Permite enviar logs, erros e screenshots para monitoramento remoto em tempo real
"""

import logging
import os
import sys
from pathlib import Path
from typing import Optional

# Adicionar caminho do rpa_monitor_client ao sys.path
sys.path.insert(0, '/home/runner/workspace/rpa_monitor_client/rpa_monitor_client')

# Importar cliente do monitor
try:
    from rpa_monitor_client import auto_setup_rpa_monitor, rpa_log
    MONITOR_AVAILABLE = True
except ImportError:
    MONITOR_AVAILABLE = False
    rpa_log = None

LOG = logging.getLogger(__name__)

# Estado de inicializa√ß√£o do monitor
_monitor_initialized = False

def init_monitor(rpa_id: Optional[str] = None) -> bool:
    """
    Inicializa o RPA Monitor usando vari√°veis de ambiente
    Conecta imediatamente ao servidor para aparecer como "ativo"
    
    Args:
        rpa_id: ID do RPA (opcional, usa RPA_MONITOR_ID do .env se n√£o especificado)
    
    Returns:
        True se inicializado com sucesso, False caso contr√°rio
    """
    global _monitor_initialized
    
    LOG.info("[MONITOR] Iniciando integra√ß√£o do RPA Monitor...")
    
    if not MONITOR_AVAILABLE:
        LOG.warning("[MONITOR] rpa-monitor-client n√£o dispon√≠vel")
        return False
    
    # Verificar se est√° habilitado
    enabled = os.getenv("RPA_MONITOR_ENABLED", "false").lower() == "true"
    monitor_id = rpa_id or os.getenv("RPA_MONITOR_ID", "RPA-FGbularmaci-5")
    monitor_host = os.getenv("RPA_MONITOR_HOST", "")
    monitor_region = os.getenv("RPA_MONITOR_REGION", "Sistema Juridico")
    monitor_transport = os.getenv("RPA_MONITOR_TRANSPORT", "ws")
    
    LOG.debug(f"[MONITOR] Configura√ß√£o: enabled={enabled}, id={monitor_id}, region={monitor_region}")
    
    if not enabled:
        LOG.info("[MONITOR] Monitor desabilitado via RPA_MONITOR_ENABLED")
        return False
    
    if not monitor_host:
        LOG.warning("[MONITOR] RPA_MONITOR_HOST n√£o configurado")
        return False
    
    try:
        # Configurar RPA_MONITOR_ID se fornecido
        if rpa_id:
            os.environ["RPA_MONITOR_ID"] = rpa_id
        
        LOG.info(f"[MONITOR] Conectando ao servidor de monitoramento: {monitor_host[:60]}...")
        
        # Inicializar usando auto_setup (l√™ vari√°veis de ambiente)
        auto_setup_rpa_monitor()
        _monitor_initialized = True
        
        LOG.info(f"[MONITOR] ‚úÖ Conectado com sucesso: {monitor_id} @ {monitor_region}")
        
        # Enviar log inicial para confirmar conex√£o
        try:
            rpa_log.info(f"Sistema {monitor_id} iniciado e conectado ao monitor")
        except Exception as e:
            LOG.debug(f"[MONITOR] N√£o foi poss√≠vel enviar log inicial: {e}")
        
        return True
        
    except Exception as e:
        LOG.error(f"[MONITOR] Erro ao inicializar: {e}", exc_info=True)
        _monitor_initialized = False
        return False

def log_info(message: str, region: str = "SYSTEM"):
    """
    Envia log de informa√ß√£o para o monitor
    
    Args:
        message: Mensagem de log
        region: Regi√£o/m√≥dulo que originou o log
    """
    if _monitor_initialized and rpa_log:
        try:
            rpa_log.info(f"[{region}] {message}")
        except Exception:
            pass  # N√£o quebrar execu√ß√£o se monitor falhar

def log_error(message: str, exc: Optional[Exception] = None, region: str = "SYSTEM"):
    """
    Envia log de erro para o monitor
    
    Args:
        message: Mensagem de erro
        exc: Exce√ß√£o capturada (opcional)
        region: Regi√£o/m√≥dulo que originou o erro
    """
    if _monitor_initialized and rpa_log:
        try:
            full_message = f"[{region}] {message}"
            if exc:
                rpa_log.error(full_message, exc=exc)
            else:
                rpa_log.error(full_message)
        except Exception:
            pass  # N√£o quebrar execu√ß√£o se monitor falhar

def send_screenshot(screenshot_path: Path, region: str = "SYSTEM"):
    """
    Envia screenshot PNG para o monitor
    
    Args:
        screenshot_path: Caminho do arquivo PNG existente
        region: Regi√£o/m√≥dulo que gerou o screenshot
    """
    if not _monitor_initialized:
        return
    
    try:
        # Converter para Path se necess√°rio
        if isinstance(screenshot_path, str):
            screenshot_path = Path(screenshot_path)
        
        # Verificar se arquivo existe
        if not screenshot_path.exists():
            LOG.warning(f"[MONITOR] Screenshot n√£o existe: {screenshot_path}")
            return
        
        # Importar m√≥dulo interno do rpa_monitor_client
        import sys
        sys.path.insert(0, str(Path(__file__).parent / 'rpa_monitor_client' / 'rpa_monitor_client'))
        from rpa_monitor_client import _logging_api
        
        # Acessar inst√¢ncia do cliente via _logging_api
        client_instance = _logging_api._client_instance
        
        if not client_instance:
            LOG.warning(f"[MONITOR] Cliente n√£o inicializado para enviar screenshot")
            return
        
        # Ler arquivo PNG do disco
        image_bytes = screenshot_path.read_bytes()
        
        # Enviar diretamente via send_image() do cliente
        client_instance.send_image(
            image_bytes=image_bytes,
            content_type="image/png",
            filename=screenshot_path.name,
            regiao=region,
            nivel="INFO"
        )
        
        LOG.info(f"[MONITOR] üì∏ Screenshot enviado: {screenshot_path.name} ({screenshot_path.stat().st_size} bytes)")
        
    except Exception as e:
        LOG.warning(f"[MONITOR] Erro ao enviar screenshot: {e}")

def is_initialized() -> bool:
    """Retorna True se o monitor foi inicializado com sucesso"""
    return _monitor_initialized



================================================================================
FILE: gunicorn.conf.py
================================================================================
"""
Gunicorn configuration for Flask legal process management system
Increases timeout for long-running AI PDF processing operations
"""

# Server socket
bind = "0.0.0.0:5000"

# Worker processes
workers = 1
worker_class = "sync"

# Timeout configurations
# Increased from default 30s to 300s (5 minutes) to handle large PDF processing
timeout = 300
graceful_timeout = 300
keepalive = 5

# Server mechanics
daemon = False
pidfile = None
user = None
group = None
tmp_upload_dir = None

# Logging
accesslog = "-"
errorlog = "-"
loglevel = "info"
access_log_format = '%(h)s %(l)s %(u)s %(t)s "%(r)s" %(s)s %(b)s "%(f)s" "%(a)s"'

# Process naming
proc_name = "legal_process_app"

# Server hooks
def on_starting(server):
    print("[GUNICORN] Starting with timeout: 300s")

def on_reload(server):
    print("[GUNICORN] Reloading configuration")

def worker_int(worker):
    print(f"[GUNICORN] Worker {worker.pid} received INT or QUIT signal")

# Reload
reload = True
reload_engine = "auto"



================================================================================
FILE: extractors/__init__.py
================================================================================
# -*- coding: utf-8 -*-
"""
Interface p√∫blica est√°vel do pacote `extractors`.

Exporta sempre:
    extract_text_from_pdf
    run_extraction_from_text
    run_extraction_from_file
    run_pipeline            (alias seguro; usa o pipeline se dispon√≠vel)
    run_pipeline_from_text  (quando existir)
"""

# 1) Entradas do pipeline (quando dispon√≠veis)
try:
    from .pipeline import extract_text_from_pdf, run_extraction_from_file, run_pipeline_from_text
except Exception:
    extract_text_from_pdf = None
    run_extraction_from_file = None
    run_pipeline_from_text = None

# 2) Fonte da verdade do extrator de texto
from juridico_inteligente.extract import run_extraction_from_text

# 3) Alias robusto: tenta o pipeline, sen√£o cai para o extrator puro
def run_pipeline(*args, **kwargs):
    """
    Alias robusto: tenta o pipeline; se n√£o aceitar certos kwargs
    (ex.: brand_map_path), reenvia sem eles; cai para o extrator puro se precisar.
    """
    from .pipeline import run_pipeline_from_text, run_extraction_from_text  # garantimos import local

    # kwargs que nossos extratores realmente entendem
    allowed = {"celula_options"}  # adicione aqui se surgir outro kw suportado
    safe_kwargs = {k: v for k, v in kwargs.items() if k in allowed}

    if callable(run_pipeline_from_text):
        try:
            return run_pipeline_from_text(*args, **safe_kwargs)
        except TypeError:
            pass  # assinatura n√£o bate: cai para o extrator puro

    return run_extraction_from_text(*args, **safe_kwargs)


__all__ = [
    "extract_text_from_pdf",
    "run_extraction_from_text",
    "run_extraction_from_file",
    "run_pipeline",
    "run_pipeline_from_text",
]



================================================================================
FILE: extractors/pipeline.py
================================================================================
# -*- coding: utf-8 -*-
import logging
import re
from typing import Dict, Any, Optional, List
from .regex_utils import (
    parse_numero_processo_cnj, extract_estado_sigla, extract_foro,
    parse_vara, parse_celula, parse_cliente_parte,
    assunto_from_text, objeto_from_text, subobj_from_text,
    detect_orgao_origem_instancia, extract_valor_causa, extract_data_distribuicao,
    extract_link_audiencia, extract_subtipo_audiencia, extract_envolvido_audiencia,
    extract_advogados, extract_telefone_parte_adversa, extract_email_parte_adversa,
    extract_prazo, extract_numero_processo_antigo, extract_cpf_cnpj_parte_adversa,
    # Dados trabalhistas
    extract_data_admissao, extract_data_demissao, extract_salario,
    extract_cargo_funcao, extract_empregador, extract_pis, extract_ctps,
    extract_local_trabalho, extract_motivo_demissao,
    # Novos campos
    extract_pedidos, extract_advogado_adverso,
    # M√∫ltiplas reclamadas
    extract_todas_reclamadas
)
from .audiencia import parse_audiencia_inicial
from .brand_map import detect_grupo

# Integra√ß√£o com monitor remoto
try:
    from monitor_integration import log_info, log_error
    MONITOR_AVAILABLE = True
except ImportError:
    MONITOR_AVAILABLE = False
    def log_info(msg, region=""): pass
    def log_error(msg, exc=None, region=""): pass

logger = logging.getLogger(__name__)

ANNEX_HEADER_PATTERNS = [
    r'^Perfil\s*Profissiogr[a√°]fico\s*Previdenci[a√°]rio',
    r'^ARQUIVO\s*DE\s*M[I√ç]DIA',
    r'^SUM[A√Å]RIO\s*\n.*Documentos',
    r'P√°gina\s+\d+\s+de\s+\d+\s*$.*PPP',
]

def extract_text_from_pdf(path: str, max_pages: int = 30, max_chars: int = 120000) -> str:
    """
    Extrai texto do PDF usando EXTRA√á√ÉO POR ZONAS INTELIGENTE.
    
    üÜï ESTRAT√âGIA DE 3 ZONAS (resolve problema de pedidos no meio do PDF):
    - ZONA PETI√á√ÉO (p√°ginas 1-35): CNJ, partes, comarca, valor causa, datas, PEDIDOS
    - ZONA TRCT (√∫ltimas 15 p√°ginas): Sal√°rio, PIS, CTPS, datas admiss√£o/demiss√£o
    
    2025-12-01: AMPLIADO para 35 p√°ginas iniciais porque peti√ß√µes trabalhistas
    costumam ter os pedidos entre p√°ginas 15-35 (ap√≥s fundamenta√ß√£o).
    
    Isso garante captura de dados mesmo em PDFs com 100+ p√°ginas onde
    o TRCT est√° no final (ex: p√°gina 126 de 138).
    """
    import os
    
    try:
        from PyPDF2 import PdfReader
        
        file_size_mb = os.path.getsize(path) / (1024 * 1024) if os.path.exists(path) else 0
        r = PdfReader(path)
        total_pages = len(r.pages)
        
        # 2025-12-01: Ampliado front_pages para 35 para capturar PEDIDOS
        # Em peti√ß√µes trabalhistas, pedidos geralmente est√£o entre p√°ginas 15-35
        front_pages = 35
        back_pages = 15
        
        if file_size_mb > 10:
            front_pages = 30  # Ainda amplo para capturar pedidos
            back_pages = 12
            logger.warning(f"[PDF_EXTRACT] ‚ö†Ô∏è PDF GRANDE ({file_size_mb:.1f}MB, {total_pages}p) - Zonas: {front_pages} in√≠cio + {back_pages} fim")
        elif file_size_mb > 5:
            front_pages = 32
            back_pages = 12
            logger.info(f"[PDF_EXTRACT] üìÑ PDF m√©dio ({file_size_mb:.1f}MB, {total_pages}p) - Zonas: {front_pages} in√≠cio + {back_pages} fim")
        
        texts = []
        pages_read = set()
        
        # ZONA 1: Primeiras p√°ginas (peti√ß√£o + pedidos)
        for i in range(min(front_pages, total_pages)):
            try:
                page_text = r.pages[i].extract_text() or ""
                texts.append(f"[P√ÅGINA {i+1}]\n{page_text}")
                pages_read.add(i)
            except Exception as page_err:
                logger.warning(f"[PDF_EXTRACT] ‚ö†Ô∏è Erro na p√°gina {i+1}: {page_err}")
        
        # ZONA 2: √öltimas p√°ginas (TRCT/anexos trabalhistas)
        if total_pages > front_pages:
            back_start = max(front_pages, total_pages - back_pages)
            
            if back_start > front_pages:
                texts.append(f"\n[... p√°ginas {front_pages+1}-{back_start} omitidas ...]\n")
            
            for i in range(back_start, total_pages):
                if i not in pages_read:
                    try:
                        page_text = r.pages[i].extract_text() or ""
                        texts.append(f"[P√ÅGINA {i+1}]\n{page_text}")
                        pages_read.add(i)
                    except Exception as page_err:
                        logger.warning(f"[PDF_EXTRACT] ‚ö†Ô∏è Erro na p√°gina {i+1}: {page_err}")
        
        result = "\n".join(texts)
        
        if len(result) > max_chars:
            result = result[:max_chars]
            logger.debug(f"[PDF_EXTRACT] Truncado para {max_chars} chars")
        
        logger.info(f"[PDF_EXTRACT] ‚úÖ ZONAS: {len(pages_read)} p√°ginas extra√≠das de {total_pages} total ({file_size_mb:.1f}MB, {len(result)} chars)")
        logger.info(f"[PDF_EXTRACT]    In√≠cio: 1-{min(front_pages, total_pages)}, Fim: {max(front_pages, total_pages - back_pages) + 1}-{total_pages}")
        return result
        
    except Exception as e:
        logger.exception("Falha ao ler PDF")
        log_error(f"Erro ao ler PDF: {path}", exc=e, region="EXTRACTOR")
        return ""

def _infer_tipo_processo(texto: str) -> str | None:
    if "P JE" in texto.upper() or "PJE" in texto.upper():
        return "Eletr√¥nico"
    return None

def run_extraction_from_text(texto: str, brand_map_path: Optional[str] = None, filename: Optional[str] = None, celula_options: Optional[List[str]] = None, pdf_path: Optional[str] = None) -> Dict[str, Any]:
    log_info(f"Iniciando extra√ß√£o de dados: {filename or 'N/A'}", region="EXTRACTOR")
    t = texto or ""
    data: Dict[str, Any] = {}

    # 1) CNJ + flags
    cnj = parse_numero_processo_cnj(t)
    if cnj:
        data["numero_processo"] = cnj
        data["cnj_sim"] = True
        data["cnj"] = "Sim"

    # 2) √Årea/Sub √°rea/Assunto/Objeto
    data["area_direito"] = "Trabalhista"
    # N√ÉO pr√©-configura rito - ser√° inferido por parse_header_info()
    data["objeto"] = objeto_from_text(t) or "Verbas rescis√≥rias"
    data["sub_objeto"] = subobj_from_text(t) or ""

    # 3) Localiza√ß√£o e √≥rg√£o - usa parse_header_info() compartilhado
    from .header_parser import parse_header_info
    header_data = parse_header_info(t, filename=filename)
    
    # Comarca, n√∫mero do √≥rg√£o e rito v√™m do header parser
    if header_data.get("comarca"):
        data["comarca"] = header_data["comarca"]
    if header_data.get("numero_orgao"):
        data["numero_orgao"] = header_data["numero_orgao"]
    if header_data.get("rito"):
        rito = header_data["rito"]
        data["sub_area_direito"] = f"A√ß√£o Trabalhista - Rito {rito}"
        data["assunto"] = f"Reclama√ß√£o Trabalhista No Rito {rito}"
    
    # Estado inferido da comarca ou fallback
    if header_data.get("estado"):
        data["estado"] = header_data["estado"]
    else:
        data["estado"] = extract_estado_sigla(t) or ""
    
    data["foro"]    = extract_foro(t) or ""
    data["vara"]    = parse_vara(t) or ""
    orgao, origem, instancia = detect_orgao_origem_instancia(t)
    if orgao:   data["orgao"] = orgao
    if origem:  data["origem"] = origem
    if instancia: data["instancia"] = instancia

    # 4) Sistema/Tipo de processo
    tipo = _infer_tipo_processo(t)
    if tipo: data["tipo_processo"] = tipo
    if "PJE" in t.upper():
        data["sistema_eletronico"] = "PJE"

    # 5) Cliente vs Parte adversa
    # ‚úÖ NOVA L√ìGICA: Extrai cliente do RECLAMADO, n√£o for√ßa GPA como padr√£o
    from .brand_map import normalize_cliente, detect_grupo
    
    # Primeiro extrai as partes sem cliente_hint para obter o nome bruto
    partes = parse_cliente_parte(t, cliente_hint=None)
    data.update(partes)
    
    # ‚úÖ NOVO: Propaga segunda parte interessada para campo do modelo (ex: CSN MINERA√á√ÉO quando CBSI √© principal)
    cliente_secundario_raw = partes.get("cliente_secundario", "")
    if cliente_secundario_raw and cliente_secundario_raw.strip():
        data["outra_reclamada_cliente"] = cliente_secundario_raw.strip()
        logger.debug(f"[MULTI_PARTE] Segunda parte interessada detectada: {cliente_secundario_raw.strip()}")
    
    # ‚úÖ M√öLTIPLAS RECLAMADAS - Extrai TODAS as partes reclamadas para o RPA
    # Formato: [{"nome": "...", "posicao": "RECLAMADO|REU|...", "tipo_pessoa": "fisica|juridica"}]
    # 2025-12-02: Com fallback LLM quando regex n√£o encontra
    reclamadas = extract_todas_reclamadas(t)
    if reclamadas:
        data["reclamadas"] = reclamadas
        logger.info(f"[RECLAMADAS] Extra√≠das via REGEX: {len(reclamadas)} reclamadas: {[r['nome'][:30] for r in reclamadas]}")
    else:
        # ‚úÖ FALLBACK LLM para reclamadas - quando regex n√£o encontra nenhuma
        logger.info("[RECLAMADAS_LLM] Regex n√£o encontrou reclamadas - tentando LLM...")
        try:
            from .llm_extractor import extract_reclamadas_with_llm
            reclamadas_llm = extract_reclamadas_with_llm(t)
            
            if reclamadas_llm:
                data["reclamadas"] = reclamadas_llm
                logger.info(f"[RECLAMADAS] ‚ú® LLM encontrou {len(reclamadas_llm)} reclamadas")
            else:
                data["reclamadas"] = []
                logger.debug("[RECLAMADAS] Nenhuma reclamada encontrada (regex + LLM)")
        except Exception as e:
            data["reclamadas"] = []
            logger.debug(f"[RECLAMADAS_LLM] Erro: {e}")
    
    # Extrai o nome bruto do reclamado
    nome_reclamado_bruto = partes.get("nome_reclamado", "")
    
    # Normaliza o cliente usando o mapeamento de aliases
    cliente_normalizado = normalize_cliente(nome_reclamado_bruto) if nome_reclamado_bruto else "Cliente N√£o Identificado"
    
    # Define cliente e cliente_grupo
    data["cliente"] = cliente_normalizado
    
    # cliente_grupo s√≥ √© preenchido se for um grupo conhecido (ex: GPA, Casas Bahia)
    # Para GPA: "Grupo P√£o de A√ß√∫car", para outros: o pr√≥prio cliente normalizado
    if detect_grupo(nome_reclamado_bruto):
        data["cliente_grupo"] = "Grupo P√£o de A√ß√∫car"
    else:
        data["cliente_grupo"] = cliente_normalizado

    # 6) Notifica√ß√£o/Audi√™ncia
    if "intima" in t.lower():
        data["tipo_notificacao"] = "Intima√ß√£o"
    
    # üîç DEBUG: Verificar se texto cont√©m palavras-chave de audi√™ncia
    texto_lower = t.lower()
    tem_audiencia = 'audi√™ncia' in texto_lower or 'audiencia' in texto_lower
    tem_inicial = 'inicial' in texto_lower
    tem_una = 'una' in texto_lower
    tem_data_possivel = any(f"{d:02d}/" in t for d in range(1, 32))
    logger.debug(f"[AUDIENCIA_DEBUG] Texto tem: audi√™ncia={tem_audiencia}, inicial={tem_inicial}, una={tem_una}, data_possivel={tem_data_possivel}")
    
    ai = parse_audiencia_inicial(t)
    if ai:
        data["audiencia_inicial"] = ai
        data["cadastrar_primeira_audiencia"] = True  # ‚úÖ Marcar automaticamente quando audi√™ncia for detectada
        logger.info(f"[AUDIENCIA_INICIAL] ‚úÖ Detectada: {ai} - cadastrar_primeira_audiencia=True")
    elif pdf_path:
        # ‚úÖ FALLBACK OCR: Tenta extrair audi√™ncia de p√°ginas escaneadas via mapeamento cir√∫rgico
        try:
            from .ocr_utils import extract_audiencia_from_mapping
            aud_ocr = extract_audiencia_from_mapping(pdf_path)
            if aud_ocr:
                data_aud = aud_ocr.get('data_audiencia', '')
                hora_aud = aud_ocr.get('hora_audiencia', '')
                if data_aud:
                    ai_combined = f"{data_aud} {hora_aud}".strip() if hora_aud else data_aud
                    data["audiencia_inicial"] = ai_combined
                    data["cadastrar_primeira_audiencia"] = True
                    logger.info(f"[AUDIENCIA_INICIAL_OCR] ‚úÖ Detectada via OCR: {ai_combined}")
        except Exception as e:
            logger.debug(f"[AUDIENCIA_INICIAL_OCR] Fallback OCR n√£o dispon√≠vel: {e}")
    
    # ‚úÖ Extrair link de audi√™ncia telepresencial (Zoom, Meet, Teams)
    link_aud = extract_link_audiencia(t)
    if link_aud:
        data["link_audiencia"] = link_aud
        logger.debug(f"[LINK_AUDIENCIA] Detectado: {link_aud}")
    
    # ‚úÖ Extrair subtipo de audi√™ncia (Una, N√£o-Una, Tentativa Concilia√ß√£o, etc)
    subtipo_aud = extract_subtipo_audiencia(t)
    if subtipo_aud:
        data["subtipo_audiencia"] = subtipo_aud
        logger.debug(f"[SUBTIPO_AUDIENCIA] Detectado: {subtipo_aud}")
    
    # ‚úÖ Extrair envolvidos da audi√™ncia (Advogado, Preposto, Advogado e Preposto, etc)
    envolvido_aud = extract_envolvido_audiencia(t)
    if envolvido_aud:
        data["envolvido_audiencia"] = envolvido_aud
        logger.debug(f"[ENVOLVIDO_AUDIENCIA] Detectado: {envolvido_aud}")

    # 7) Data de Distribui√ß√£o
    data_dist = extract_data_distribuicao(t)
    if data_dist:
        data["data_distribuicao"] = data_dist
        logger.debug(f"[DATA_DISTRIBUICAO] Extra√≠da: {data_dist}")
    
    # ‚úÖ VALIDA√á√ÉO: Audi√™ncia DEVE ser POSTERIOR √† Distribui√ß√£o
    # 2025-11-28: Plano Batman - valida√ß√£o preventiva para evitar datas iguais/invertidas
    if data.get("audiencia_inicial") and data.get("data_distribuicao"):
        from datetime import datetime
        try:
            aud_str = data["audiencia_inicial"]
            dist_str = data["data_distribuicao"]
            
            # Extrair apenas a data da audi√™ncia (pode ter hora: "25/12/2025 09:00")
            if ' ' in aud_str:
                aud_date_str = aud_str.split()[0]
            else:
                aud_date_str = aud_str
            
            # Normalizar formatos (DD/MM/YYYY ou YYYY-MM-DD)
            if '-' in aud_date_str and len(aud_date_str.split('-')[0]) == 4:
                dt_aud = datetime.strptime(aud_date_str, '%Y-%m-%d')
            else:
                dt_aud = datetime.strptime(aud_date_str, '%d/%m/%Y')
            
            if '-' in dist_str and len(dist_str.split('-')[0]) == 4:
                dt_dist = datetime.strptime(dist_str, '%Y-%m-%d')
            else:
                dt_dist = datetime.strptime(dist_str, '%d/%m/%Y')
            
            # Regra: Audi√™ncia deve ser ESTRITAMENTE POSTERIOR √† distribui√ß√£o
            if dt_aud.date() <= dt_dist.date():
                logger.warning(f"[VALIDACAO_AUDIENCIA] ‚ö†Ô∏è Audi√™ncia ({aud_str}) √© IGUAL OU ANTERIOR √† Distribui√ß√£o ({dist_str}) - REMOVENDO audi√™ncia!")
                # Remover a audi√™ncia inv√°lida
                del data["audiencia_inicial"]
                if "cadastrar_primeira_audiencia" in data:
                    data["cadastrar_primeira_audiencia"] = False
            else:
                dias_diff = (dt_aud.date() - dt_dist.date()).days
                logger.debug(f"[VALIDACAO_AUDIENCIA] ‚úÖ Audi√™ncia ({aud_str}) √© {dias_diff} dias ap√≥s Distribui√ß√£o ({dist_str})")
        except Exception as e:
            logger.warning(f"[VALIDACAO_AUDIENCIA] Erro ao validar datas: {e}")
    
    # 8) Valor da Causa
    valor_causa = extract_valor_causa(t)
    if valor_causa:
        data["valor_causa"] = valor_causa
        logger.debug(f"[VALOR_CAUSA] Extra√≠do: {valor_causa}")
    
    # 9) Observa√ß√£o (ex.: Segredo de justi√ßa)
    if "segredo de justi√ßa" in t.lower():
        data["observacao"] = "Segredo de justi√ßa"

    # 10) ‚úÖ NOVOS CAMPOS ADICIONAIS
    # Advogados (autor e r√©u)
    advogado_autor, advogado_reu = extract_advogados(t)
    if advogado_autor:
        data["advogado_autor"] = advogado_autor
    if advogado_reu:
        data["advogado_reu"] = advogado_reu
    
    # CPF/CNPJ da parte adversa (com verifica√ß√£o rigorosa de contexto)
    cpf_cnpj = extract_cpf_cnpj_parte_adversa(t)
    if cpf_cnpj:
        data["cpf_cnpj_parte_adversa"] = cpf_cnpj
    
    # Telefone e email da parte adversa
    telefone = extract_telefone_parte_adversa(t)
    if telefone:
        data["telefone_parte_adversa"] = telefone
    
    email = extract_email_parte_adversa(t)
    if email:
        data["email_parte_adversa"] = email
    
    # Prazo
    prazo = extract_prazo(t)
    if prazo:
        data["prazo"] = prazo
    
    # N√∫mero de processo antigo
    num_antigo = extract_numero_processo_antigo(t)
    if num_antigo:
        data["numero_processo_antigo"] = num_antigo
    
    # 11) ‚úÖ DADOS TRABALHISTAS (admiss√£o, demiss√£o, sal√°rio, cargo, PIS, CTPS, local, motivo)
    data_admissao = extract_data_admissao(t)
    if data_admissao:
        data["data_admissao"] = data_admissao
        logger.debug(f"[DATA_ADMISSAO] Extra√≠da: {data_admissao}")
    
    data_demissao = extract_data_demissao(t)
    if data_demissao:
        data["data_demissao"] = data_demissao
        logger.debug(f"[DATA_DEMISSAO] Extra√≠da: {data_demissao}")
    
    # ‚úÖ VALIDA√á√ÉO DE DATAS TRABALHISTAS COM CONSOLIDA√á√ÉO INTELIGENTE
    # 2025-11-28: Regras de consolida√ß√£o cautelosas (Plano Batman)
    # - Data de demiss√£o DEVE estar entre admiss√£o e distribui√ß√£o
    # - Rejeitar datas futuras (audi√™ncias) e muito antigas
    # - Usar data de distribui√ß√£o como limite m√°ximo para demiss√£o
    from datetime import datetime
    dt_hoje = datetime.now()
    
    # Extrair data de distribui√ß√£o para usar como limite m√°ximo
    data_distribuicao = extract_data_distribuicao(t)
    dt_distribuicao = None
    if data_distribuicao:
        try:
            dt_distribuicao = datetime.strptime(data_distribuicao, '%d/%m/%Y')
            data["data_distribuicao"] = data_distribuicao
            logger.debug(f"[DATA_DISTRIBUICAO] Extra√≠da: {data_distribuicao} (usada como limite m√°ximo)")
        except ValueError:
            pass
    
    def validar_data_trabalhista(data_str: str, campo: str, limite_max: datetime = None) -> str | None:
        """
        Valida se uma data trabalhista √© plaus√≠vel.
        
        Regras:
        1. N√£o pode ser futura (> hoje)
        2. N√£o pode ser muito antiga (< 1950)
        3. Se limite_max fornecido, n√£o pode ultrapass√°-lo (ex: demiss√£o < distribui√ß√£o)
        
        Retorna None se imposs√≠vel.
        """
        if not data_str:
            return None
        try:
            dt = datetime.strptime(data_str, '%d/%m/%Y')
            
            # Regra 1: Datas no futuro s√£o imposs√≠veis para eventos passados
            if dt > dt_hoje:
                logger.warning(f"[VALIDACAO_DATAS] ‚ö†Ô∏è {campo} ({data_str}) √© FUTURA - REMOVENDO!")
                return None
            
            # Regra 2: Datas muito antigas (antes de 1950) s√£o suspeitas
            if dt.year < 1950:
                logger.warning(f"[VALIDACAO_DATAS] ‚ö†Ô∏è {campo} ({data_str}) √© MUITO ANTIGA (< 1950) - REMOVENDO!")
                return None
            
            # Regra 3: Demiss√£o n√£o pode ser ap√≥s distribui√ß√£o do processo
            # (seria imposs√≠vel - o trabalhador processa antes de ser demitido?!)
            if limite_max and dt >= limite_max:
                logger.warning(f"[VALIDACAO_DATAS] ‚ö†Ô∏è {campo} ({data_str}) √© IGUAL OU POSTERIOR √† distribui√ß√£o ({limite_max.strftime('%d/%m/%Y')}) - REMOVENDO!")
                return None
            
            return data_str
        except ValueError:
            return None
    
    # Validar admiss√£o (sem limite m√°ximo al√©m de "hoje")
    if data.get('data_admissao'):
        data["data_admissao"] = validar_data_trabalhista(data["data_admissao"], "Admiss√£o")
    
    # Validar demiss√£o COM limite m√°ximo da distribui√ß√£o
    # Regra cautelosa: demiss√£o deve ser < distribui√ß√£o (n√£o pode processar antes de ser demitido)
    if data.get('data_demissao'):
        data["data_demissao"] = validar_data_trabalhista(
            data["data_demissao"], 
            "Demiss√£o",
            limite_max=dt_distribuicao  # Usar distribui√ß√£o como teto
        )
    
    # Se ambas as datas existem e s√£o v√°lidas, verificar ordem cronol√≥gica
    if data.get('data_admissao') and data.get('data_demissao'):
        try:
            dt_admissao = datetime.strptime(data['data_admissao'], '%d/%m/%Y')
            dt_demissao = datetime.strptime(data['data_demissao'], '%d/%m/%Y')
            
            if dt_admissao > dt_demissao:
                # Datas invertidas - corrigir se diferen√ßa razo√°vel
                diferenca_anos = abs((dt_admissao - dt_demissao).days) / 365
                if diferenca_anos < 50:
                    logger.warning(f"[VALIDACAO_DATAS] ‚ùå Admiss√£o ({data['data_admissao']}) POSTERIOR √† Demiss√£o ({data['data_demissao']}) - INVERTENDO!")
                    data["data_admissao"], data["data_demissao"] = data["data_demissao"], data["data_admissao"]
                    logger.info(f"[VALIDACAO_DATAS] ‚úÖ Datas corrigidas: Admiss√£o={data['data_admissao']}, Demiss√£o={data['data_demissao']}")
                else:
                    logger.warning(f"[VALIDACAO_DATAS] ‚ö†Ô∏è Diferen√ßa muito grande ({diferenca_anos:.0f} anos) - poss√≠vel erro de extra√ß√£o")
        except ValueError as e:
            logger.warning(f"[VALIDACAO_DATAS] Erro ao comparar datas: {e}")
    
    salario = extract_salario(t)
    if salario:
        data["salario"] = salario
        logger.debug(f"[SALARIO] Extra√≠do: {salario}")
    
    cargo = extract_cargo_funcao(t)
    if cargo:
        data["cargo_funcao"] = cargo
        logger.debug(f"[CARGO_FUNCAO] Extra√≠do: {cargo}")
    
    empregador = extract_empregador(t)
    if empregador:
        data["empregador"] = empregador
        logger.debug(f"[EMPREGADOR] Extra√≠do: {empregador}")
    else:
        # FALLBACK: usar RECLAMADO quando n√£o encontrar nome expl√≠cito no contexto de admiss√£o
        # Comum em processos que dizem apenas "admitido pela primeira reclamada"
        if data.get("nome_reclamado"):
            data["empregador"] = data["nome_reclamado"]
            logger.debug(f"[EMPREGADOR] Usando RECLAMADO como fallback: {data['empregador']}")
    
    pis = extract_pis(t)
    if pis:
        data["pis"] = pis
        logger.debug(f"[PIS] Extra√≠do: {pis}")
    
    ctps = extract_ctps(t)
    if ctps:
        data["ctps"] = ctps
        logger.debug(f"[CTPS] Extra√≠do: {ctps}")
    
    local_trabalho = extract_local_trabalho(t)
    if local_trabalho:
        data["local_trabalho"] = local_trabalho
        logger.debug(f"[LOCAL_TRABALHO] Extra√≠do via REGEX: {local_trabalho}")
    
    motivo_demissao = extract_motivo_demissao(t)
    if motivo_demissao:
        data["motivo_demissao"] = motivo_demissao
        logger.debug(f"[MOTIVO_DEMISSAO] Extra√≠do via REGEX: {motivo_demissao}")
    
    # 12) ‚úÖ PEDIDOS (lista estruturada da se√ß√£o "DOS PEDIDOS")
    # 2025-12-02: Com fallback LLM APENAS quando regex n√£o encontra NENHUM pedido
    pedidos = extract_pedidos(t)
    if pedidos:
        data["pedidos"] = pedidos
        logger.debug(f"[PEDIDOS] Extra√≠dos via REGEX: {len(pedidos)} pedidos")
    else:
        # ‚úÖ FALLBACK LLM para pedidos - APENAS quando regex n√£o encontra nenhum
        logger.info("[PEDIDOS_LLM] Regex n√£o encontrou pedidos - tentando LLM...")
        try:
            from .llm_extractor import extract_pedidos_with_llm
            pedidos_llm = extract_pedidos_with_llm(t)
            
            if pedidos_llm:
                # Extrair descri√ß√µes e garantir formato consistente
                pedidos_descricoes = []
                for p in pedidos_llm:
                    if isinstance(p, dict) and p.get("descricao"):
                        pedidos_descricoes.append(p["descricao"])
                
                if pedidos_descricoes:
                    data["pedidos"] = pedidos_descricoes
                    data["pedidos_categorias"] = pedidos_llm  # Manter categorias para uso futuro
                    logger.info(f"[PEDIDOS] ‚ú® LLM encontrou {len(pedidos_descricoes)} pedidos")
        except Exception as e:
            logger.debug(f"[PEDIDOS_LLM] Erro: {e}")
    
    # 13) ‚úÖ ADVOGADO DA PARTE ADVERSA (empregador)
    adv_adverso_nome, adv_adverso_oab = extract_advogado_adverso(t)
    if adv_adverso_nome:
        data["advogado_adverso_nome"] = adv_adverso_nome
        logger.debug(f"[ADV_ADVERSO] Nome: {adv_adverso_nome}")
    if adv_adverso_oab:
        data["advogado_adverso_oab"] = adv_adverso_oab
        logger.debug(f"[ADV_ADVERSO] OAB: {adv_adverso_oab}")
    
    # ‚úÖ FALLBACK LLM - Campos Trabalhistas Cr√≠ticos
    # Chama LLM se QUALQUER campo trabalhista cr√≠tico estiver faltando
    # Campos: sal√°rio, local_trabalho, pis, ctps, motivo_demissao
    
    campos_faltantes_criticos = []
    if not salario: campos_faltantes_criticos.append("salario")
    if not local_trabalho: campos_faltantes_criticos.append("local_trabalho")
    if not pis: campos_faltantes_criticos.append("pis")
    if not ctps: campos_faltantes_criticos.append("ctps")
    if not motivo_demissao: campos_faltantes_criticos.append("motivo_demissao")
    
    # Chamar LLM se qualquer campo trabalhista cr√≠tico estiver faltando
    if campos_faltantes_criticos:
        logger.info(f"[LLM_FALLBACK] Campos cr√≠ticos faltantes: {campos_faltantes_criticos} - chamando LLM...")
        from .llm_extractor import extract_labor_fields_with_llm
        llm_data = extract_labor_fields_with_llm(t)
        
        if llm_data:
            if not local_trabalho and llm_data.get("local_trabalho"):
                data["local_trabalho"] = llm_data["local_trabalho"]
                logger.info(f"[LOCAL_TRABALHO] ‚ú® Recuperado via LLM: {llm_data['local_trabalho']}")
            
            if not salario and llm_data.get("salario"):
                data["salario"] = llm_data["salario"]
                logger.info(f"[SALARIO] ‚ú® Recuperado via LLM: {llm_data['salario']}")
            
            # Aproveitar para preencher outros campos se vieram na mesma chamada
            if not motivo_demissao and llm_data.get("motivo_demissao"):
                data["motivo_demissao"] = llm_data["motivo_demissao"]
                logger.info(f"[MOTIVO_DEMISSAO] ‚ú® Recuperado via LLM: {llm_data['motivo_demissao']}")
            
            if not pis and llm_data.get("pis"):
                data["pis"] = llm_data["pis"]
                logger.info(f"[PIS] ‚ú® Recuperado via LLM: {llm_data['pis']}")
            
            if not ctps and (llm_data.get("ctps_numero") or llm_data.get("ctps_serie_uf")):
                if llm_data.get("ctps_numero") and llm_data.get("ctps_serie_uf"):
                    data["ctps"] = f"{llm_data['ctps_numero']} s√©rie {llm_data['ctps_serie_uf']}"
                elif llm_data.get("ctps_numero"):
                    data["ctps"] = llm_data["ctps_numero"]
                logger.info(f"[CTPS] ‚ú® Recuperado via LLM: {data.get('ctps', 'N/A')}")
    else:
        logger.debug("[LLM_SKIP] Regex extraiu campos cr√≠ticos - LLM n√£o necess√°rio")
    
    # ‚úÖ CAMADA 4: OCR SELETIVO INTELIGENTE (2025-12-01 - Plano Batman)
    # Aplica OCR APENAS em p√°ginas escaneadas detectadas automaticamente
    # Evita OCR cego em 8 p√°ginas - otimiza tempo sem perder cobertura
    
    campos_ocr = []
    if not data.get("salario"): campos_ocr.append("salario")
    if not data.get("pis"): campos_ocr.append("pis")
    if not data.get("ctps"): campos_ocr.append("ctps")
    
    if campos_ocr and pdf_path:
        try:
            from .ocr_utils import detect_scanned_pages, ocr_extract_from_pages
            
            # Detectar p√°ginas escaneadas (text_len < 100)
            scanned_pages = detect_scanned_pages(pdf_path)
            
            if scanned_pages:
                logger.info(f"[OCR_BATMAN] Detectadas {len(scanned_pages)} p√°ginas escaneadas: {scanned_pages}")
                # OCR apenas nas p√°ginas escaneadas (m√°x 5 para performance)
                target_pages = scanned_pages[-5:]  # √öltimas 5 p√°ginas escaneadas (TRCT/contracheques)
                ocr_result = ocr_extract_from_pages(pdf_path, target_pages)
                
                if ocr_result:
                    if not data.get("salario") and ocr_result.get("salario"):
                        data["salario"] = ocr_result["salario"]
                        logger.info(f"[SALARIO] üì∑ OCR cir√∫rgico: {ocr_result['salario']}")
                    
                    if not data.get("pis") and ocr_result.get("pis"):
                        data["pis"] = ocr_result["pis"]
                        logger.info(f"[PIS] üì∑ OCR cir√∫rgico: {ocr_result['pis']}")
                    
                    if not data.get("ctps") and ocr_result.get("ctps"):
                        data["ctps"] = ocr_result["ctps"]
                        logger.info(f"[CTPS] üì∑ OCR cir√∫rgico: {ocr_result['ctps']}")
            else:
                logger.debug(f"[OCR_SKIP] Campos {campos_ocr} vazios mas PDF √© 100% texto nativo - OCR n√£o necess√°rio")
        except Exception as e:
            logger.debug(f"[OCR_FALLBACK] Erro: {e}")
    elif campos_ocr:
        logger.debug(f"[OCR_SKIP] Campos {campos_ocr} vazios mas pdf_path n√£o fornecido")

    # 12) P√≥s-processamento (inclui infer√™ncia de c√©lula a partir do cliente)
    from .postprocess import full_postprocess
    data = full_postprocess(data, t, celula_options=celula_options or [])
    
    # NOTA: Valida√ß√£o LLM dispon√≠vel via validate_extracted_data_with_llm()
    # Chamada manual quando necess√°rio - n√£o autom√°tica para evitar chamadas extras

    logger.debug("Resultado (pipeline): %s", data)
    
    # Enviar log de conclus√£o para monitor
    extracted_count = len([v for v in data.values() if v])
    log_info(f"Extra√ß√£o conclu√≠da: {extracted_count} campos extra√≠dos ({filename or 'N/A'})", region="EXTRACTOR")
    
    return data

def run_extraction_from_file(path: str, brand_map_path: Optional[str] = None, filename: Optional[str] = None) -> Dict[str, Any]:
    if not filename:
        import os
        filename = os.path.basename(path)
    return run_extraction_from_text(
        extract_text_from_pdf(path), 
        brand_map_path=brand_map_path, 
        filename=filename,
        pdf_path=path  # ‚úÖ Passar caminho do PDF para habilitar OCR fallback
    )

def run_pipeline_from_text(text: str, celula_options: List[str] | None = None, filename: Optional[str] = None, pdf_path: Optional[str] = None, brand_map_path: Optional[str] = None) -> Dict[str, Any]:
    data = run_extraction_from_text(
        text, 
        filename=filename, 
        celula_options=celula_options,
        pdf_path=pdf_path,  # ‚úÖ Propagar pdf_path para habilitar OCR
        brand_map_path=brand_map_path  # ‚úÖ Propagar brand_map_path para normaliza√ß√£o de clientes
    )
    # Preenche orgao/origem apenas se faltarem
    orgao, origem, instancia_guess = detect_orgao_origem_instancia(text or "")
    if orgao and not data.get("orgao"):
        data["orgao"] = orgao
    if origem and not data.get("origem"):
        data["origem"] = origem
    # N√ÉO sobrescreva 'instancia' se o postprocess j√° definiu
    if instancia_guess and not data.get("instancia"):
        data["instancia"] = instancia_guess
    return data

# compat com o resto do projeto
run_pipeline = run_pipeline_from_text


================================================================================
FILE: extractors/llm_extractor.py
================================================================================
# extractors/llm_extractor.py
import json
import os
import re
from typing import Dict

# Integra√ß√£o com monitor remoto
try:
    from monitor_integration import log_info, log_error
    MONITOR_AVAILABLE = True
except ImportError:
    MONITOR_AVAILABLE = False
    def log_info(msg, region=""): pass
    def log_error(msg, exc=None, region=""): pass

OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")  # troque se quiser
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY") or os.getenv("OPENAI_API_KEY_2")

SCHEMA = {
    "type": "object",
    "properties": {
        "numero_processo": {"type": "string"},
        "sistema_eletronico": {"type": "string"},
        "area_direito": {"type": "string"},
        "sub_area_direito": {"type": "string"},
        "estado": {"type": "string"},
        "comarca": {"type": "string"},
        "orgao": {"type": "string"},
        "vara": {"type": "string"},
        "foro": {"type": "string"},
        "instancia": {"type": "string"},
        "assunto": {"type": "string"},
        "objeto": {"type": "string"},
        "sub_objeto": {"type": "string"},
        "distribuido_em": {"type": "string"},
        "audiencia_tipo": {"type": "string"},
        "audiencia_data_hora": {"type": "string"},
        "audiencia_local": {"type": "string"},
        "posicao_parte_interessada": {"type": "string"},
        "parte_interessada": {"type": "string"},
        "parte_adversa_tipo": {"type": "string"},
        "parte_adversa_nome": {"type": "string"}
    },
    "required": ["numero_processo"]
}

INSTRUCTIONS = """Voc√™ √© um extrator de dados jur√≠dicos.
Retorne APENAS um JSON v√°lido que respeite o schema a seguir.

INSTRU√á√ïES IMPORTANTES:
- Campo 'sistema_eletronico' use 'PJe', 'eproc', 'Projudi' ou vazio se n√£o achar.
- 'estado' deve ser a sigla UF (ex.: 'RJ').
- Datas no formato dd/mm/aaaa hh:mm quando houver hora, sen√£o dd/mm/aaaa.
- N√£o invente dados: deixe vazio se n√£o tiver certeza.

ATEN√á√ÉO CR√çTICA - DIFEREN√áA ENTRE DATAS:

1. 'distribuido_em': √â a DATA DE DISTRIBUI√á√ÉO do processo ao ju√≠zo
   - Procure por: "Distribu√≠do em DD/MM/AAAA" no cabe√ßalho do documento
   - Exemplo: "Distribu√≠do em 25/09/2025 12:16:24"
   - Esta data aparece NO CABE√áALHO/IN√çCIO do documento
   - N√ÉO confundir com data de audi√™ncia!

2. 'audiencia_data_hora': √â a DATA E HORA DA AUDI√äNCIA INICIAL quando agendada
   - Procure por: "audi√™ncia INICIAL", "audi√™ncia inicial", "Determino a audi√™ncia INICIAL"
   - Exemplo: "audi√™ncia INICIAL TELEPRESENCIAL... : 12/12/2025 09:10"
   - Esta data aparece no CORPO do documento, geralmente ap√≥s o texto de decis√£o
   - S√≥ preencher se houver EXPLICITAMENTE men√ß√£o a "audi√™ncia INICIAL" ou "audi√™ncia inicial"
   - Se n√£o encontrar "audi√™ncia inicial", deixe VAZIO

REGRA DE OURO: 
- Data de Distribui√ß√£o = cabe√ßalho ("Distribu√≠do em...")
- Audi√™ncia Inicial = corpo do documento ("audi√™ncia INICIAL...")
- S√£o datas DIFERENTES e n√£o devem ser confundidas!

Schema:
{}
""".format(json.dumps(SCHEMA, ensure_ascii=False))

def _call_openai_json(texto: str) -> Dict:
    """
    Chama a IA. Se n√£o houver chave, retorna {}.
    Sa√≠da sempre √© um dict (vazio em falha).
    """
    if not OPENAI_API_KEY:
        return {}

    try:
        # Cliente oficial (>= 1.0). Ajuste conforme seu SDK.
        from openai import OpenAI
        client = OpenAI(api_key=OPENAI_API_KEY)

        prompt = INSTRUCTIONS + "\n\n---\nTEXTO DO PDF:\n" + texto[:35000]  # OTIMIZADO: texto suficiente para campos essenciais

        # Usamos "responses" (novo) ou "chat.completions" (legado).
        # Aqui opto por "chat.completions" para compatibilidade ampla.
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": "Voc√™ extrai dados para preencher um formul√°rio jur√≠dico."},
                {"role": "user", "content": prompt}
            ],
            temperature=0,
        )

        content = resp.choices[0].message.content
        if not content:
            return {}
        content = content.strip()
        # Tenta achar um bloco JSON mesmo que a IA envolva em texto
        m = re.search(r"\{.*\}", content, flags=re.S)
        if m:
            content = m.group(0)
        data = json.loads(content)
        if isinstance(data, dict):
            return data
    except Exception:
        return {}
    return {}

def extract_fields_with_llm(texto: str) -> Dict:
    """
    API p√∫blica: retorna um dict com os campos do schema extra√≠dos pela IA.
    """
    data = _call_openai_json(texto)
    # Sanitiza√ß√£o m√≠nima
    if not isinstance(data, dict):
        return {}
    for k, v in list(data.items()):
        if isinstance(v, str):
            data[k] = re.sub(r"\s+", " ", v).strip()
    return data


# ========== FALLBACK LLM PARA CAMPOS TRABALHISTAS ==========

LABOR_SCHEMA = {
    "type": "object",
    "properties": {
        "motivo_demissao": {
            "type": "string",
            "enum": ["sem_justa_causa", "justa_causa", "term_exp", "rescisao_indireta", "pedido_demissao", ""]
        },
        "local_trabalho": {"type": "string"},
        "empregador": {"type": "string"},
        "salario": {"type": "string"},
        "pis": {"type": "string"},
        "ctps_numero": {"type": "string"},
        "ctps_serie_uf": {"type": "string"}
    }
}

LABOR_INSTRUCTIONS = """Voc√™ √© um extrator especializado em dados trabalhistas de PDFs jur√≠dicos brasileiros.
Retorne APENAS um JSON v√°lido com os campos solicitados.

PRIORIZA√á√ÉO DE FONTES (use nesta ordem):
1. TRCT (Termo de Rescis√£o do Contrato de Trabalho) - prioridade M√ÅXIMA
2. CTPS (Carteira de Trabalho) - prioridade ALTA
3. Peti√ß√£o inicial / narrativa - prioridade BAIXA

INSTRU√á√ïES POR CAMPO:

1. motivo_demissao:
   - TRCT: procure "Causa da rescis√£o" ou "Tipo de desligamento"
   - Narrativa: procure "sem justa causa", "rescis√£o indireta", "t√©rmino de contrato/experi√™ncia", "pedido de demiss√£o"
   - Valores aceitos: "sem_justa_causa", "justa_causa", "term_exp", "rescisao_indireta", "pedido_demissao"
   - Se n√£o encontrar, retorne vazio ""

2. local_trabalho:
   - Procure: "√öltimo local de trabalho", "Endere√ßo do estabelecimento", "Local de trabalho"
   - TRCT: "Estabelecimento/Unidade/Endere√ßo"
   - Deve ser endere√ßo completo com rua/avenida, bairro ou cidade
   - Se n√£o encontrar endere√ßo real, retorne vazio ""

3. empregador:
   - TRCT: "IDENTIFICA√á√ÉO DO EMPREGADOR" (raz√£o social)
   - CTPS: raz√£o social ou nome fantasia da empresa
   - Narrativa: qualifica√ß√£o da r√© ("em face de...", "RECLAMADA:")
   - Retorne a raz√£o social/nome da empresa

4. salario:
   - TRCT: campo "√öltima remunera√ß√£o" ou "Remunera√ß√£o" (mais confi√°vel)
   - CTPS: campo de sal√°rio na anota√ß√£o
   - Narrativa: procure "percebia", "recebia", "ganhava", "√∫ltimo sal√°rio", "remunera√ß√£o"
   - Formato: "R$ X.XXX,XX" (ex: "R$ 1.200,00", "R$ 10.500,50")
   - N√ÉO confundir com: piso salarial, "deveria receber", valores totais de rescis√£o
   - Priorize SAL√ÅRIO EFETIVAMENTE RECEBIDO, n√£o valores rescis√≥rios
   - Se n√£o encontrar, retorne vazio ""

5. pis:
   - TRCT: campo "PIS/PASEP" no bloco do trabalhador
   - Formato: 11 d√≠gitos (ex: "204.05911.17-8")
   - Se encontrar, mantenha a formata√ß√£o encontrada
   - Se n√£o encontrar, retorne vazio ""

5. ctps_numero e ctps_serie_uf:
   - CTPS: procure "CTPS", "Carteira de Trabalho", "s√©rie", "UF"
   - Separe n√∫mero (ex: "1210996") e s√©rie/UF (ex: "2780/RJ")
   - Se estiverem juntos: "CTPS n¬∫ 123456, s√©rie 149/RJ" ‚Üí numero="123456", serie_uf="149/RJ"
   - Se n√£o encontrar, retorne vazio ""

REGRAS CR√çTICAS:
- N√ÉO invente dados: se n√£o encontrar, deixe campo vazio ""
- Priorize informa√ß√µes de TRCT sobre outras fontes
- Para endere√ßos, exija que tenha indicadores geogr√°ficos reais (rua, avenida, bairro)
- Para PIS: exatamente 11 d√≠gitos
- Para CTPS s√©rie: deve ter UF (2 letras mai√∫sculas) ou ser num√©rica

Schema:
{}
""".format(json.dumps(LABOR_SCHEMA, ensure_ascii=False))


def extract_labor_fields_with_llm(texto: str) -> Dict:
    """
    Extrai campos trabalhistas usando LLM como fallback.
    Retorna dict com: motivo_demissao, local_trabalho, empregador, salario, pis, ctps_numero, ctps_serie_uf
    """
    log_info("Iniciando extra√ß√£o LLM (GPT-4o-mini) para campos trabalhistas", region="LLM_EXTRACTOR")
    
    if not OPENAI_API_KEY:
        return {}

    try:
        from openai import OpenAI
        client = OpenAI(api_key=OPENAI_API_KEY)

        prompt = LABOR_INSTRUCTIONS + "\n\n---\nTEXTO DO PDF:\n" + texto[:35000]  # OTIMIZADO: texto suficiente para campos trabalhistas

        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": "Voc√™ √© um extrator especializado em dados trabalhistas."},
                {"role": "user", "content": prompt}
            ],
            temperature=0,
        )

        content = resp.choices[0].message.content
        if not content:
            return {}
        content = content.strip()
        m = re.search(r"\{.*\}", content, flags=re.S)
        if m:
            content = m.group(0)
        data = json.loads(content)
        
        if isinstance(data, dict):
            # Sanitizar e validar
            result = {}
            if data.get("motivo_demissao") and data["motivo_demissao"].strip():
                result["motivo_demissao"] = data["motivo_demissao"].strip()
            if data.get("local_trabalho") and data["local_trabalho"].strip():
                result["local_trabalho"] = re.sub(r"\s+", " ", data["local_trabalho"]).strip()
            if data.get("empregador") and data["empregador"].strip():
                result["empregador"] = re.sub(r"\s+", " ", data["empregador"]).strip()
            if data.get("salario") and data["salario"].strip():
                result["salario"] = data["salario"].strip()
            if data.get("pis") and data["pis"].strip():
                result["pis"] = data["pis"].strip()
            if data.get("ctps_numero") and data["ctps_numero"].strip():
                result["ctps_numero"] = data["ctps_numero"].strip()
            if data.get("ctps_serie_uf") and data["ctps_serie_uf"].strip():
                result["ctps_serie_uf"] = data["ctps_serie_uf"].strip()
            
            extracted_fields = list(result.keys())
            log_info(f"LLM extraiu {len(extracted_fields)} campos: {', '.join(extracted_fields)}", region="LLM_EXTRACTOR")
            return result
    except Exception as e:
        log_error(f"Erro ao extrair com LLM: {e}", exc=e, region="LLM_EXTRACTOR")
        return {}
    return {}


# ========== FALLBACK LLM - QUERIES ESPEC√çFICAS POR CAMPO ==========
# 2025-11-28: Baseado na arquitetura RAG do prompt de extra√ß√£o otimizado
# Usa perguntas direcionadas quando regex + LLM geral falham

def _query_llm_single_field(texto: str, query: str, field_name: str) -> str | None:
    """
    Faz uma query espec√≠fica ao LLM para um √∫nico campo.
    Retorna apenas o valor extra√≠do ou None.
    """
    if not OPENAI_API_KEY:
        return None
    
    try:
        from openai import OpenAI
        client = OpenAI(api_key=OPENAI_API_KEY)
        
        prompt = f"""Analise o texto de um processo trabalhista e responda APENAS com o valor solicitado.
N√ÉO inclua explica√ß√µes, apenas o valor.
Se n√£o encontrar, responda apenas: NAO_ENCONTRADO

PERGUNTA: {query}

---
TEXTO DO PROCESSO:
{texto[:100000]}
"""
        
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": "Voc√™ √© um extrator de dados jur√≠dicos. Responda APENAS com o valor solicitado, sem explica√ß√µes."},
                {"role": "user", "content": prompt}
            ],
            temperature=0,
            max_tokens=100
        )
        
        content = resp.choices[0].message.content
        if not content:
            return None
        
        content = content.strip()
        
        if "NAO_ENCONTRADO" in content.upper() or "N√ÉO ENCONTRADO" in content.upper():
            return None
        
        if content and len(content) < 200:
            log_info(f"[{field_name}] Query LLM espec√≠fica retornou: {content[:50]}", region="LLM_QUERY")
            return content
        
        return None
        
    except Exception as e:
        log_error(f"Erro em query LLM espec√≠fica para {field_name}: {e}", exc=e, region="LLM_QUERY")
        return None


def extract_pis_with_llm_query(texto: str) -> str | None:
    """Extrai PIS usando query LLM espec√≠fica (fallback final)."""
    query = "Qual √© o n√∫mero de PIS/PASEP do reclamante/trabalhador? Responda APENAS com o n√∫mero no formato XXX.XXXXX.XX-X ou apenas d√≠gitos."
    result = _query_llm_single_field(texto, query, "PIS")
    
    if result:
        digits = re.sub(r'[^\d]', '', result)
        if len(digits) == 11:
            return f"{digits[:3]}.{digits[3:8]}.{digits[8:10]}-{digits[10]}"
        elif 10 <= len(digits) <= 12:
            return result
    return None


def extract_ctps_with_llm_query(texto: str) -> str | None:
    """Extrai CTPS usando query LLM espec√≠fica (fallback final)."""
    query = "Qual √© o n√∫mero da CTPS (Carteira de Trabalho) do reclamante? Responda no formato: NUMERO s√©rie SERIE/UF (ex: 123456 s√©rie 789/RJ)"
    return _query_llm_single_field(texto, query, "CTPS")


def extract_data_admissao_with_llm_query(texto: str) -> str | None:
    """Extrai data de admiss√£o usando query LLM espec√≠fica (fallback final)."""
    query = "Qual √© a data de admiss√£o/contrata√ß√£o do trabalhador reclamante? Responda APENAS com a data no formato dd/mm/aaaa."
    result = _query_llm_single_field(texto, query, "DATA_ADMISSAO")
    
    if result:
        date_match = re.search(r'(\d{2}[/.\-]\d{2}[/.\-]\d{4})', result)
        if date_match:
            return date_match.group(1).replace('.', '/').replace('-', '/')
    return None


def extract_data_demissao_with_llm_query(texto: str) -> str | None:
    """Extrai data de demiss√£o usando query LLM espec√≠fica (fallback final)."""
    query = "Qual √© a data de demiss√£o/dispensa/t√©rmino do contrato do trabalhador? Responda APENAS com a data no formato dd/mm/aaaa."
    result = _query_llm_single_field(texto, query, "DATA_DEMISSAO")
    
    if result:
        date_match = re.search(r'(\d{2}[/.\-]\d{2}[/.\-]\d{4})', result)
        if date_match:
            return date_match.group(1).replace('.', '/').replace('-', '/')
    return None


def extract_salario_with_llm_query(texto: str) -> str | None:
    """Extrai sal√°rio usando query LLM espec√≠fica (fallback final)."""
    query = "Qual √© o √∫ltimo sal√°rio mensal do trabalhador reclamante (n√£o valor de rescis√£o)? Responda APENAS com o valor no formato R$ X.XXX,XX."
    result = _query_llm_single_field(texto, query, "SALARIO")
    
    if result:
        money_match = re.search(r'R\$\s*[\d\.\s,]+', result)
        if money_match:
            value = money_match.group().strip()
            value = re.sub(r'\s+', '', value)
            return value
    return None


def extract_cargo_with_llm_query(texto: str) -> str | None:
    """Extrai cargo/fun√ß√£o usando query LLM espec√≠fica (fallback final)."""
    query = "Qual √© o cargo ou fun√ß√£o exercida pelo trabalhador reclamante? Responda APENAS com o nome do cargo."
    result = _query_llm_single_field(texto, query, "CARGO")
    
    if result and len(result) <= 100:
        result = result.upper()
        result = re.sub(r'\s+', ' ', result).strip()
        return result
    return None


def extract_data_audiencia_with_llm_query(texto: str) -> str | None:
    """Extrai data de audi√™ncia usando query LLM espec√≠fica (fallback final)."""
    query = "Qual √© a data e hora da audi√™ncia designada neste processo? Responda no formato dd/mm/aaaa HH:MM."
    result = _query_llm_single_field(texto, query, "DATA_AUDIENCIA")
    
    if result:
        datetime_match = re.search(r'(\d{2}[/.\-]\d{2}[/.\-]\d{4})\s*(?:√†s?\s*)?(\d{1,2}:\d{2})?', result)
        if datetime_match:
            date_part = datetime_match.group(1).replace('.', '/').replace('-', '/')
            time_part = datetime_match.group(2) or ""
            if time_part:
                return f"{date_part} {time_part}"
            return date_part
    return None


# ========== OTIMIZA√á√ïES LLM - PEDIDOS, RECLAMADAS, VALIDA√á√ÉO ==========
# 2025-12-02: Fun√ß√µes avan√ßadas para melhorar precis√£o da extra√ß√£o

from typing import List, Optional

# Schema para extra√ß√£o de pedidos
PEDIDOS_SCHEMA = {
    "type": "object",
    "properties": {
        "pedidos": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "descricao": {"type": "string"},
                    "categoria": {
                        "type": "string",
                        "enum": [
                            "verbas_rescisorias",      # Aviso pr√©vio, f√©rias, 13¬∫, FGTS+40%
                            "salariais",               # Horas extras, adicional noturno, insalubridade
                            "indenizatorios",          # Danos morais, ass√©dio, acidente
                            "acessorios",              # Honor√°rios, custas, juros
                            "outros"
                        ]
                    },
                    "valor_estimado": {"type": "string"}  # Se mencionado
                }
            }
        },
        "total_pedidos": {"type": "integer"}
    }
}

PEDIDOS_INSTRUCTIONS = """Voc√™ √© um extrator especializado em pedidos de peti√ß√µes trabalhistas brasileiras.
Analise o texto e extraia TODOS os pedidos feitos pelo reclamante.

LOCALIZA√á√ÉO DOS PEDIDOS:
1. Se√ß√£o "DOS PEDIDOS" ou "DOS REQUERIMENTOS"
2. Ap√≥s "Diante o exposto, requer:"
3. Listados com letras (a, b, c) ou n√∫meros (1, 2, 3)

CATEGORIAS DE PEDIDOS:
1. verbas_rescisorias: Aviso pr√©vio, f√©rias proporcionais/vencidas, 13¬∫ sal√°rio, FGTS, multa 40%
2. salariais: Horas extras, adicional noturno, insalubridade, periculosidade, diferen√ßas salariais
3. indenizatorios: Danos morais, danos materiais, ass√©dio, acidente de trabalho
4. acessorios: Honor√°rios advocat√≠cios, custas processuais, juros, corre√ß√£o monet√°ria
5. outros: Qualquer pedido que n√£o se encaixe nas categorias acima

REGRAS:
- Extraia o pedido COMPLETO, n√£o apenas palavras-chave
- Se houver valor estimado no pedido, inclua
- N√ÉO invente pedidos - extraia apenas os que est√£o no texto
- Retorne array vazio se n√£o encontrar se√ß√£o de pedidos

Retorne JSON no formato:
{
    "pedidos": [
        {"descricao": "...", "categoria": "verbas_rescisorias", "valor_estimado": "R$ X.XXX,XX"},
        ...
    ],
    "total_pedidos": N
}
"""


def extract_pedidos_with_llm(texto: str) -> List[dict]:
    """
    Extrai pedidos da peti√ß√£o usando LLM para maior precis√£o.
    Fallback quando regex n√£o encontra ou encontra poucos pedidos.
    
    Returns:
        Lista de dicts com: descricao, categoria, valor_estimado (opcional)
    """
    log_info("Iniciando extra√ß√£o LLM para pedidos", region="LLM_PEDIDOS")
    
    if not OPENAI_API_KEY:
        log_info("API key n√£o dispon√≠vel, retornando lista vazia", region="LLM_PEDIDOS")
        return []
    
    try:
        from openai import OpenAI
        client = OpenAI(api_key=OPENAI_API_KEY)
        
        # Usar at√© 50k chars para capturar se√ß√£o de pedidos completa
        prompt = PEDIDOS_INSTRUCTIONS + "\n\n---\nTEXTO DO PDF:\n" + texto[:50000]
        
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": "Voc√™ √© um extrator especializado em pedidos trabalhistas. Retorne APENAS JSON v√°lido."},
                {"role": "user", "content": prompt}
            ],
            temperature=0,
        )
        
        content = resp.choices[0].message.content
        if not content:
            return []
        
        content = content.strip()
        
        # Extrair JSON do response
        m = re.search(r'\{.*\}', content, flags=re.S)
        if m:
            content = m.group(0)
        
        data = json.loads(content)
        
        if isinstance(data, dict) and "pedidos" in data:
            pedidos = data["pedidos"]
            if isinstance(pedidos, list):
                # Sanitizar e validar cada pedido
                result = []
                for p in pedidos:
                    if isinstance(p, dict) and p.get("descricao"):
                        descricao = re.sub(r'\s+', ' ', p["descricao"]).strip()
                        if len(descricao) > 10:  # M√≠nimo de caracteres
                            result.append({
                                "descricao": descricao,
                                "categoria": p.get("categoria", "outros"),
                                "valor_estimado": p.get("valor_estimado", "")
                            })
                
                log_info(f"LLM extraiu {len(result)} pedidos", region="LLM_PEDIDOS")
                return result
        
        return []
        
    except Exception as e:
        log_error(f"Erro ao extrair pedidos com LLM: {e}", exc=e, region="LLM_PEDIDOS")
        return []


# Schema para extra√ß√£o de reclamadas
RECLAMADAS_SCHEMA = {
    "type": "object",
    "properties": {
        "reclamadas": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "nome": {"type": "string"},
                    "cnpj": {"type": "string"},
                    "tipo": {"type": "string", "enum": ["juridica", "fisica"]},
                    "posicao": {"type": "string"}  # RECLAMADO, R√âU, etc.
                }
            }
        }
    }
}

RECLAMADAS_INSTRUCTIONS = """Voc√™ √© um extrator especializado em identificar as partes reclamadas (r√©us/empregadores) em processos trabalhistas brasileiros.

OBJETIVO: Identificar TODAS as empresas ou pessoas que s√£o R√âS/RECLAMADAS no processo.

ONDE ENCONTRAR:
1. Cabe√ßalho do processo: "RECLAMADO:", "R√â:", "RECLAMADA:"
2. Qualifica√ß√£o das partes
3. Corpo da peti√ß√£o: "em face de...", "contra..."
4. M√∫ltiplas r√©s: "1¬™ RECLAMADA:", "2¬™ RECLAMADA:" ou listadas em sequ√™ncia

IDENTIFICA√á√ÉO:
- Pessoa Jur√≠dica: tem CNPJ, LTDA, S.A., S/A, EIRELI, ME, EPP, CIA, Companhia
- Pessoa F√≠sica: tem CPF, sem sufixos empresariais

REGRAS:
- Extraia o NOME COMPLETO da empresa/pessoa
- Se houver CNPJ, inclua no formato XX.XXX.XXX/XXXX-XX
- N√ÉO inclua o reclamante (trabalhador/autor)
- N√ÉO inclua advogados
- Se houver m√∫ltiplas empresas do mesmo grupo, liste todas separadamente

Retorne JSON no formato:
{
    "reclamadas": [
        {"nome": "EMPRESA XYZ LTDA", "cnpj": "12.345.678/0001-90", "tipo": "juridica", "posicao": "RECLAMADO"},
        {"nome": "EMPRESA ABC S.A.", "cnpj": "", "tipo": "juridica", "posicao": "2¬™ RECLAMADA"}
    ]
}
"""


def extract_reclamadas_with_llm(texto: str) -> List[dict]:
    """
    Extrai todas as partes reclamadas usando LLM para maior precis√£o.
    √ötil quando regex n√£o identifica corretamente ou h√° formatos incomuns.
    
    Returns:
        Lista de dicts com: nome, cnpj, tipo (juridica/fisica), posicao
    """
    log_info("Iniciando extra√ß√£o LLM para reclamadas", region="LLM_RECLAMADAS")
    
    if not OPENAI_API_KEY:
        log_info("API key n√£o dispon√≠vel, retornando lista vazia", region="LLM_RECLAMADAS")
        return []
    
    try:
        from openai import OpenAI
        client = OpenAI(api_key=OPENAI_API_KEY)
        
        # Usar primeiros 30k chars (cabe√ßalho + qualifica√ß√£o das partes)
        prompt = RECLAMADAS_INSTRUCTIONS + "\n\n---\nTEXTO DO PDF:\n" + texto[:30000]
        
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": "Voc√™ √© um extrator especializado em partes processuais. Retorne APENAS JSON v√°lido."},
                {"role": "user", "content": prompt}
            ],
            temperature=0,
        )
        
        content = resp.choices[0].message.content
        if not content:
            return []
        
        content = content.strip()
        
        # Extrair JSON do response
        m = re.search(r'\{.*\}', content, flags=re.S)
        if m:
            content = m.group(0)
        
        data = json.loads(content)
        
        if isinstance(data, dict) and "reclamadas" in data:
            reclamadas = data["reclamadas"]
            if isinstance(reclamadas, list):
                result = []
                for r in reclamadas:
                    if isinstance(r, dict) and r.get("nome"):
                        nome = re.sub(r'\s+', ' ', r["nome"]).strip().upper()
                        if len(nome) > 3:  # Nome m√≠nimo v√°lido
                            result.append({
                                "nome": nome,
                                "cnpj": r.get("cnpj", ""),
                                "tipo_pessoa": r.get("tipo", "juridica"),
                                "posicao": r.get("posicao", "RECLAMADO")
                            })
                
                log_info(f"LLM extraiu {len(result)} reclamadas", region="LLM_RECLAMADAS")
                return result
        
        return []
        
    except Exception as e:
        log_error(f"Erro ao extrair reclamadas com LLM: {e}", exc=e, region="LLM_RECLAMADAS")
        return []


# Schema para valida√ß√£o de dados
VALIDATION_SCHEMA = {
    "type": "object",
    "properties": {
        "is_valid": {"type": "boolean"},
        "issues": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "field": {"type": "string"},
                    "issue": {"type": "string"},
                    "suggestion": {"type": "string"}
                }
            }
        },
        "corrections": {
            "type": "object"  # campo: valor_corrigido
        }
    }
}

VALIDATION_INSTRUCTIONS = """Voc√™ √© um validador de dados jur√≠dicos extra√≠dos de processos trabalhistas.
Analise os dados extra√≠dos e verifique consist√™ncia e corre√ß√£o.

VALIDA√á√ïES A FAZER:

1. DATAS:
   - Data de admiss√£o deve ser ANTERIOR √† data de demiss√£o
   - Datas n√£o podem ser futuras (refer√™ncia: hoje √© {today})
   - Formato deve ser dd/mm/aaaa
   - Datas n√£o podem ter ano < 1950 ou > ano atual

2. VALORES MONET√ÅRIOS:
   - Sal√°rio deve estar em formato R$ X.XXX,XX
   - Sal√°rio deve ser razo√°vel (> R$ 1.000,00 e < R$ 500.000,00)

3. DOCUMENTOS:
   - PIS: deve ter 11 d√≠gitos
   - CTPS: n√∫mero + s√©rie/UF

4. PARTES:
   - Reclamante e reclamado devem ser diferentes
   - Reclamado deve parecer nome de empresa (para PJ) ou pessoa (para PF)

5. CONSIST√äNCIA GERAL:
   - Se h√° data de demiss√£o, deve haver data de admiss√£o
   - Se h√° sal√°rio, deve parecer valor mensal (n√£o anual, n√£o total rescis√≥rio)

Retorne JSON no formato:
{
    "is_valid": true/false,
    "issues": [
        {"field": "data_admissao", "issue": "Data posterior √† demiss√£o", "suggestion": "Verificar datas"}
    ],
    "corrections": {
        "data_admissao": "01/05/2020"  // Se houver corre√ß√£o √≥bvia
    }
}
"""


def validate_extracted_data_with_llm(data: dict, texto: str = "") -> dict:
    """
    Valida os dados extra√≠dos usando LLM para detectar inconsist√™ncias.
    
    Args:
        data: Dict com dados extra√≠dos (data_admissao, data_demissao, salario, etc.)
        texto: Texto do PDF para contexto adicional (opcional)
    
    Returns:
        Dict com: is_valid, issues (lista), corrections (dict campo->valor)
    """
    log_info("Iniciando valida√ß√£o LLM dos dados extra√≠dos", region="LLM_VALIDATION")
    
    if not OPENAI_API_KEY:
        log_info("API key n√£o dispon√≠vel, assumindo dados v√°lidos", region="LLM_VALIDATION")
        return {"is_valid": True, "issues": [], "corrections": {}}
    
    try:
        from openai import OpenAI
        from datetime import datetime
        
        client = OpenAI(api_key=OPENAI_API_KEY)
        
        today = datetime.now().strftime("%d/%m/%Y")
        instructions = VALIDATION_INSTRUCTIONS.replace("{today}", today)
        
        # Preparar dados para valida√ß√£o
        data_str = json.dumps(data, ensure_ascii=False, indent=2)
        
        prompt = instructions + f"\n\n---\nDADOS EXTRA√çDOS:\n{data_str}"
        
        # Adicionar contexto do PDF se dispon√≠vel (primeiros 5k chars)
        if texto:
            prompt += f"\n\n---\nCONTEXTO DO PDF (primeiros 5000 chars):\n{texto[:5000]}"
        
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": "Voc√™ √© um validador de dados jur√≠dicos. Retorne APENAS JSON v√°lido."},
                {"role": "user", "content": prompt}
            ],
            temperature=0,
        )
        
        content = resp.choices[0].message.content
        if not content:
            return {"is_valid": True, "issues": [], "corrections": {}}
        
        content = content.strip()
        
        # Extrair JSON do response
        m = re.search(r'\{.*\}', content, flags=re.S)
        if m:
            content = m.group(0)
        
        result = json.loads(content)
        
        if isinstance(result, dict):
            is_valid = result.get("is_valid", True)
            issues = result.get("issues", [])
            corrections = result.get("corrections", {})
            
            if issues:
                log_info(f"Valida√ß√£o encontrou {len(issues)} problemas", region="LLM_VALIDATION")
                for issue in issues[:3]:  # Log primeiros 3
                    log_info(f"  - {issue.get('field', '?')}: {issue.get('issue', '?')}", region="LLM_VALIDATION")
            else:
                log_info("Valida√ß√£o OK - dados consistentes", region="LLM_VALIDATION")
            
            return {
                "is_valid": is_valid,
                "issues": issues if isinstance(issues, list) else [],
                "corrections": corrections if isinstance(corrections, dict) else {}
            }
        
        return {"is_valid": True, "issues": [], "corrections": {}}
        
    except Exception as e:
        log_error(f"Erro na valida√ß√£o LLM: {e}", exc=e, region="LLM_VALIDATION")
        return {"is_valid": True, "issues": [], "corrections": {}}


# Schema para classifica√ß√£o de documento
CLASSIFICATION_SCHEMA = {
    "type": "object",
    "properties": {
        "tipo_documento": {
            "type": "string",
            "enum": [
                "peticao_inicial",
                "contestacao",
                "sentenca",
                "acordao",
                "despacho",
                "decisao_interlocutoria",
                "mandado_citacao",
                "notificacao",
                "trct",
                "ctps",
                "outro"
            ]
        },
        "area_direito": {
            "type": "string",
            "enum": ["trabalhista", "civel", "criminal", "tributario", "outro"]
        },
        "instancia": {
            "type": "string",
            "enum": ["1_grau", "2_grau", "superior", "outro"]
        },
        "confianca": {"type": "number"}  # 0.0 a 1.0
    }
}

CLASSIFICATION_INSTRUCTIONS = """Voc√™ √© um classificador de documentos jur√≠dicos brasileiros.
Analise o texto e classifique o tipo de documento.

TIPOS DE DOCUMENTO:
- peticao_inicial: Primeira pe√ßa do processo, cont√©m qualifica√ß√£o das partes, causa de pedir, pedidos
- contestacao: Resposta do r√©u √† peti√ß√£o inicial
- sentenca: Decis√£o final de 1¬∫ grau que resolve o m√©rito
- acordao: Decis√£o colegiada de tribunal (2¬∫ grau ou superior)
- despacho: Ato judicial de mero expediente
- decisao_interlocutoria: Decis√£o que n√£o p√µe fim ao processo
- mandado_citacao: Documento para citar a parte r√©
- notificacao: Comunica√ß√£o oficial do ju√≠zo
- trct: Termo de Rescis√£o do Contrato de Trabalho
- ctps: Carteira de Trabalho e Previd√™ncia Social
- outro: Qualquer outro tipo

INDICADORES:
- Peti√ß√£o inicial: "DOS FATOS", "DOS PEDIDOS", "RECLAMANTE:", "em face de"
- Senten√ßa: "DECIDO", "JULGO", "PROCEDENTE/IMPROCEDENTE", "DISPOSITIVO"
- Ac√≥rd√£o: "ACORDAM", "TURMA", "EMENTA"
- TRCT: "TERMO DE RESCIS√ÉO", "AVISO PR√âVIO", "FGTS"

Retorne JSON no formato:
{
    "tipo_documento": "peticao_inicial",
    "area_direito": "trabalhista",
    "instancia": "1_grau",
    "confianca": 0.95
}
"""


def classify_document_with_llm(texto: str) -> dict:
    """
    Classifica o tipo de documento jur√≠dico usando LLM.
    
    Returns:
        Dict com: tipo_documento, area_direito, instancia, confianca
    """
    log_info("Iniciando classifica√ß√£o LLM do documento", region="LLM_CLASSIFY")
    
    if not OPENAI_API_KEY:
        log_info("API key n√£o dispon√≠vel, retornando classifica√ß√£o padr√£o", region="LLM_CLASSIFY")
        return {
            "tipo_documento": "outro",
            "area_direito": "trabalhista",
            "instancia": "1_grau",
            "confianca": 0.0
        }
    
    try:
        from openai import OpenAI
        client = OpenAI(api_key=OPENAI_API_KEY)
        
        # Usar primeiros 15k chars para classifica√ß√£o
        prompt = CLASSIFICATION_INSTRUCTIONS + "\n\n---\nTEXTO DO DOCUMENTO:\n" + texto[:15000]
        
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": "Voc√™ √© um classificador de documentos jur√≠dicos. Retorne APENAS JSON v√°lido."},
                {"role": "user", "content": prompt}
            ],
            temperature=0,
        )
        
        content = resp.choices[0].message.content
        if not content:
            return {
                "tipo_documento": "outro",
                "area_direito": "trabalhista",
                "instancia": "1_grau",
                "confianca": 0.0
            }
        
        content = content.strip()
        
        # Extrair JSON do response
        m = re.search(r'\{.*\}', content, flags=re.S)
        if m:
            content = m.group(0)
        
        result = json.loads(content)
        
        if isinstance(result, dict):
            tipo = result.get("tipo_documento", "outro")
            area = result.get("area_direito", "trabalhista")
            instancia = result.get("instancia", "1_grau")
            confianca = result.get("confianca", 0.5)
            
            log_info(f"Documento classificado: {tipo} ({area}, {instancia}) - confian√ßa: {confianca:.0%}", region="LLM_CLASSIFY")
            
            return {
                "tipo_documento": tipo,
                "area_direito": area,
                "instancia": instancia,
                "confianca": float(confianca) if isinstance(confianca, (int, float)) else 0.5
            }
        
        return {
            "tipo_documento": "outro",
            "area_direito": "trabalhista",
            "instancia": "1_grau",
            "confianca": 0.0
        }
        
    except Exception as e:
        log_error(f"Erro na classifica√ß√£o LLM: {e}", exc=e, region="LLM_CLASSIFY")
        return {
            "tipo_documento": "outro",
            "area_direito": "trabalhista",
            "instancia": "1_grau",
            "confianca": 0.0
        }




================================================================================
FILE: extractors/regex_utils.py
================================================================================
# -*- coding: utf-8 -*-
import re
import json
import os
import logging
from typing import Dict, Optional, Tuple, List

CNJ_RE = re.compile(r"\b\d{7}-\d{2}\.\d{4}\.\d\.\d{2}\.\d{4}\b")

# ===== UTILIT√ÅRIOS DE NORMALIZA√á√ÉO COMPARTILHADOS =====
# 2025-12-01: Fun√ß√µes centralizadas para normalizar texto antes de aplicar regex
# Evita duplica√ß√£o e garante consist√™ncia em todas as fun√ß√µes de extra√ß√£o

def normalize_text(text: str) -> str:
    """
    Normaliza√ß√£o b√°sica de texto para TODOS os campos.
    Remove espa√ßos m√∫ltiplos, normaliza quebras de linha, limpa h√≠fens especiais.
    
    Usar como PRIMEIRO passo em todas as fun√ß√µes extract_*.
    """
    if not text:
        return ""
    # Substituir h√≠fens especiais por h√≠fen comum
    text = text.replace('‚Äì', '-').replace('‚Äî', '-')
    # Remover quebras de linha m√∫ltiplas
    text = re.sub(r'\n{3,}', '\n\n', text)
    # Normalizar espa√ßos m√∫ltiplos para um s√≥
    text = re.sub(r' {2,}', ' ', text)
    # Remover espa√ßos no in√≠cio/fim de linhas
    text = re.sub(r'^ +| +$', '', text, flags=re.MULTILINE)
    return text.strip()

def normalize_monetary(text: str) -> str:
    """
    Normaliza√ß√£o espec√≠fica para VALORES MONET√ÅRIOS.
    Corrige problemas comuns de OCR/PyPDF2 em valores como R$ 1.234,56
    
    Exemplos de corre√ß√£o:
    - "R $ 3.093, 10" ‚Üí "R$ 3.093,10"
    - "R$ 2 . 802,31" ‚Üí "R$ 2.802,31"
    - "1 . 234 , 56" ‚Üí "1.234,56"
    """
    if not text:
        return ""
    # R $ ‚Üí R$
    text = re.sub(r'R\s*\$', 'R$', text)
    # V√≠rgula com espa√ßo: ", 10" ‚Üí ",10"
    text = re.sub(r',\s+', ',', text)
    # Ponto com espa√ßo: "3. 093" ‚Üí "3.093"
    text = re.sub(r'\.\s+', '.', text)
    # Espa√ßo antes do ponto: "2 ." ‚Üí "2."
    text = re.sub(r'\s+\.', '.', text)
    # D√≠gitos separados por espa√ßo: "2 802" ‚Üí "2802" (problema PyPDF2)
    text = re.sub(r'(\d)\s+(\d)', r'\1\2', text)
    return text

def normalize_date_separators(text: str) -> str:
    """
    Normaliza√ß√£o espec√≠fica para DATAS.
    Converte separadores variados para formato padr√£o DD/MM/AAAA.
    
    Exemplos:
    - "25.09.2025" ‚Üí "25/09/2025"
    - "25-09-2025" ‚Üí "25/09/2025"
    - "25 / 09 / 2025" ‚Üí "25/09/2025"
    """
    if not text:
        return ""
    # Espa√ßos ao redor de separadores: "25 / 09" ‚Üí "25/09"
    text = re.sub(r'\s*[/.\-]\s*', '/', text)
    return text

def normalize_identifiers(text: str) -> str:
    """
    Normaliza√ß√£o espec√≠fica para IDENTIFICADORES (PIS, CTPS, CPF, RG).
    Remove "n¬∫", "n¬∞", "n ¬∫" e normaliza espa√ßos.
    
    Exemplos:
    - "PIS n¬∫ 204.05911.17.8" ‚Üí "PIS  204.05911.17.8" (espa√ßo extra removido depois)
    - "CTPS n¬∞ 1210996" ‚Üí "CTPS  1210996"
    """
    if not text:
        return ""
    # Remover "n¬∫", "n¬∞", "N¬∞", "N¬∫" com espa√ßos opcionais
    text = re.sub(r'n\s*[¬∫¬∞]\.?\s*', ' ', text, flags=re.I)
    # Normalizar espa√ßos m√∫ltiplos resultantes
    text = re.sub(r'\s+', ' ', text)
    # Normalizar h√≠fens especiais
    text = text.replace('‚Äì', '-').replace('‚Äî', '-')
    return text

def clean_extracted_value(value: str) -> str:
    """
    Limpeza final de valores extra√≠dos.
    Remove espa√ßos extras, pontua√ß√£o pendente, etc.
    """
    if not value:
        return ""
    value = value.strip()
    # Remover pontua√ß√£o pendente no final
    value = re.sub(r'[,;:\.\s]+$', '', value)
    # Normalizar espa√ßos internos
    value = re.sub(r'\s+', ' ', value)
    return value

# Mapeamento de meses por extenso (compartilhado)
MESES_MAP = {
    'janeiro': '01', 'jan': '01', 'jan.': '01',
    'fevereiro': '02', 'fev': '02', 'fev.': '02',
    'mar√ßo': '03', 'marco': '03', 'mar': '03', 'mar.': '03',
    'abril': '04', 'abr': '04', 'abr.': '04',
    'maio': '05', 'mai': '05', 'mai.': '05',
    'junho': '06', 'jun': '06', 'jun.': '06',
    'julho': '07', 'jul': '07', 'jul.': '07',
    'agosto': '08', 'ago': '08', 'ago.': '08',
    'setembro': '09', 'set': '09', 'set.': '09',
    'outubro': '10', 'out': '10', 'out.': '10',
    'novembro': '11', 'nov': '11', 'nov.': '11',
    'dezembro': '12', 'dez': '12', 'dez.': '12'
}

def parse_date_extenso(text: str) -> Optional[str]:
    """
    Converte data por extenso para DD/MM/AAAA.
    
    IMPORTANTE: Requer dia expl√≠cito para evitar fabrica√ß√£o de dados.
    
    Exemplos:
    - "01 de junho de 2024" ‚Üí "01/06/2024"
    - "15 de mar√ßo de 2023" ‚Üí "15/03/2023"
    - "junho de 2024" ‚Üí None (dia n√£o especificado, n√£o fabrica)
    
    Returns:
        Data formatada ou None se n√£o conseguir parsear OU se faltando dia
    """
    if not text:
        return None
    
    text_lower = text.lower().strip()
    
    # Padr√£o SOMENTE com dia expl√≠cito: "01 de junho de 2024"
    # NOTA: Removido fallback para m√™s/ano pois fabricar dia=01 viola regra ZERO ERRORS
    m = re.search(r'(\d{1,2})\s*(?:de\s+)?(' + '|'.join(MESES_MAP.keys()) + r')\.?\s*(?:de\s+)?(\d{4})', text_lower)
    if m:
        dia = m.group(1).zfill(2)
        mes = MESES_MAP.get(m.group(2).replace('.', ''), None)
        ano = m.group(3)
        if mes:
            return f"{dia}/{mes}/{ano}"
    
    # N√£o retorna data se s√≥ tiver m√™s/ano - evita fabricar dia=01
    return None

def is_valid_brazilian_date(date_str: str) -> bool:
    """
    Valida se uma data no formato DD/MM/AAAA √© v√°lida.
    
    Regras:
    - Dia: 01-31
    - M√™s: 01-12
    - Ano: 1900-2100 (razo√°vel para contexto trabalhista)
    """
    if not date_str:
        return False
    
    m = re.match(r'^(\d{2})/(\d{2})/(\d{4})$', date_str)
    if not m:
        return False
    
    dia, mes, ano = int(m.group(1)), int(m.group(2)), int(m.group(3))
    
    if not (1 <= dia <= 31):
        return False
    if not (1 <= mes <= 12):
        return False
    if not (1900 <= ano <= 2100):
        return False
    
    return True

def is_invalid_date_context(match_obj, text: str, keywords: List[str] = None) -> bool:
    """
    Verifica se uma data est√° em contexto inv√°lido (assinatura eletr√¥nica, distribui√ß√£o, etc).
    
    Args:
        match_obj: Objeto match do regex
        text: Texto original
        keywords: Lista de keywords que invalidam a data (default: assinaturas, distribui√ß√£o)
    
    Returns:
        True se a data est√° em contexto inv√°lido
    """
    if keywords is None:
        keywords = [
            'assinado eletronicamente', 'documento assinado', 
            'data da autua√ß√£o', 'data da distribui√ß√£o', 'distribu√≠do em',
            'intima√ß√£o', 'notifica√ß√£o', 'publica√ß√£o', 'certifico',
            'assinatura digital', 'validar este documento'
        ]
    
    # Contexto: 50 chars antes e 50 depois
    start = max(0, match_obj.start() - 50)
    end = min(len(text), match_obj.end() + 50)
    context = text[start:end].lower()
    
    return any(kw in context for kw in keywords)

# Logger para fun√ß√µes de extra√ß√£o
_extract_logger = logging.getLogger(__name__)

# ===== MAPEAMENTO TRT CENTRALIZADO =====
_TRT_MAP_CACHE = None

def _load_trt_map() -> Dict:
    """Carrega o mapeamento TRT ‚Üí Estado/UF do arquivo JSON."""
    global _TRT_MAP_CACHE
    if _TRT_MAP_CACHE is not None:
        return _TRT_MAP_CACHE
    
    try:
        map_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "trt_map.json")
        with open(map_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        _TRT_MAP_CACHE = {k: v for k, v in data.items() if not k.startswith("_")}
        return _TRT_MAP_CACHE
    except Exception as e:
        print(f"[TRT_MAP] Erro ao carregar mapeamento: {e}")
        return {}

def get_trt_info(codigo_trt: str) -> Dict:
    """Retorna informa√ß√µes do TRT pelo c√≥digo (01-24)."""
    trt_map = _load_trt_map()
    codigo = codigo_trt.zfill(2)
    return trt_map.get(codigo, {})

def get_estado_from_trt(codigo_trt: str) -> str:
    """Retorna o nome do estado a partir do c√≥digo TRT."""
    info = get_trt_info(codigo_trt)
    return info.get("estado", "")

def get_uf_from_trt(codigo_trt: str) -> str:
    """Retorna a sigla UF principal a partir do c√≥digo TRT."""
    info = get_trt_info(codigo_trt)
    return info.get("uf", "")

def get_ufs_from_trt(codigo_trt: str) -> List[str]:
    """Retorna lista de todas UFs cobertas pelo TRT (para TRTs multi-estado)."""
    info = get_trt_info(codigo_trt)
    return info.get("ufs", [info.get("uf", "")]) if info else []

def get_estado_alt_from_uf(codigo_trt: str, uf: str) -> str:
    """Retorna o nome do estado alternativo para uma UF em TRTs multi-estado."""
    info = get_trt_info(codigo_trt)
    estados_alt = info.get("estados_alt", {})
    return estados_alt.get(uf, info.get("estado", ""))

def disambiguate_trt_uf(codigo_trt: str, text: str) -> str:
    """
    Para TRTs que cobrem m√∫ltiplos estados (08, 10, 11, 14), 
    tenta desambiguar qual UF √© a correta baseando-se no texto do PDF.
    
    TRTs multi-estado:
    - TRT 08: PA, AP (Par√° e Amap√°)
    - TRT 10: DF, TO (Distrito Federal e Tocantins)
    - TRT 11: AM, RR (Amazonas e Roraima)
    - TRT 14: RO, AC (Rond√¥nia e Acre)
    
    Returns:
        UF correta baseada no texto, ou UF principal como fallback
    """
    ufs = get_ufs_from_trt(codigo_trt)
    
    if len(ufs) <= 1:
        return ufs[0] if ufs else ""
    
    t = (text or "").upper()
    
    uf_scores = {}
    
    uf_palavras = {
        "PA": ["PAR√Å", "PARA", "BEL√âM", "BELEM", "SANTAREM", "SANTAR√âM", "MARAB√Å", "MARABA"],
        "AP": ["AMAP√Å", "AMAPA", "MACAP√Å", "MACAPA"],
        "DF": ["DISTRITO FEDERAL", "BRAS√çLIA", "BRASILIA"],
        "TO": ["TOCANTINS", "PALMAS", "ARAGUAINA", "ARAGUA√çNA", "GURUPI"],
        "AM": ["AMAZONAS", "MANAUS"],
        "RR": ["RORAIMA", "BOA VISTA"],
        "RO": ["ROND√îNIA", "RONDONIA", "PORTO VELHO"],
        "AC": ["ACRE", "RIO BRANCO"]
    }
    
    for uf in ufs:
        score = 0
        for palavra in uf_palavras.get(uf, []):
            if palavra in t:
                score += 10
        if re.search(rf'\b{uf}\b', t):
            score += 5
        uf_scores[uf] = score
    
    sorted_ufs = sorted(uf_scores.items(), key=lambda x: x[1], reverse=True)
    
    if sorted_ufs[0][1] > sorted_ufs[1][1]:
        return sorted_ufs[0][0]
    
    return ufs[0]

def get_estado_variantes(codigo_trt: str) -> List[str]:
    """Retorna lista de variantes do nome do estado para sele√ß√£o em dropdowns."""
    info = get_trt_info(codigo_trt)
    variantes = info.get("variantes", [])
    estado = info.get("estado", "")
    uf = info.get("uf", "")
    
    result = []
    if estado:
        result.append(estado)
    if uf:
        result.append(uf)
    for v in variantes:
        if v not in result:
            result.append(v)
    return result

def extract_trt_from_cnj(cnj: str) -> str:
    """Extrai o c√≥digo TRT (2 d√≠gitos) do n√∫mero CNJ."""
    if not cnj:
        return ""
    cnj_digits = re.sub(r'\D', '', cnj)
    if len(cnj_digits) >= 16:
        return cnj_digits[14:16]
    return ""

def extract_trt_from_text(text: str) -> str:
    """Extrai o c√≥digo TRT do texto do PDF (ex: 'TRT da 13¬™ Regi√£o' ‚Üí '13')."""
    if not text:
        return ""
    
    # Padr√£o: "TRT da X¬™ Regi√£o" ou "Tribunal Regional do Trabalho da X¬™ Regi√£o"
    m = re.search(r'(?:TRT|Tribunal\s+Regional\s+do\s+Trabalho)\s+(?:da|de)\s+(\d{1,2})[¬™a¬∫]?\s*Regi[√£a]o', text, re.I)
    if m:
        return m.group(1).zfill(2)
    
    # Padr√£o: "TRT-13" ou "TRT13"
    m = re.search(r'\bTRT[-\s]?(\d{1,2})\b', text, re.I)
    if m:
        return m.group(1).zfill(2)
    
    return ""

UF = r"(AC|AL|AP|AM|BA|CE|DF|ES|GO|MA|MT|MS|MG|PA|PB|PR|PE|PI|RJ|RN|RS|RO|RR|SC|SP|SE|TO)"
_CPF_RE  = r'\b(\d{3}[.\s]?\d{3}[.\s]?\d{3}[-]?\d{2})\b'
_CNPJ_RE = r'\b(\d{2}[.\s]?\d{3}[.\s]?\d{3}[\/]?\d{4}[-]?\d{2})\b'
UF_RE = re.compile(r"\b([A-Z]{2})\b")
FORO_RE = re.compile(r"(F[√ìO]RUM\s+[A-Z√á√É√Ç√â√ç√ì√ö\- ]+?\s-\s+[A-Z]{2})")
VARA_RE = re.compile(r"\b\d{1,2}¬™?\s+Vara do Trabalho de\s+[A-Za-z√Ä-√∫\s'\-]+")
CELULA_RE = re.compile(r"\bC[√âE]LULA\s+([A-Za-z√Ä-√∫0-9\s\-/]+)")
DATA_RE = re.compile(r"\b(\d{2}/\d{2}/\d{4})\b")
HORA_RE = re.compile(r"\b(\d{1,2}:\d{2})\b")

# "RECLAMANTE: FULANO CPF 123.456.789-00"
PESSOA_FISICA_RE = re.compile(r"\b(CPF)\s*[:\-]?\s*(\d{3}\.?\d{3}\.?\d{3}-?\d{2})")
PESSOA_JURIDICA_RE = re.compile(r"\b(CNPJ)\s*[:\-]?\s*(\d{2}\.?\d{3}\.?\d{3}/?\d{4}-?\d{2})")

# ‚úÖ REGEX COMPLETO: Suporta TODAS as 61 nomenclaturas do eLaw
# Baseado no dropdown "Posi√ß√£o da Parte Interessada" do sistema eLaw

# PARTE AUTORA (quem move a a√ß√£o) - Todas as op√ß√µes do polo ativo
RECLAMANTE_RE = re.compile(
    r"(?:RECLAMANTE|RECORRENTE|AUTOR|APELANTE|AGRAVANTE|EMBARGANTE|EXEQUENTE|"
    r"IMPETRANTE|IMPUGNANTE|DENUNCIANTE|EXCIPIENTE|OPOENTE|REQUERENTE|"
    r"SUSCITANTE|NOTIFICANTE|INTERPELANTE|DEMANDANTE|DEPRECANTE|AUTUANTE|"
    r"HABILITANTE|INVENTARIANTE|CONSIGNANTE|ALIMENTANTE|INTERDITANTE|RECOVINTE|"
    r"REQUENTE)\s*[:\-]\s*([^\n\r]+)", 
    re.I | re.M
)

# PARTE RECLAMADA (quem sofre a a√ß√£o) - Todas as op√ß√µes do polo passivo + neutras
RECLAMADO_RE = re.compile(
    r"(?:RECLAMADO|RECORRIDO|R[√âE]U|REU|APELADO|AGRAVADO|EMBARGADO|EXECUTADO|"
    r"IMPETTRADO|IMPUGNADO|DENUNCIADO|EXCEPTO|REQUERIDO|SUSCITADO|NOTIFICADO|"
    r"INTERPELADO|DEMANDADO|DEPRECADO|AUTUADO|HABILITADA|INVENTARIADO|"
    r"CONSIGNADOV|INTERDITADO|RECOVINDO|OPOSTO|BENEFICI[√ÅA]RIO|CONFINANTE|"
    r"CREDOR|DEVEDOR|FAL[√äE]NCIA|HABTE|INVENT|ADVOGADO|PARTES|REQT|"
    r"TERCEIRO\s+INTERESSADO)\s*[:\-]\s*([^\n\r]+)", 
    re.I | re.M
)


# ===== PADR√ïES DE DETEC√á√ÉO DE √ìRG√ÉOS JUDICIAIS E ADMINISTRATIVOS =====
# Tribunais Trabalhistas
TRT_RE = re.compile(r"Tribunal Regional do Trabalho\s+da\s+(\d+)[¬™a]\s+Regi[a√£]o", re.I)
TST_RE = re.compile(r"\bTribunal Superior do Trabalho\b", re.I)

# Tribunais Superiores
STF_RE = re.compile(r"\bSupremo\s+Tribunal\s+Federal\b|\bSTF\b", re.I)
STJ_RE = re.compile(r"\bSuperior\s+Tribunal\s+de\s+Justi[√ßc]a\b|\bSTJ\b", re.I)

# Justi√ßa Federal
TRF_RE = re.compile(r"Tribunal Regional Federal\s+da\s+(\d+)[¬™a]\s+Regi[a√£]o", re.I)
JF_RE = re.compile(r"\bJusti[√ßc]a\s+Federal\b|\bVara\s+Federal\b|\bJF\b", re.I)

# √ìrg√£os Administrativos
PROCON_RE = re.compile(r"\bPROCON\b", re.I)
RECEITA_FEDERAL_RE = re.compile(r"\bReceita\s+Federal\b|\bRFB\b", re.I)
PREFEITURA_RE = re.compile(r"\bPrefeitura\s+(Municipal\s+)?de\b", re.I)
ORGAO_ADMIN_RE = re.compile(r"\b[√ìO]rg[a√£]o\s+Administrativo\b", re.I)

def normalize(s: Optional[str]) -> str:
    return re.sub(r"\s+", " ", (s or "")).strip()

def is_pessoa_juridica(nome: str) -> bool:
    """
    Detecta se um nome √© de pessoa jur√≠dica atrav√©s de sufixos empresariais e entidades institucionais.
    Usa word boundaries para evitar falsos positivos (ex: "CIA" em "GARCIA").
    
    Cobre:
    - Sufixos empresariais (LTDA, S.A., EIRELI, etc)
    - Entidades institucionais (SINDICATO, UNI√ÉO, MUNIC√çPIO, ESTADO, etc)
    - Entidades p√∫blicas (PREFEITURA, BANCO CENTRAL, MINIST√âRIO, etc)
    
    Returns:
        True se detectar indicadores de PJ, False caso contr√°rio
    """
    if not nome:
        return False
    
    nome_upper = normalize(nome).upper()
    
    # Remover acentos para matching mais robusto (ex: UNI√ÉO ‚Üí UNIAO)
    import unicodedata
    nome_normalizado = unicodedata.normalize('NFD', nome_upper)
    nome_normalizado = ''.join(c for c in nome_normalizado if unicodedata.category(c) != 'Mn')
    
    # Lista de sufixos/indicadores empresariais robustos
    indicadores_pj = [
        # Sufixos empresariais comuns
        r"\bLTDA\b", r"\bLIMITADA\b",
        r"\bS\.?A\.?\b", r"\bS/A\b", r"\bSOCIEDADE\s+ANONIMA\b",
        r"\bEIRELI\b",
        r"\bCOMPANHIA\b", r"\bCIA\.?\b",
        r"\b-\s*ME\b", r"\b-\s*EPP\b",  # Microempresa, Empresa de Pequeno Porte
        r"\bHOLDING\b",
        r"\bSOCIEDADE\b",
        r"\bEMPRESA\b",
        r"\bINDUSTRIA\b",
        r"\bCOMERCIO\b",
        
        # Entidades institucionais (‚úÖ FIX CR√çTICO para sindicatos e √≥rg√£os p√∫blicos)
        r"\bSINDICATO\b",
        r"\bUNIAO\b",  # UNI√ÉO FEDERAL sem acento
        r"\bMUNICIPIO\b",
        r"\bESTADO\s+(DE|DO|DA)\b",  # ESTADO DE/DO/DA (ex: "ESTADO DO RIO DE JANEIRO")
        r"\bGOVERNO\s+(DO|DA|DE|FEDERAL|ESTADUAL)\b",
        r"\bPREFEITURA\b",
        r"\bBANCO\s+CENTRAL\b",
        r"\bMINISTERIO\b",
        r"\bSECRETARIA\b",
        r"\bAUTARQUIA\b",
        r"\bCONSELHO\b",
        r"\bTRIBUNAL\b",
        r"\bFAZENDA\s+(PUBLICA|NACIONAL|ESTADUAL|MUNICIPAL)\b",
        r"\bPROCURADORIA\b",  # Procuradoria Geral (√≥rg√£o p√∫blico)
        r"\bDEFENSORIA\b",   # Defensoria P√∫blica
        r"\bCAMARA\s+(MUNICIPAL|DOS\s+DEPUTADOS)\b",
        r"\bASSEMBLEIA\s+LEGISLATIVA\b",
        r"\bINSS\b",
        r"\bCAIXA\s+ECONOMICA\b",
        
        # Outras entidades coletivas
        r"\bASSOCIACAO\b",
        r"\bCOOPERATIVA\b",
        r"\bFUNDACAO\b",
        r"\bINSTITUTO\b",
        r"\bORGANIZACAO\b",
        r"\bFEDERACAO\b",
        r"\bCONFEDERACAO\b"
    ]
    
    # Verifica se algum indicador est√° presente (com word boundaries)
    for indicador in indicadores_pj:
        if re.search(indicador, nome_normalizado):
            return True
    
    return False

def is_pessoa_fisica(nome: str) -> bool:
    """
    Detecta se um nome √© provavelmente de pessoa f√≠sica atrav√©s de padr√µes t√≠picos.
    
    Indicadores:
    - Presen√ßa de prenomes compostos t√≠picos (ex: "MARIA", "JOS√â", "JO√ÉO")
    - Aus√™ncia de sufixos empresariais
    - Formato de nome completo (2+ palavras sem indicadores PJ)
    
    Returns:
        True se detectar padr√µes de PF, False caso contr√°rio
    """
    if not nome:
        return False
    
    nome_upper = normalize(nome).upper()
    
    # Se j√° detectou PJ, n√£o √© PF
    if is_pessoa_juridica(nome):
        return False
    
    # Prenomes brasileiros comuns (forte indicador de PF)
    prenomes_comuns = [
        r"\bMARIA\b", r"\bJOS[E√â]\b", r"\bJO[A√É]O\b", r"\bANT[O√î]NIO\b", r"\bANA\b",
        r"\bPAULO\b", r"\bPEDRO\b", r"\bFRANCISCO\b", r"\bCARL(OS|A)\b", r"\bFERNAND(O|A)\b",
        r"\bLUCIA\b", r"\bLUIZ\b", r"\bMARCOS\b", r"\bPAULA\b", r"\bROBERT(O|A)\b",
        r"\bADRIAN(O|A)\b", r"\bANDR[E√â](A)?\b", r"\bBRUNO\b", r"\bRAFAEL\b", r"\bGABRIEL(A)?\b"
    ]
    
    # Verifica prenomes comuns
    for prenome in prenomes_comuns:
        if re.search(prenome, nome_upper):
            return True
    
    # Se tem 2+ palavras e n√£o tem indicadores PJ, provavelmente √© PF
    palavras = nome_upper.split()
    if len(palavras) >= 2:
        # Verifica se tem part√≠culas t√≠picas de nomes (DE, DA, DOS, DAS, DO)
        particulas_nome = ["DE", "DA", "DO", "DOS", "DAS", "E"]
        tem_particula = any(p in palavras for p in particulas_nome)
        
        # Nome com 3+ palavras ou com part√≠culas ‚Üí prov√°vel PF
        if len(palavras) >= 3 or tem_particula:
            return True
    
    return False

# --- API EST√ÅVEL ---

def parse_numero_processo_cnj(text: str) -> Optional[str]:
    m = CNJ_RE.search(text or "")
    return m.group(0) if m else None

# Alias para compatibilidade retroativa
def parse_numero_processo(text: str) -> Optional[str]:
    return parse_numero_processo_cnj(text)

def extract_estado_sigla(text: str, cnj: str = None) -> str | None:
    """
    Extrai a sigla UF do estado a partir do texto do PDF.
    
    Ordem de prioridade:
    1. UF expl√≠cita ap√≥s munic√≠pio (ex: "Jo√£o Pessoa/PB", "Campina Grande-PB")
    2. UF em contexto de localiza√ß√£o (ex: "Comarca de X-PB", "Foro de X/PB")
    3. UF expl√≠cita (ex: "Estado: PB", "UF: PB")
    4. TRT do texto ‚Üí UF via mapeamento (com desambigua√ß√£o para TRTs multi-estado)
    5. TRT do CNJ ‚Üí UF via mapeamento (com desambigua√ß√£o para TRTs multi-estado)
    6. UF isolada pr√≥ximo a contexto judicial
    
    Para TRTs multi-estado (08, 10, 11, 14), usa desambigua√ß√£o baseada em
    palavras-chave do texto (cidades, estados) para escolher a UF correta.
    """
    t = text or ""
    
    # Prioridade 1: UF ap√≥s nome de munic√≠pio (padr√£o: "Munic√≠pio/UF" ou "Munic√≠pio-UF")
    m = re.search(r'[A-Z√Ä√Ç√Å√É√â√ä√ç√ì√î√ï√ö][a-z√†√¢√°√£√ß√©√™√≠√≥√¥√µ√∫]+(?:\s+[A-Z√Ä√Ç√Å√É√â√ä√ç√ì√î√ï√ö][a-z√†√¢√°√£√ß√©√™√≠√≥√¥√µ√∫]+)*\s*[-/]\s*' + rf'({UF})\b', t, flags=re.I)
    if m:
        return m.group(1).upper()
    
    # Prioridade 2: UF em contexto de localiza√ß√£o (Comarca, Foro, Vara)
    m = re.search(rf'(?:Comarca|Foro|F[√≥o]rum|Vara)\s+(?:Trabalhista\s+)?(?:de|do|da)\s+[A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß]+(?:\s+[A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß]+)*\s*[-‚Äì/]\s*({UF})\b', t, flags=re.I)
    if m:
        return m.group(1).upper()
    
    # Prioridade 3: UF expl√≠cita (ex: "Estado: PB", "UF: PB")
    m = re.search(rf'\b(?:Estado|UF)\s*:\s*({UF})\b', t, flags=re.I)
    if m:
        return m.group(1).upper()
    
    # Prioridade 4: TRT do texto do PDF ‚Üí UF via mapeamento (com desambigua√ß√£o)
    trt_texto = extract_trt_from_text(t)
    if trt_texto:
        uf = disambiguate_trt_uf(trt_texto, t)
        if uf:
            return uf
    
    # Prioridade 5: TRT do CNJ (se fornecido) ‚Üí UF via mapeamento (com desambigua√ß√£o)
    if cnj:
        trt_cnj = extract_trt_from_cnj(cnj)
        if trt_cnj:
            uf = disambiguate_trt_uf(trt_cnj, t)
            if uf:
                return uf
    
    # Prioridade 6: H√≠fen seguido de UF (padr√£o gen√©rico)
    m = re.search(rf"[-‚Äì]\s*({UF})\b", t, flags=re.I)
    if m:
        return m.group(1).upper()
    
    # Prioridade 7: UF isolada pr√≥ximo a contexto judicial (cabe√ßalho)
    cabecalho = t[:2000]
    ufs_seguras = ['RJ', 'SP', 'MG', 'RS', 'PR', 'SC', 'BA', 'PE', 'CE', 'PA', 'GO', 'MA', 'ES', 'PB', 'RN', 'MT', 'MS', 'PI', 'AL', 'SE', 'RO', 'AC', 'AM', 'RR', 'AP', 'TO', 'DF']
    if re.search(r'\b(?:TRIBUNAL|VARA|JUIZ|JU√çZO|F√ìRUM|FORUM|TRT|REGIONAL)\b', cabecalho, re.I):
        for uf_segura in ufs_seguras:
            if re.search(rf'\b{uf_segura}\b', cabecalho):
                return uf_segura
    
    return None

def extract_foro(text: str) -> str | None:
    # pega linhas com F√ìRUM TRABALHISTA / FORO TRABALHISTA / JUSTI√áA DO TRABALHO
    m = re.search(r"(F[√ìO]RUM\s+TRABALHISTA[^\n]+|F[√ìO]RO\s+TRABALHISTA[^\n]+|Justi[c√ß]a do Trabalho[^\n]+)", text or "", flags=re.I)
    return (m.group(1).strip().upper() if m else None)

def parse_vara(text: str) -> str | None:
    m = re.search(r"(\d+\s*¬™?\s*Vara do Trabalho[^\n]*)", text or "", flags=re.I)
    return m.group(1).strip() if m else None

def parse_celula(text: str) -> str | None:
    # n√£o inventa; s√≥ retorna se houver pista expl√≠cita
    m = re.search(r"C[√âE]LULA\s*:\s*([A-Za-z0-9\s\-/]+)", text or "", flags=re.I)
    return m.group(1).strip() if m else None

def extract_datetime(text: str) -> Optional[str]:
    # Retorna "dd/mm/aaaa hh:mm" se encontrar ambos
    mdata = DATA_RE.search(text or "")
    mhora = HORA_RE.search(text or "")
    if mdata and mhora:
        return f"{mdata.group(1)} {mhora.group(1)}"
    return None

def extract_data_distribuicao(text: str) -> Optional[str]:
    """
    Extrai a data de distribui√ß√£o do processo.
    
    2025-12-01: OTIMIZA√á√ÉO COMPLETA - Plano Batman
    - Usa utilit√°rios compartilhados
    - Novos padr√µes para formatos alternativos
    - Valida√ß√£o de data
    
    1¬™ Inst√¢ncia: "Distribu√≠do em DD/MM/AAAA"
    2¬™ Inst√¢ncia: "Data da Autua√ß√£o: DD/MM/AAAA"
    """
    logger = _extract_logger
    
    if not text:
        return None
    
    # NORMALIZA√á√ÉO
    text_norm = normalize_text(text)
    
    def format_date(raw: str) -> str:
        return raw.strip().replace('.', '/').replace('-', '/')
    
    # ===== PRIORIDADE 1: Distribui√ß√£o (1¬™ inst√¢ncia) =====
    dist_patterns = [
        r'Distribu[√≠i]d[oa]?\s+em\s*:?\s*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'Data\s+(?:da\s+)?distribui[√ßc][a√£]o\s*[:\s]+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "Protocolo em DD/MM/AAAA"
        r'Protocola?d?[oa]?\s+em\s*:?\s*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
    ]
    
    for pattern in dist_patterns:
        m = re.search(pattern, text_norm, re.I)
        if m:
            data = format_date(m.group(1))
            if is_valid_brazilian_date(data):
                logger.debug(f"[DATA_DISTRIBUICAO] ‚úÖ Distribui√ß√£o: {data}")
                return data
    
    # ===== PRIORIDADE 2: Autua√ß√£o (2¬™ inst√¢ncia) =====
    autua_patterns = [
        r'(?:Data\s+da\s+)?Autua[√ßc][√£a]o(?:\s+em)?\s*:?\s*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'Autuad[oa]\s+em\s*:?\s*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "Recebido em DD/MM/AAAA" (recursos)
        r'Recebid[oa]\s+em\s*:?\s*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
    ]
    
    for pattern in autua_patterns:
        m = re.search(pattern, text_norm, re.I)
        if m:
            data = format_date(m.group(1))
            if is_valid_brazilian_date(data):
                logger.debug(f"[DATA_DISTRIBUICAO] ‚úÖ Autua√ß√£o: {data}")
                return data
    
    # NOTA: Removido fallback "primeira data no cabe√ßalho" para evitar 
    # capturar datas de assinatura/publica√ß√£o como distribui√ß√£o
    
    logger.debug("[DATA_DISTRIBUICAO] ‚ùå Nenhuma data encontrada")
    return None

def extract_valor_causa(text: str) -> Optional[str]:
    """
    Extrai o valor da causa do PDF.
    Procura por padr√µes como:
    - "Valor da causa: R$ 462.289,03"
    - "Valor da Causa: 1.234,56"
    - "Valor: R$ 10.000,00"
    
    Retorna o valor formatado como string (ex: "462.289,03")
    """
    t = text or ""
    
    # Padr√£o 1: "Valor da causa: R$ X.XXX,XX" (mais comum em capas de processo)
    m = re.search(r"Valor\s+da\s+[Cc]ausa\s*[:\-]?\s*R?\$?\s*([0-9]{1,3}(?:\.[0-9]{3})*(?:,[0-9]{2})?)", t, re.I)
    if m:
        return m.group(1).strip()
    
    # Padr√£o 2: "Valor: R$ X.XXX,XX" (alternativo)
    m = re.search(r"(?<!\w)Valor\s*[:\-]\s*R?\$?\s*([0-9]{1,3}(?:\.[0-9]{3})*(?:,[0-9]{2})?)", t, re.I)
    if m:
        return m.group(1).strip()
    
    return None

def detect_orgao_origem_instancia(text: str) -> Tuple[Optional[str], Optional[str], Optional[str]]:
    """
    Retorna (orgao, origem, instancia)
      - orgao: "TRT-1", "STF", "STJ", "TRF-3", "JF", etc
      - origem: "TRT", "TST", "STF", "STJ", "TRF", "JF", "PROCON", "RECEITA FEDERAL", "Prefeitura", "√ìRG√ÉO ADMINISTRATIVO"
      - instancia: "1¬™ Inst√¢ncia" / "2¬™ Inst√¢ncia" / "3¬™ Inst√¢ncia" / None
    
    ‚úÖ PRIORIDADE CORRIGIDA: Detecta tribunais regionais ANTES de superiores para evitar
       falsos positivos com cita√ß√µes jur√≠dicas (ex: "DECIS√ÉO DO STF" em peti√ß√µes TRT).
       
    Ordem de detec√ß√£o:
    1. Tribunais Regionais (TRT, TRF, JF) - aparecem no cabe√ßalho oficial
    2. Tribunais Superiores (STF, STJ, TST) - frequentemente citados no corpo do texto
    3. √ìrg√£os Administrativos (PROCON, etc)
    """
    t = text or ""
    
    # ===== JUSTI√áA DO TRABALHO (prioridade 1) =====
    # TRT (Tribunal Regional do Trabalho) - pode ser 1¬™ ou 2¬™ inst√¢ncia
    m_trt = TRT_RE.search(t)
    if m_trt:
        n = m_trt.group(1)
        trt_orgao = f"TRT-{n}"
        
        # ‚úÖ FIX: Detectar 2¬™ inst√¢ncia APENAS com sinais no cabe√ßalho (primeiros 1500 chars)
        # para evitar falsos positivos de cita√ß√µes de jurisprud√™ncia
        cabecalho = t[:1500]  # Primeiros 1500 caracteres = cabe√ßalho do documento
        
        # Sinais FORTES de 2¬™ inst√¢ncia (devem aparecer no cabe√ßalho)
        sinais_2a_cabecalho = [
            r"\bRecurso\s+Ordin[a√°]rio",  # RO/ROT no cabe√ßalho
            r"\bRecurso\s+de\s+Revista",  # RR no cabe√ßalho
            r"\bAgravo",                   # Agravo de Peti√ß√£o/Instrumento
            r"\bAc[√≥o]rd[a√£]o",           # Ac√≥rd√£o (decis√£o colegiada)
            r"\bTurma\b",                  # Turma do Tribunal
            r"\bRelator[:\-]",             # Relator (desembargador)
            r"2[a¬™]\s+Inst[a√¢]ncia",      # Men√ß√£o expl√≠cita
            r"\bDesembargador",            # Desembargador (2¬™ inst√¢ncia)
        ]
        
        for padrao in sinais_2a_cabecalho:
            if re.search(padrao, cabecalho, re.I):
                return trt_orgao, "TRT", "2¬™ Inst√¢ncia"
        
        # Sinais de 1¬™ inst√¢ncia (peti√ß√µes iniciais em Vara):
        sinais_1a_instancia = [
            r"A[√ßc][a√£]o\s+Trabalhista",   # A√ß√£o Trabalhista
            r"\bRito\s+(Ordin[a√°]rio|Sumar[i√≠]ssimo)",  # Rito (s√≥ 1¬™ inst√¢ncia)
            r"\bPeti[√ßc][a√£]o\s+Inicial",  # Peti√ß√£o Inicial
            r"Distribu[i√≠]do?\s+em",       # Distribui√ß√£o (a√ß√µes usam, recursos usam autua√ß√£o)
        ]
        
        for padrao in sinais_1a_instancia:
            if re.search(padrao, t, re.I):
                return trt_orgao, "TRT", "1¬™ Inst√¢ncia"
        
        # Se menciona Vara, √© 1¬™ inst√¢ncia
        if VARA_RE.search(t):
            return trt_orgao, "TRT", "1¬™ Inst√¢ncia"
        
        # Fallback: Indeterminada
        return trt_orgao, "TRT", None
    
    # Se menciona Vara do Trabalho mas n√£o detectou TRT, assume TRT desconhecido
    if VARA_RE.search(t):
        return None, "TRT", "1¬™ Inst√¢ncia"
    
    # ===== JUSTI√áA FEDERAL (prioridade 2) =====
    # TRF (Tribunal Regional Federal) - 2¬™ inst√¢ncia da Justi√ßa Federal
    m_trf = TRF_RE.search(t)
    if m_trf:
        n = m_trf.group(1)
        return f"TRF-{n}", "TRF", "2¬™ Inst√¢ncia"
    
    # JF (Justi√ßa Federal/Vara Federal) - 1¬™ inst√¢ncia
    if JF_RE.search(t):
        return "JF", "JF", "1¬™ Inst√¢ncia"
    
    # ===== TRIBUNAIS SUPERIORES (prioridade 3 - cita√ß√µes frequentes) =====
    if STF_RE.search(t):
        return "STF", "STF", "3¬™ Inst√¢ncia"
    
    if STJ_RE.search(t):
        return "STJ", "STJ", "3¬™ Inst√¢ncia"
    
    if TST_RE.search(t):
        return "TST", "TST", "3¬™ Inst√¢ncia"
    
    # ===== √ìRG√ÉOS ADMINISTRATIVOS (prioridade 4) =====
    if PROCON_RE.search(t):
        return "PROCON", "PROCON", None
    
    if RECEITA_FEDERAL_RE.search(t):
        return "Receita Federal", "RECEITA FEDERAL", None
    
    if PREFEITURA_RE.search(t):
        return "Prefeitura", "Prefeitura", None
    
    if ORGAO_ADMIN_RE.search(t):
        return "√ìrg√£o Administrativo", "√ìRG√ÉO ADMINISTRATIVO", None
    
    return None, None, None

def _strip_id(line: str) -> str:
    # remove ‚ÄúCPF ‚Ä¶‚Äù, ‚ÄúCNPJ ‚Ä¶‚Äù, refs de p√°gina e lixo comum
    s = re.sub(PESSOA_FISICA_RE, "", line)
    s = re.sub(PESSOA_JURIDICA_RE, "", s)
    s = re.sub(r"PAGINA?_CAPA_PROCESSO_PJE", "", s, flags=re.I)
    return normalize(s)

def _cpf_cnpj_near(line: str) -> Optional[str]:
    m = PESSOA_FISICA_RE.search(line)
    if m: return m.group(2)
    m = PESSOA_JURIDICA_RE.search(line)
    if m: return m.group(2)
    return None

def parse_cliente_parte(text: str, cliente_hint: Optional[str] = None) -> Dict[str, str]:
    """
    Mapeia corretamente parte interessada (cliente) e parte adversa.
    
    ‚úÖ SUPORTE A M√öLTIPLOS RECLAMADOS: Quando h√° m√∫ltiplos reclamados (ex: pessoa f√≠sica + empresa),
    prioriza a pessoa jur√≠dica (empresa) como cliente.
    
    ‚úÖ NOVO: M√öLTIPLOS CLIENTES NO POLO: Quando h√° m√∫ltiplos clientes conhecidos no polo reclamado
    (ex: CBSI + CSN), aplica regra de prioridade e retorna ambos (principal + secund√°rio).
    
    Args:
        text: Texto do PDF
        cliente_hint: Dica opcional do cliente (DEPRECATED - mantido por compatibilidade)
    
    Returns:
        Dicion√°rio com campos legados (retrocompatibilidade) + novos campos opcionais:
        
        Legados:
        - nome_reclamado: Nome bruto do RECLAMADO extra√≠do (prioriza PJ)
        - nome_reclamante: Nome bruto do RECLAMANTE extra√≠do
        - parte_interessada: Cliente identificado (com heur√≠stica)
        - parte_adversa_nome: Parte adversa identificada
        - parte: Posi√ß√£o do cliente (RECLAMADO/RECLAMANTE)
        - posicao_parte_interessada: Alias de 'parte'
        
        Novos (opcionais):
        - cliente_principal: Cliente com maior prioridade (ex: "CBSI")
        - cliente_secundario: Segundo cliente se existir (ex: "CSN") ou None
        - clientes_encontrados: Lista de todos os clientes conhecidos detectados
    """
    # Importa√ß√µes lazy para evitar circular import
    from extractors.brand_map import find_cliente_by_parte_interessada
    
    t = text or ""
    reclte = RECLAMANTE_RE.search(t)
    
    # ‚úÖ BUSCA TODOS OS RECLAMADOS (n√£o apenas o primeiro)
    todos_reclamados = RECLAMADO_RE.findall(t)
    
    # ‚úÖ NOVO: Captura o TERMO ORIGINAL usado no PDF (R√âU, AUTOR, RECLAMADO, etc)
    termo_parte_autora = None
    termo_parte_reclamada = None
    
    if reclte:
        # Extrai o label antes dos dois pontos (AUTOR:, RECLAMANTE:, etc)
        match_label = re.search(r'(RECLAMANTE|RECORRENTE|AUTOR|APELANTE|AGRAVANTE|EMBARGANTE|EXEQUENTE|IMPETRANTE|IMPUGNANTE|DENUNCIANTE|EXCIPIENTE|OPOENTE|REQUERENTE|SUSCITANTE|NOTIFICANTE|INTERPELANTE|DEMANDANTE|DEPRECANTE|AUTUANTE|HABILITANTE|INVENTARIANTE|CONSIGNANTE|ALIMENTANTE|INTERDITANTE|RECOVINTE|REQUENTE)\s*[:\-]', reclte.group(0), re.I)
        if match_label:
            termo_parte_autora = match_label.group(1).upper()
    
    # üîí BUSCA O LABEL DA PARTE RECLAMADA - Itera por todos os matches at√© achar v√°lido
    # Lista de TODOS os 61 labels conhecidos do eLaw (para filtrar "PARTES:" como t√≠tulo)
    KNOWN_LABELS = {
        # Polo ativo (autores)
        "RECLAMANTE", "RECORRENTE", "AUTOR", "APELANTE", "AGRAVANTE", "EMBARGANTE",
        "EXEQUENTE", "IMPETRANTE", "IMPUGNANTE", "DENUNCIANTE", "EXCIPIENTE", "OPOENTE",
        "REQUERENTE", "SUSCITANTE", "NOTIFICANTE", "INTERPELANTE", "DEMANDANTE",
        "DEPRECANTE", "AUTUANTE", "HABILITANTE", "INVENTARIANTE", "CONSIGNANTE",
        "ALIMENTANTE", "INTERDITANTE", "RECOVINTE", "REQUENTE",
        # Polo passivo (r√©us)
        "RECLAMADO", "RECORRIDO", "R√âU", "REU", "APELADO", "AGRAVADO", "EMBARGADO",
        "EXECUTADO", "IMPETTRADO", "IMPUGNADO", "DENUNCIADO", "EXCEPTO", "REQUERIDO",
        "SUSCITADO", "NOTIFICADO", "INTERPELADO", "DEMANDADO", "DEPRECADO", "AUTUADO",
        "HABILITADA", "INVENTARIADO", "CONSIGNADOV", "INTERDITADO", "RECOVINDO",
        "OPOSTO", "BENEFICI√ÅRIO", "BENEFICIARIO", "CONFINANTE", "CREDOR", "DEVEDOR",
        "FAL√äNCIA", "FALENCIA", "HABTE", "INVENT", "REQT", "TERCEIRO INTERESSADO",
        # Outros
        "ADVOGADO"
    }
    
    # Itera por TODOS os matches at√© encontrar um label v√°lido (n√£o "PARTES:" como t√≠tulo)
    for reclamado_match_full in RECLAMADO_RE.finditer(t):
        match_label = re.search(r'(RECLAMADO|RECORRIDO|R[√âE]U|REU|APELADO|AGRAVADO|EMBARGADO|EXECUTADO|IMPETTRADO|IMPUGNADO|DENUNCIADO|EXCEPTO|REQUERIDO|SUSCITADO|NOTIFICADO|INTERPELADO|DEMANDADO|DEPRECADO|AUTUADO|HABILITADA|INVENTARIADO|CONSIGNADOV|INTERDITADO|RECOVINDO|OPOSTO|BENEFICI[√ÅA]RIO|CONFINANTE|CREDOR|DEVEDOR|FAL[√äE]NCIA|HABTE|INVENT|ADVOGADO|PARTES|REQT|TERCEIRO\s+INTERESSADO)\s*[:\-]', reclamado_match_full.group(0), re.I)
        if match_label:
            label_candidato = match_label.group(1).upper()
            
            # üîí FILTRO INTELIGENTE: Ignora "PARTES:" quando √© apenas t√≠tulo de se√ß√£o
            # Problema: "Partes:\nAUTOR: Nome" casa com regex e captura "AUTOR: Nome" como valor
            # Solu√ß√£o: Se valor capturado COME√áA COM outro label conhecido, √© t√≠tulo de se√ß√£o
            if label_candidato == "PARTES":
                valor_apos_partes = reclamado_match_full.group(1).strip().upper()
                
                # Se valor come√ßa com qualquer label conhecida, "PARTES:" era apenas t√≠tulo - SKIP
                if any(valor_apos_partes.startswith(lbl) for lbl in KNOWN_LABELS):
                    continue  # Pula este match e tenta o pr√≥ximo
            
            # üîí FILTRO: Ignora "ADVOGADO:" pois n√£o √© posi√ß√£o de parte interessada
            if label_candidato == "ADVOGADO":
                continue  # Pula e tenta o pr√≥ximo
            
            # Label v√°lido encontrado!
            termo_parte_reclamada = label_candidato
            break  # Para de iterar
    
    nome_reclamante = _strip_id(reclte.group(1)) if reclte else ""
    
    # Limpa nomes dos reclamados
    reclamados_limpos = []
    for recldo_nome in todos_reclamados:
        nome_limpo = _strip_id(recldo_nome)
        # corta ru√≠do comum
        for tok in (r"\bADVOGADO\b", r"\bRECLAMADO\b", r"\bRECLAMANTE\b"):
            nome_limpo = re.split(tok, nome_limpo, flags=re.I)[0].strip()
        if nome_limpo:
            reclamados_limpos.append(nome_limpo)
    
    # ‚úÖ NOVO: Detecta TODAS as partes interessadas conhecidas no polo reclamado
    partes_conhecidas = []
    cliente_detectado = None
    clientes_detectados = []  # Mantido para retrocompatibilidade
    
    for nome in reclamados_limpos:
        cliente = find_cliente_by_parte_interessada(nome, threshold=85)
        if cliente:
            partes_conhecidas.append(nome)
            if not cliente_detectado:
                cliente_detectado = cliente  # Todos pertencem ao mesmo cliente (ex: CSN)
            # Mant√©m estrutura legada
            clientes_detectados.append({"cliente": cliente, "parte": nome})
    
    # ‚úÖ NOVO: Aplica regra de prioridade se h√° m√∫ltiplas partes (ex: CBSI + CSN MINERA√á√ÉO)
    from extractors.client_priority import assign_primary_secondary_partes
    parte_principal, parte_secundaria = assign_primary_secondary_partes(partes_conhecidas)
    
    # Mant√©m vari√°veis legadas para retrocompatibilidade
    # IMPORTANTE: Mapeamos as PARTES para os campos legados de "cliente" para n√£o quebrar consumidores
    cliente_principal = parte_principal  # Parte priorit√°ria (ex: "CBSI LTDA")
    cliente_secundario = parte_secundaria  # Segunda parte se existir (ex: "CSN MINERA√á√ÉO")
    
    # ‚úÖ ESTRAT√âGIA DE PRIORIZA√á√ÉO (ORDEM IMPORTA):
    # 1¬∫: Se h√° cliente conhecido com maior prioridade, usa ele
    # 2¬∫: Sen√£o, busca qualquer empresa (PJ com CNPJ ou sufixos LTDA/SA)
    # 3¬∫: Se n√£o achou nada, pega o √∫ltimo reclamado (fallback)
    
    nome_reclamado = ""
    id_reclamado = None
    
    # 1¬∫ PRIORIDADE: Cliente conhecido detectado
    if parte_principal:
        nome_reclamado = parte_principal
        # Busca CNPJ do cliente conhecido
        nome_original = [n for n in todos_reclamados if _strip_id(n) == parte_principal]
        if nome_original:
            id_reclamado = _cpf_cnpj_near(nome_original[0])
    
    # 2¬∫ PRIORIDADE: Qualquer empresa com CNPJ ou indicadores (LTDA, S.A, etc)
    if not nome_reclamado:
        for nome in reclamados_limpos:
            # Busca CNPJ no nome original (antes de limpar)
            nome_original = [n for n in todos_reclamados if _strip_id(n) == nome]
            texto_busca = nome_original[0] if nome_original else nome
            
            id_temp = _cpf_cnpj_near(texto_busca)
            if id_temp and len(_digits(id_temp)) == 14:
                # √â CNPJ (empresa)
                nome_reclamado = nome
                id_reclamado = id_temp
                break
            elif "COMPANHIA" in nome.upper() or "LTDA" in nome.upper() or "S.A" in nome.upper() or "EIRELI" in nome.upper():
                # Tem indicador de empresa
                nome_reclamado = nome
                id_reclamado = id_temp or _cpf_cnpj_near(texto_busca)
                break
    
    # 3¬∫ PRIORIDADE: Fallback - √∫ltimo reclamado
    if not nome_reclamado and reclamados_limpos:
        nome_reclamado = reclamados_limpos[-1]
        nome_original = [n for n in todos_reclamados if _strip_id(n) == nome_reclamado]
        if nome_original:
            id_reclamado = _cpf_cnpj_near(nome_original[0])
    
    # Limpa reclamante
    for tok in (r"\bADVOGADO\b", r"\bRECLAMADO\b", r"\bRECLAMANTE\b"):
        nome_reclamante = re.split(tok, nome_reclamante, flags=re.I)[0].strip()

    id_reclamante = _cpf_cnpj_near(reclte.group(0)) if reclte else None

    # Detec√ß√£o h√≠brida: CPF/CNPJ + padr√µes de nome
    reclamante_pf = bool(id_reclamante and len(_digits(id_reclamante)) == 11)
    reclamado_pj  = bool(id_reclamado and len(_digits(id_reclamado)) == 14) or ("COMPANHIA" in nome_reclamado.upper())
    
    # ‚úÖ FIX CR√çTICO: Detec√ß√£o inteligente quando CPF/CNPJ ausente
    # Se n√£o tem CPF mas nome indica PF, marca como PF
    if not reclamante_pf and is_pessoa_fisica(nome_reclamante):
        reclamante_pf = True
    # Se n√£o tem CNPJ mas nome indica PJ, marca como PJ
    if not reclamado_pj and is_pessoa_juridica(nome_reclamado):
        reclamado_pj = True
    
    # ‚úÖ FIX CR√çTICO: Se detectamos cliente conhecido, for√ßamos reclamado_pj = True
    # Isso garante que entramos no branch correto mesmo quando CNPJ n√£o tem label "CNPJ:"
    if parte_principal and not reclamado_pj:
        reclamado_pj = True

    out: Dict[str, str] = {}
    
    # ‚úÖ SEMPRE exp√µe os nomes brutos para permitir extra√ß√£o gen√©rica
    out["nome_reclamado"] = nome_reclamado
    out["nome_reclamante"] = nome_reclamante

    # Heur√≠stica: Se reclamante √© PF OU reclamado √© PJ ‚Üí cliente √© RECLAMADO (caso trabalhista t√≠pico)
    if reclamante_pf or reclamado_pj:
        # ‚úÖ USA O TERMO ORIGINAL DO PDF (R√âU, RECLAMADO, etc) ao inv√©s de normalizar
        termo_final = termo_parte_reclamada if termo_parte_reclamada else "RECLAMADO"
        out["parte"] = out["posicao_parte_interessada"] = termo_final
        
        # ‚úÖ PRIORIZA: Se temos cliente conhecido (parte_principal), usa ele. Caso contr√°rio, usa nome_reclamado
        parte_a_usar = parte_principal if parte_principal else nome_reclamado
        
        out["parte_interessada"] = parte_a_usar or "Cliente N√£o Identificado"
        out["parte_adversa_nome"] = nome_reclamante or "PARTE ADVERSA"
        
        # ‚úÖ DETEC√á√ÉO INTELIGENTE: CPF/CNPJ primeiro, fallback para padr√µes de nome, default PF (trabalhista)
        if reclamante_pf:
            out["parte_adversa_tipo"] = "PESSOA FISICA"
        elif is_pessoa_juridica(nome_reclamante):
            out["parte_adversa_tipo"] = "PESSOA JURIDICA"
        else:
            # Fallback: assumir PF (padr√£o em a√ß√µes trabalhistas, minimiza risco regulat√≥rio)
            out["parte_adversa_tipo"] = "PESSOA FISICA"
        
        out["cpf_cnpj_parte_adversa"] = _digits(id_reclamante) if id_reclamante else ""
        
        # ‚úÖ NOVO: Adiciona campos de m√∫ltiplas partes interessadas (opcionais)
        out["parte_interessada_principal"] = parte_principal
        out["outra_parte_interessada"] = parte_secundaria
        out["cliente_detectado"] = cliente_detectado
        # Campos legados (deprecated mas mantidos por compatibilidade)
        out["cliente_principal"] = cliente_principal
        out["cliente_secundario"] = cliente_secundario
        out["clientes_encontrados"] = [c["cliente"] for c in clientes_detectados] if clientes_detectados else []
        
        return out

    # Fallback: Verifica se cliente_hint (legado) est√° no RECLAMADO
    if cliente_hint and nome_reclamado and (cliente_hint.lower() in nome_reclamado.lower()):
        # ‚úÖ USA O TERMO ORIGINAL DO PDF (R√âU, RECLAMADO, etc) ao inv√©s de normalizar
        termo_final = termo_parte_reclamada if termo_parte_reclamada else "RECLAMADO"
        out["parte"] = out["posicao_parte_interessada"] = termo_final
        out["parte_interessada"] = nome_reclamado or cliente_hint
        out["parte_adversa_nome"] = nome_reclamante or "PARTE ADVERSA"
        
        # ‚úÖ DETEC√á√ÉO INTELIGENTE: CPF/CNPJ primeiro, fallback para padr√µes de nome, default PF (trabalhista)
        if reclamante_pf:
            out["parte_adversa_tipo"] = "PESSOA FISICA"
        elif is_pessoa_juridica(nome_reclamante):
            out["parte_adversa_tipo"] = "PESSOA JURIDICA"
        else:
            # Fallback: assumir PF (padr√£o em a√ß√µes trabalhistas, minimiza risco regulat√≥rio)
            out["parte_adversa_tipo"] = "PESSOA FISICA"
        
        out["cpf_cnpj_parte_adversa"] = _digits(id_reclamante) if id_reclamante else ""
        
        # ‚úÖ NOVO: Adiciona campos de m√∫ltiplas partes interessadas (opcionais)
        out["parte_interessada_principal"] = parte_principal
        out["outra_parte_interessada"] = parte_secundaria
        out["cliente_detectado"] = cliente_detectado
        # Campos legados (deprecated mas mantidos por compatibilidade)
        out["cliente_principal"] = cliente_principal
        out["cliente_secundario"] = cliente_secundario
        out["clientes_encontrados"] = [c["cliente"] for c in clientes_detectados] if clientes_detectados else []
        
        return out

    # Caso padr√£o: cliente como RECLAMANTE (menos comum em casos trabalhistas)
    # ‚úÖ USA O TERMO ORIGINAL DO PDF (AUTOR, RECLAMANTE, etc) ao inv√©s de normalizar
    termo_final_autora = termo_parte_autora if termo_parte_autora else "RECLAMANTE"
    out["parte"] = out["posicao_parte_interessada"] = termo_final_autora
    out["parte_interessada"] = nome_reclamante or "Cliente N√£o Identificado"
    out["parte_adversa_nome"] = nome_reclamado or "PARTE ADVERSA"
    
    # ‚úÖ DETEC√á√ÉO INTELIGENTE: CNPJ primeiro, fallback para padr√µes de nome, default PJ (adverso t√≠pico)
    if reclamado_pj:
        out["parte_adversa_tipo"] = "PESSOA JURIDICA"
    elif is_pessoa_fisica(nome_reclamado):
        out["parte_adversa_tipo"] = "PESSOA FISICA"
    else:
        # Fallback: neste branch raro (cliente=reclamante), adverso geralmente √© PJ
        out["parte_adversa_tipo"] = "PESSOA JURIDICA"
    
    out["cpf_cnpj_parte_adversa"] = _digits(id_reclamado) if id_reclamado else ""
    
    # ‚úÖ NOVO: Adiciona campos de m√∫ltiplos clientes (opcionais)
    out["cliente_principal"] = cliente_principal or None
    out["cliente_secundario"] = cliente_secundario or None
    out["clientes_encontrados"] = [c["cliente"] for c in clientes_detectados] if clientes_detectados else []
    
    return out

# Assunto/Objeto
def assunto_from_text(t: str) -> Optional[str]:
    if re.search(r"reclama[c√ß][a√£]o\s+trabalhista", (t or ""), re.I):
        return "Reclama√ß√£o Trabalhista No Rito Ordin√°rio"
    return None

def objeto_from_text(t: str) -> Optional[str]:
    if re.search(r"verbas?\s+rescis[o√≥]rias", (t or ""), re.I):
        return "Verbas rescis√≥rias"
    return None

# --- Adi√ß√µes em extractors/regex_utils.py ---

def parse_numero_orgao_from_cnj(cnj: str) -> str | None:
    """
    Retorna OOOO do CNJ  nnnnnnn-dd.aaaa.j.tr.oooo  -> oooo
    """
    if not cnj:
        return None
    m = re.search(r'\b\d{7}-\d{2}\.\d{4}\.\d\.\d{2}\.(\d{4})\b', cnj)
    return m.group(1) if m else None

def parse_comarca(text: str, cnj: str = None) -> str | None:
    """
    Extrai Comarca/Cidade do texto do PDF trabalhista.
    
    Suporta m√∫ltiplos formatos:
    - "F√ìRUM TRABALHISTA DE JO√ÉO PESSOA - PB"
    - "F√≥rum Trabalhista de Campina Grande/PB"
    - "Comarca de Jo√£o Pessoa"
    - "1¬™ Vara do Trabalho de Guarabira"
    - "Justi√ßa do Trabalho de Campina Grande"
    - "Ju√≠zo de Patos - PB"
    - "PODER JUDICI√ÅRIO - JUSTI√áA DO TRABALHO - TRT 13¬™ REGI√ÉO - VARA DO TRABALHO DE GUARABIRA"
    
    Returns:
        "Cidade - UF" ou apenas "Cidade" se UF n√£o encontrada
    """
    if not text:
        return None
    
    t = text
    cidade = None
    uf = None
    
    # Padr√£o 1: F√ìRUM TRABALHISTA DE CIDADE - UF
    m = re.search(r'F[√ìO]RUM\s+TRABALHISTA\s+DE\s+([A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√áa-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+?)\s*[-‚Äì/]\s*([A-Z]{2})\b', t, re.I)
    if m:
        cidade, uf = m.group(1).strip(), m.group(2).strip().upper()
    
    # Padr√£o 2: Comarca de CIDADE (com ou sem UF)
    if not cidade:
        m = re.search(r'\bComarca\s+(?:de|do|da)\s+([A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√áa-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+?)(?:\s*[-‚Äì/]\s*([A-Z]{2}))?\b', t, re.I)
        if m:
            cidade = m.group(1).strip()
            if m.group(2):
                uf = m.group(2).strip().upper()
    
    # Padr√£o 3: Vara do Trabalho de CIDADE
    if not cidade:
        m = re.search(r'\bVara\s+do\s+Trabalho\s+de\s+([A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√áa-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+?)(?:\s*[-‚Äì/]\s*([A-Z]{2}))?\b', t, re.I)
        if m:
            cidade = m.group(1).strip()
            if m.group(2):
                uf = m.group(2).strip().upper()
    
    # Padr√£o 4: Foro/Ju√≠zo de CIDADE
    if not cidade:
        m = re.search(r'\b(?:Foro|Ju[√≠i]zo)\s+(?:Trabalhista\s+)?(?:de|do|da)\s+([A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√áa-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+?)(?:\s*[-‚Äì/]\s*([A-Z]{2}))?\b', t, re.I)
        if m:
            cidade = m.group(1).strip()
            if m.group(2):
                uf = m.group(2).strip().upper()
    
    # Padr√£o 5: Justi√ßa do Trabalho de CIDADE
    if not cidade:
        m = re.search(r'\bJusti[√ßc]a\s+do\s+Trabalho\s+de\s+([A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√áa-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+?)(?:\s*[-‚Äì/]\s*([A-Z]{2}))?\b', t, re.I)
        if m:
            cidade = m.group(1).strip()
            if m.group(2):
                uf = m.group(2).strip().upper()
    
    # Padr√£o 6: CIDADE/UF ou CIDADE-UF em contexto judicial (ex: ap√≥s TRT)
    if not cidade:
        m = re.search(r'(?:TRT|Tribunal|Regi[√£a]o)[^\n]{0,50}?\bde\s+([A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß]+(?:\s+[A-Z√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√°√¢√£√©√™√≠√≥√¥√µ√∫√ß]+)*)\s*[-‚Äì/]\s*([A-Z]{2})\b', t, re.I)
        if m:
            cidade, uf = m.group(1).strip(), m.group(2).strip().upper()
    
    if cidade:
        # Limpar cidade (remover termos irrelevantes)
        cidade = re.split(r'\bsegredo\b|\bju[i√≠]za?\b|\bProcesso\b|\bATOS\b|\bPJ[eE]\b', cidade, flags=re.I)[0].strip()
        cidade = re.sub(r'\s{2,}', ' ', cidade)
        cidade = re.sub(r'\s*[-‚Äì/]\s*$', '', cidade).strip()
        
        # Normalizar capitaliza√ß√£o
        cidade = cidade.title()
        
        # Buscar UF se ainda n√£o encontrada
        if not uf:
            uf = extract_estado_sigla(t, cnj) or ""
        
        return f"{cidade} - {uf}" if uf else cidade
    
    return None


def extract_cpf_cnpj_near(text: str, name: str, window: int = 200) -> str | None:
    """
    Procura CPF/CNPJ numa janela ao redor do nome informado.
    Normaliza espa√ßos/acentos e, se n√£o achar ‚Äúperto‚Äù, usa o √∫nico CPF/CNPJ do PDF.
    """
    if not text or not name:
        return None

    def _norm(s: str) -> str:
        s = re.sub(r"\s+", " ", s or "")
        try:
            from unicodedata import normalize as _u
            s = _u("NFKD", s).encode("ascii", "ignore").decode("ascii")
        except Exception:
            pass
        return s

    T = _norm(text)
    N = _norm(name)

    for m in re.finditer(re.escape(N), T, flags=re.I):
        i = m.end()
        snip = T[max(0, i - window): i + window]
        mcpf = re.search(_CPF_RE, snip)
        if mcpf:
            return _digits(mcpf.group(1))
        mcnpj = re.search(_CNPJ_RE, snip)
        if mcnpj:
            return _digits(mcnpj.group(1))

    all_ids = re.findall(_CPF_RE, T) + re.findall(_CNPJ_RE, T)
    if len(all_ids) == 1:
        return _digits(all_ids[0])
    return None

def subobj_from_text(text: str) -> str:
    """
    Amplia padr√µes de sub-objeto. Se nada for encontrado,
    usa heur√≠stica com termos comuns do trabalhista.
    """
    t = (text or "").replace("\n", " ")

    # Sub-objeto expl√≠cito
    m = re.search(r'(?:sub-?objeto|assunto\s+complementar|pedido(?:\s+principal)?)\s*[:\-]\s*([^\n\r]{3,160})', t, re.I)
    if m:
        return m.group(1).strip()

    # Heur√≠sticas relevantes
    if re.search(r'verbas?\s+rescis[√≥o]rias?', t, re.I):
        return 'Verbas rescis√≥rias'

    if re.search(r'horas?\s+extras?', t, re.I):
        return 'Horas extras'

    return ""

def _digits(s: str | None) -> str:
    return re.sub(r'\D', '', s or '')


def extract_data_hora_audiencia(text: str) -> tuple[Optional[str], Optional[str]]:
    """
    Extrai data e hora de audi√™ncia do texto do PDF.
    
    2025-12-01: OTIMIZA√á√ÉO COMPLETA - Plano Batman
    - Busca em contexto de audi√™ncia
    - Suporta m√∫ltiplos formatos de data/hora
    - Valida√ß√£o de data
    
    Formatos de hora suportados:
    - "13:30", "13h30", "13 h 30", "13h", "√†s 13h30"
    
    Returns:
        Tuple (data, hora) no formato ("DD/MM/AAAA", "HH:MM") ou (None, None)
    """
    logger = _extract_logger
    
    if not text:
        return None, None
    
    # NORMALIZA√á√ÉO
    text_norm = normalize_text(text)
    
    def format_date(raw: str) -> str:
        return raw.strip().replace('.', '/').replace('-', '/')
    
    def extract_hora_from_context(context: str) -> Optional[str]:
        """Extrai hora do contexto em v√°rios formatos portugueses.
        
        IMPORTANTE: S√≥ retorna hora se minutos estiverem expl√≠citos.
        N√£o fabrica ":00" para horas sem minutos - isso viola ZERO ERRORS.
        """
        # Padr√µes de hora COM minutos expl√≠citos (ordem de prioridade):
        hora_patterns = [
            r'(\d{1,2})\s*[hH]\s*(\d{2})',  # 13h30, 13 h 30, 13H30
            r'(\d{1,2})\s*:\s*(\d{2})',  # 13:30
            r'[√†a]s?\s+(\d{1,2})\s*[hH]\s*(\d{2})',  # √†s 13h30
            r'[√†a]s?\s+(\d{1,2})\s*:\s*(\d{2})',  # √†s 13:30
        ]
        
        for pattern in hora_patterns:
            match = re.search(pattern, context, re.I)
            if match:
                h = match.group(1).zfill(2)
                m = match.group(2)
                return f"{h}:{m}"
        
        # NOTA: Removido fallback para horas sem minutos (9h, 10h)
        # Fabricar ":00" viola a regra ZERO ERRORS
        # Se precisar da hora sem minutos, retornar None e deixar o usu√°rio preencher
        
        return None
    
    # Padr√µes de data
    data_pattern = r'(\d{2}[/.\-]\d{2}[/.\-]\d{4})'
    
    # Buscar em contexto de audi√™ncia
    lines = text_norm.split('\n')
    
    for i, line in enumerate(lines):
        if re.search(r'audi[√™e]ncia|design(?:o|a|ada?)|realizar|marcad[oa]|convoc', line, re.I):
            # Contexto: 3 linhas antes e 5 depois
            context_lines = lines[max(0, i-3):min(i+6, len(lines))]
            context = ' '.join(context_lines)
            
            # Buscar data
            data_match = re.search(data_pattern, context)
            if data_match:
                data = format_date(data_match.group(1))
                if not is_valid_brazilian_date(data):
                    continue
                
                # Buscar hora
                hora = extract_hora_from_context(context)
                
                logger.debug(f"[AUDIENCIA] ‚úÖ Data: {data}, Hora: {hora}")
                return data, hora
    
    # Fallback: padr√£o espec√≠fico de designa√ß√£o COM minutos expl√≠citos
    # NOTA: S√≥ aceita padr√µes que incluem minutos para evitar fabricar ":00"
    designacao_patterns = [
        r'design[oa]\s+audi[√™e]ncia[^,]*para\s+(?:o\s+dia\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})[,\s]+[√†a]s?\s+(\d{1,2})\s*[h:]\s*(\d{2})',
        r'audi[√™e]ncia\s+(?:marcada|designada)\s+para\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})[,\s]+[√†a]s?\s+(\d{1,2})\s*[h:]\s*(\d{2})',
        r'realizar[√°a]\s+audi[√™e]ncia[^,]*em\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})[,\s]+[√†a]s?\s+(\d{1,2})\s*[h:]\s*(\d{2})',
    ]
    
    for pattern in designacao_patterns:
        match = re.search(pattern, text_norm, re.I)
        if match:
            data = format_date(match.group(1))
            if not is_valid_brazilian_date(data):
                continue
            
            # S√≥ retorna hora se minutos estiverem presentes
            if match.group(3):
                h = match.group(2).zfill(2)
                m = match.group(3)
                hora = f"{h}:{m}"
            else:
                hora = None  # N√£o fabrica :00
            
            logger.debug(f"[AUDIENCIA] ‚úÖ Designa√ß√£o: Data: {data}, Hora: {hora}")
            return data, hora
    
    logger.debug("[AUDIENCIA] ‚ùå Data/hora n√£o encontrada")
    return None, None


def extract_envolvido_audiencia(text: str) -> Optional[str]:
    """
    Extrai os envolvidos que devem comparecer √† audi√™ncia do texto do PDF.
    
    Mapeia men√ß√µes encontradas no PDF para valores do dropdown eLaw:
    - "Advogado e Preposto" ‚Üí quando menciona ambos
    - "Advogado" ‚Üí quando menciona apenas advogado
    - "Preposto" ‚Üí quando menciona apenas preposto
    - "Dispensadas as partes" ‚Üí quando dispensa comparecimento
    - "Facultada as partes" ‚Üí quando faculta comparecimento
    
    Args:
        text: Texto completo do PDF
        
    Returns:
        String do envolvido ou None se n√£o detectado
    """
    if not text:
        return None
    
    text_upper = text.upper()
    
    # Procurar padr√µes de envolvidos pr√≥ximos ao contexto de audi√™ncia
    lines = text.split('\n')
    
    for i, line in enumerate(lines):
        if re.search(r'audi[e√™]ncia|audiencia', line, re.I):
            # Contexto: pegar 5 linhas antes e depois
            context_lines = lines[max(0, i-5):min(i+6, len(lines))]
            context = ' '.join(context_lines).upper()
            
            # Padr√µes espec√≠ficos (ordem de prioridade)
            
            # 1. Dispensadas as partes
            if re.search(r'DISPENSAD[OA]S?\s+AS\s+PARTES|COMPARECIMENTO\s+DISPENSADO', context):
                return "Dispensadas as partes"
            
            # 2. Facultada as partes
            if re.search(r'FACULTAD[OA]S?\s+AS\s+PARTES|COMPARECIMENTO\s+FACULTADO', context):
                return "Facultada as partes"
            
            # 3. Advogado e Preposto (deve vir antes dos individuais)
            if re.search(r'ADVOGADO.*PREPOSTO|PREPOSTO.*ADVOGADO', context):
                return "Advogado e Preposto"
            
            # 4. Preposto
            if re.search(r'\bPREPOSTO\b', context):
                return "Preposto"
            
            # 5. Advogado
            if re.search(r'\bADVOGAD[OA]S?\b', context):
                return "Advogado"
    
    # Padr√µes gerais no documento (sem contexto de audi√™ncia)
    if re.search(r'INTIM[AE].*ADVOGAD[OA].*PREPOSTO|INTIM[AE].*PREPOSTO.*ADVOGAD[OA]', text_upper):
        return "Advogado e Preposto"
    
    if re.search(r'CARTA\s+DE\s+PREPOSTO|ANEXAR\s+.*PREPOSTO', text_upper):
        return "Preposto"
    
    # Default para audi√™ncias trabalhistas: geralmente Advogado e Preposto
    if re.search(r'audi[e√™]ncia.*inicial|audiencia.*inicial', text, re.I):
        return "Advogado e Preposto"
    
    return None

def extract_subtipo_audiencia(text: str) -> Optional[str]:
    """
    Extrai o subtipo de audi√™ncia do texto do PDF.
    
    Mapeia men√ß√µes encontradas no PDF para valores do dropdown eLaw:
    - "Una" / "UNA" ‚Üí "Audi√™ncia Inicial Una (IU)"
    - "N√£o-Una" / "Inicial N√£o Una" ‚Üí "Audi√™ncia Inicial N√£o-Una (INU)"
    - "Tentativa de Concilia√ß√£o" / "ITC" ‚Üí "Audi√™ncia Inicial Apenas Tentativa Concilia√ß√£o (ITC)"
    - "Homologa√ß√£o de Acordo" ‚Üí "AUDI√äNCIA HOMOLOGA√á√ÉO DE ACORDO (HA)"
    
    Args:
        text: Texto completo do PDF
        
    Returns:
        String do subtipo ou None se n√£o detectado
    """
    if not text:
        return None
    
    # Procurar padr√µes de audi√™ncia com contexto
    lines = text.split('\n')
    
    for i, line in enumerate(lines):
        if re.search(r'audi[e√™]ncia|audiencia', line, re.I):
            # Contexto: pegar 3 linhas antes e depois
            context_lines = lines[max(0, i-3):min(i+4, len(lines))]
            context = ' '.join(context_lines).upper()
            
            # Padr√µes espec√≠ficos (ordem de prioridade)
            if re.search(r'\bUNA\b.*\bTELEPRESENCIAL\b|\bTELEPRESENCIAL\b.*\bUNA\b', context):
                return "Audi√™ncia Inicial Una (IU)"
            
            if re.search(r'\bUNA\b(?!\s*[-‚Äì]\s*N[√ÉA]O)', context):
                return "Audi√™ncia Inicial Una (IU)"
            
            if re.search(r'N[√ÉA]O\s*[-‚Äì]?\s*UNA|INICIAL\s+N[√ÉA]O\s+UNA', context):
                return "Audi√™ncia Inicial N√£o-Una (INU)"
            
            if re.search(r'APENAS\s+TENTATIVA\s+CONCILIA[√áC][√ÉA]O|ITC\b', context):
                return "Audi√™ncia Inicial Apenas Tentativa Concilia√ß√£o (ITC)"
            
            if re.search(r'TENTATIVA\s+DE?\s+CONCILIA[√áC][√ÉA]O|CONCILIAT[√ìO]RIA', context):
                return "Audi√™ncia Inicial Apenas Tentativa Concilia√ß√£o (ITC)"
            
            if re.search(r'HOMOLOGA[√áC][√ÉA]O\s+DE?\s+ACORDO', context):
                return "AUDI√äNCIA HOMOLOGA√á√ÉO DE ACORDO (HA)"
            
            if re.search(r'INSTRU[√áC][√ÉA]O', context):
                return "AUDI√äNCIA ENCERRAMENTO INSTRU√á√ÉO (ENCINSTR)"
            
            if re.search(r'LEITURA\s+DE?\s+SENTEN[√áC]A', context):
                return "Audi√™ncia Leitura de Senten√ßa (LS)"
    
    return None

def extract_link_audiencia(text: str) -> Optional[str]:
    """
    Extrai link de audi√™ncia telepresencial (Zoom, Google Meet, Teams, etc) do texto do PDF.
    
    Procura por URLs pr√≥ximas a contextos de audi√™ncia e reconstr√≥i links quebrados em m√∫ltiplas linhas.
    
    Args:
        text: Texto completo do PDF
        
    Returns:
        URL do link de audi√™ncia ou None se n√£o encontrado
        
    Examples:
        >>> text = "Designo audi√™ncia telepresencial via Zoom: https://trt1-jus-br.zoom.us/my/vt01mac"
        >>> extract_link_audiencia(text)
        'https://trt1-jus-br.zoom.us/my/vt01mac'
    """
    if not text:
        return None
    
    # Procurar por padr√µes de audi√™ncia + link nas proximidades
    lines = text.split('\n')
    
    for i, line in enumerate(lines):
        # Se linha menciona audi√™ncia ou "plataforma ZOOM/Meet"
        if re.search(r'audi[e√™]ncia|audiencia|plataforma\s+(zoom|meet|teams)', line, re.I):
            # Procurar link nas pr√≥ximas 10 linhas (aumentado para capturar links quebrados)
            context_lines = lines[i:min(i+11, len(lines))]
            context_text = '\n'.join(context_lines)
            
            # Remover espa√ßos/quebras dentro de URLs (comum em PDFs)
            # Exemplo: "https://zoom.us/j\n/12345" ‚Üí "https://zoom.us/j/12345"
            context_clean = re.sub(r'(https?://[^\s]*)\s*/\s*', r'\1/', context_text)
            context_clean = re.sub(r'\n(?=[^\s])', '', context_clean)  # Juntar linhas quebradas
            
            # Procurar URLs de plataformas conhecidas (prioridade)
            platforms = [
                r'https?://[^\s]*zoom\.us[^\s]*',
                r'https?://meet\.google\.com[^\s]*',
                r'https?://teams\.microsoft\.com[^\s]*',
                r'https?://[^\s]*\.webex\.com[^\s]*',
            ]
            
            for platform_pattern in platforms:
                match = re.search(platform_pattern, context_clean, re.I)
                if match:
                    url = match.group(0)
                    # Limpar pontua√ß√£o final e palavras portuguesas grudadas (comum em PDFs)
                    url = re.sub(r'[,;.!?]+$', '', url)
                    url = re.sub(r'(acesso|senha|participante|reuniao|meeting)$', '', url, flags=re.I)
                    return url
            
            # Fallback: qualquer https:// pr√≥ximo a audi√™ncia
            url_match = re.search(r'https?://[^\s]+', context_clean, re.I)
            if url_match:
                url = url_match.group(0)
                # Limpar pontua√ß√£o final
                url = re.sub(r'[,;.!?]+$', '', url)
                # Filtrar se for apenas link de valida√ß√£o (n√£o √© link de audi√™ncia)
                if 'validacao' not in url and 'pjekz' not in url:
                    return url
    
    return None

# ==============================================================================
# NOVAS FUN√á√ïES DE EXTRA√á√ÉO PARA CAMPOS ADICIONAIS
# ==============================================================================

def extract_advogados(text: str) -> tuple:
    """
    Extrai advogados do reclamante (autor) e do reclamado (r√©u).
    
    Returns:
        Tupla (advogado_autor, advogado_reu)
    """
    if not text:
        return None, None
    
    advogado_autor = None
    advogado_reu = None
    
    lines = text.split('\n')
    
    # Detectar tipo de documento (inicial vs recurso)
    is_recurso = bool(re.search(r'RECORRENTE|RECORRIDO|RECURSO\s+ORDIN√ÅRIO', text, re.I))
    
    for i, line in enumerate(lines):
        # Linha com "ADVOGADO:" seguido de nome
        adv_match = re.search(r'ADVOGADO:\s*([A-Z][A-Z√Ä-√ú\s]+(?:[A-Z]+)?)', line)
        if adv_match:
            nome_advogado = adv_match.group(1).strip()
            # Limpar lixo comum
            nome_advogado = re.sub(r'\b(RECORRENTE|RECORRIDO|RECLAMANTE|RECLAMADO|ADVOGADO)\b', '', nome_advogado).strip()
            
            if nome_advogado and len(nome_advogado) > 5:
                # Verificar contexto nas linhas anteriores (at√© 3 linhas antes)
                context_lines = '\n'.join(lines[max(0, i-3):i])
                
                if is_recurso:
                    # Em recursos: RECORRENTE = autor do recurso, RECORRIDO = r√©u
                    if 'RECORRENTE' in context_lines:
                        if not advogado_autor:  # Pega o primeiro
                            advogado_autor = nome_advogado
                    elif 'RECORRIDO' in context_lines:
                        if not advogado_reu:  # Pega o primeiro
                            advogado_reu = nome_advogado
                else:
                    # Em iniciais: RECLAMANTE = autor, RECLAMADO = r√©u
                    if 'RECLAMANTE' in context_lines and 'RECLAMADO' not in context_lines:
                        if not advogado_autor:
                            advogado_autor = nome_advogado
                    elif 'RECLAMADO' in context_lines:
                        if not advogado_reu:
                            advogado_reu = nome_advogado
    
    return advogado_autor, advogado_reu


def _identificar_parte_adversa(text: str) -> tuple[str, list[str]]:
    """
    Identifica quem √© a parte adversa e retorna marcadores a buscar.
    
    Returns:
        Tupla (nome_parte_adversa, marcadores_a_buscar)
        Ex: ("FABIANA DE FATIMA GRADES", ["RECORRENTE", "FABIANA"])
    """
    # Detectar tipo de documento
    is_recurso = bool(re.search(r'Recurso\s+Ordin√°rio|RECORRENTE|RECORRIDO', text, re.I))
    
    if is_recurso:
        # Em recursos: RECORRENTE = parte adversa
        match = re.search(r'RECORRENTE:\s*([A-Z√Ä-√ú\s\.]+?)(?:\n|ADVOGADO)', text, re.I)
        if match:
            nome = match.group(1).strip()
            # Pegar primeira palavra significativa do nome (geralmente nome/sobrenome)
            palavras = [p for p in nome.split() if len(p) > 3]
            return nome, ["RECORRENTE"] + palavras[:2]
    else:
        # Em iniciais: RECLAMANTE = parte adversa
        match = re.search(r'RECLAMANTE:\s*([A-Z√Ä-√ú\s\.]+?)(?:\n|ADVOGADO)', text, re.I)
        if match:
            nome = match.group(1).strip()
            palavras = [p for p in nome.split() if len(p) > 3]
            return nome, ["RECLAMANTE"] + palavras[:2]
    
    return "", []


def extract_telefone_parte_adversa(text: str) -> str | None:
    """
    Extrai telefone da parte adversa com verifica√ß√£o rigorosa de contexto.
    Garante que o telefone pertence √† parte adversa, n√£o √† parte interessada (cliente).
    """
    if not text:
        return None
    
    # ‚úÖ PASSO 1: Identificar quem √© a parte adversa
    nome_adversa, marcadores = _identificar_parte_adversa(text)
    if not marcadores:
        return None
    
    # Buscar todos os telefones no documento
    all_telefones = re.findall(r'\(?\s*(\d{2})\s*\)?\s*9?\s*(\d{4,5})[-\s]?(\d{4})', text)
    
    for ddd, parte1, parte2 in all_telefones:
        # Validar que n√£o √© n√∫mero gen√©rico (ex: 0800, 4003, etc)
        if ddd in ['08', '40', '30', '00']:
            continue
        
        # Formatar telefone
        telefone_formatado = f"({ddd}) {parte1}-{parte2}"
        telefone_raw = f"{ddd}{parte1}{parte2}"
        
        # Encontrar contexto onde telefone aparece
        pos = text.find(telefone_raw)
        if pos < 0:
            # Tentar com formata√ß√£o
            pos = text.find(f"({ddd})")
            
        if pos < 0:
            continue
            
        context = text[max(0, pos-200):min(len(text), pos+200)]
        context_upper = context.upper()
        
        # ‚úÖ FILTRO: Verificar contexto
        marcadores_adversa_encontrados = sum(1 for m in marcadores if m in context_upper)
        
        # Contexto positivo (parte autor/reclamante)
        contexto_positivo = any(marker in context_upper for marker in [
            'PARTE AUTORA', 'RECLAMANTE', 'RECORRENTE', 'CELULAR', 'TELEFONE'
        ] + marcadores)
        
        # Contexto negativo (parte cliente)
        contexto_negativo = any(marker in context_upper for marker in [
            'GRUPO CASAS BAHIA', 'CASAS BAHIA', 'BANQI', 'CNOVA',
            'RECORRIDO', 'RECLAMADO', 'PATRONOS DO'
        ])
        
        # Telefone v√°lido se est√° em contexto positivo e n√£o negativo
        if (contexto_positivo or marcadores_adversa_encontrados >= 1) and not contexto_negativo:
            return telefone_formatado
    
    return None


def extract_email_parte_adversa(text: str) -> str | None:
    """
    Extrai email da parte adversa com verifica√ß√£o rigorosa de contexto.
    Garante que o email pertence √† parte adversa, n√£o √† parte interessada (cliente).
    
    Estrat√©gia em 2 fases:
    1. Buscar pr√≥ximo ao nome da parte adversa
    2. Buscar em contextos que mencionam "parte autora"/"reclamante" sem refer√™ncia ao cliente
    """
    if not text:
        return None
    
    # ‚úÖ PASSO 1: Identificar quem √© a parte adversa
    nome_adversa, marcadores = _identificar_parte_adversa(text)
    if not marcadores:
        return None
    
    # Detectar se √© recurso ou inicial
    is_recurso = bool(re.search(r'Recurso\s+Ordin√°rio|RECORRENTE|RECORRIDO', text, re.I))
    
    # Todos os emails encontrados no documento
    all_emails = re.findall(r'([a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,})', text, re.I)
    
    for email in all_emails:
        email = email.lower()
        
        # ‚úÖ FILTRO 1: Ignorar emails gen√©ricos de escrit√≥rios
        if any(skip in email for skip in ['contato@', 'juridico@', 'adv@', 'escritorio@', 'advocacia@']):
            continue
        
        # Encontrar contexto onde email aparece (200 chars antes e depois)
        pos = text.lower().find(email.lower())
        if pos < 0:
            continue
            
        context = text[max(0, pos-200):min(len(text), pos+200)]
        context_upper = context.upper()
        
        # ‚úÖ FILTRO 2: Verificar se est√° em contexto da parte adversa
        marcadores_adversa_encontrados = sum(1 for m in marcadores if m in context_upper)
        
        # Marcadores de contexto positivo (parte autor/reclamante)
        contexto_positivo = any(marker in context_upper for marker in [
            'PARTE AUTORA', 'RECLAMANTE', 'RECORRENTE', 'AUTOR',
        ] + marcadores)
        
        # Marcadores de contexto negativo (parte cliente/reclamado)
        contexto_negativo = any(marker in context_upper for marker in [
            'GRUPO CASAS BAHIA', 'CASAS BAHIA', 'BANQI', 'BANQ', 'CNOVA',
            'RECORRIDO', 'RECLAMADO', 'PATRONOS DO', 'ADVOGADOS DO'
        ])
        
        # ‚úÖ FILTRO 3: Email s√≥ √© v√°lido se:
        # - Est√° em contexto positivo (autor/reclamante) OU
        # - Est√° pr√≥ximo aos marcadores da parte adversa
        # E N√ÉO est√° em contexto negativo (cliente)
        if (contexto_positivo or marcadores_adversa_encontrados >= 1) and not contexto_negativo:
            return email
    
    return None


def extract_prazo(text: str) -> str | None:
    """
    Extrai prazo de intima√ß√£o/notifica√ß√£o.
    Ex: "Prazo: 15 dias", "Prazo de recurso: 8 dias"
    """
    if not text:
        return None
    
    # Buscar padr√µes de prazo
    prazo_patterns = [
        r'prazo[:\s]+([0-9]+\s*(?:dias?|meses?))',
        r'prazo\s+de\s+recurso[:\s]+([0-9]+\s*(?:dias?|meses?))',
        r'intimad[oa].*prazo\s+de\s+([0-9]+\s*(?:dias?|meses?))',
    ]
    
    for pattern in prazo_patterns:
        match = re.search(pattern, text, re.I)
        if match:
            return match.group(1).strip()
    
    return None


def extract_cpf_cnpj_parte_adversa(text: str) -> str | None:
    """
    Extrai CPF/CNPJ da parte adversa com verifica√ß√£o rigorosa de contexto.
    Usa m√∫ltiplas estrat√©gias para garantir precis√£o:
    1. Identifica janelas contextuais da parte adversa
    2. Busca CPF/CNPJ apenas nessas janelas
    3. Valida aus√™ncia de marcadores negativos (cliente)
    """
    if not text:
        return None
    
    # PASSO 1: Identificar quem √© a parte adversa
    nome_adversa, marcadores = _identificar_parte_adversa(text)
    if not marcadores or not nome_adversa:
        return None
    
    # PASSO 2: Criar janelas contextuais v√°lidas
    # Encontrar todas as ocorr√™ncias dos marcadores da parte adversa
    lines = text.split('\n')
    janelas_validas = []
    
    for i, line in enumerate(lines):
        # Se linha cont√©m marcador forte da parte adversa
        if any(m in line.upper() for m in marcadores[:2]):  # Primeiros 2 marcadores s√£o mais confi√°veis
            # Criar janela de contexto (15 linhas antes e depois)
            inicio = max(0, i - 15)
            fim = min(len(lines), i + 15)
            janela = '\n'.join(lines[inicio:fim])
            janelas_validas.append(janela)
    
    # PASSO 3: Buscar CPF/CNPJ nas janelas v√°lidas
    for janela in janelas_validas:
        janela_upper = janela.upper()
        
        # Verificar se √© uma janela segura (sem marcadores de cliente)
        marcadores_negativos = ['RECORRIDO:', 'RECLAMADO:', 'GRUPO', 'INSTITUICAO', 'COMERCIO']
        if any(neg in janela_upper for neg in marcadores_negativos):
            continue  # Pular janela com refer√™ncias ao cliente
        
        # Buscar CPF/CNPJ nesta janela espec√≠fica
        cpfs = re.findall(_CPF_RE, janela)
        cnpjs = re.findall(_CNPJ_RE, janela)
        
        # Priorizar CPF (parte adversa geralmente √© pessoa f√≠sica)
        if cpfs:
            return _digits(cpfs[0])
        if cnpjs:
            return _digits(cnpjs[0])
    
    return None


def extract_numero_processo_antigo(text: str) -> str | None:
    """
    Extrai n√∫mero de processo antigo (formato anterior ao CNJ).
    Ex: "123/2010", "456/2015"
    """
    if not text:
        return None
    
    # Padr√µes de processo antigo
    old_patterns = [
        r'processo\s+(?:anterior|antigo)[:\s]*([0-9]+/[0-9]{4})',
        r'n[√∫u]mero\s+antigo[:\s]*([0-9]+/[0-9]{4})',
    ]
    
    for pattern in old_patterns:
        match = re.search(pattern, text, re.I)
        if match:
            return match.group(1).strip()
    
    return None


# ============================================================================
# DADOS TRABALHISTAS - Extra√ß√£o de informa√ß√µes espec√≠ficas de processos trabalhistas
# ============================================================================

def extract_data_admissao(text: str) -> str | None:
    """
    Extrai data de admiss√£o do trabalhador.
    
    2025-12-01: OTIMIZA√á√ÉO COMPLETA - Plano Batman
    - Usa utilit√°rios compartilhados (normalize_text, MESES_MAP, is_invalid_date_context)
    - Novos padr√µes para formatos menos comuns
    - Valida√ß√£o de data mais robusta
    
    PRIORIDADE DE FONTES:
    1. TRCT / CTPS (tabelas estruturadas)
    2. Peti√ß√£o inicial (narrativa)
    3. M√™s por extenso
    4. Planilha de c√°lculos (fallback)
    """
    logger = _extract_logger
    
    if not text:
        return None
    
    # NORMALIZA√á√ÉO usando utilit√°rio compartilhado
    text_norm = normalize_text(text)
    text_lower = text_norm.lower()
    
    def format_date(raw: str) -> str:
        """Formata data para DD/MM/AAAA"""
        return raw.strip().replace('.', '/').replace('-', '/')
    
    def validate_and_return(match_obj, data: str, source: str) -> str | None:
        """Valida contexto e retorna data se v√°lida"""
        if is_invalid_date_context(match_obj, text_lower):
            return None
        if is_valid_brazilian_date(data):
            logger.debug(f"[DATA_ADMISSAO] ‚úÖ {source}: {data}")
            return data
        return None
    
    # ===== PRIORIDADE 1: TRCT/CTPS (alta confian√ßa) =====
    trct_patterns = [
        r'data\s+de\s+admiss[a√£]o\s*[:\s]+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'admiss[a√£]o\s*[:\s]+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'in[√≠i]cio\s+do\s+contrato\s*[:\s]+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï TRCT campo num√©rico: "02. Data de Admiss√£o 01/01/2020"
        r'\d+\.\s*(?:data\s+de\s+)?admiss[a√£]o\s*[:\s]*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï Tabela com pipe: "| Admiss√£o | 01/01/2020 |"
        r'\|\s*admiss[a√£]o\s*\|\s*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
    ]
    
    for pattern in trct_patterns:
        match = re.search(pattern, text_lower, re.I)
        if match:
            data = format_date(match.group(1))
            result = validate_and_return(match, data, "TRCT/CTPS")
            if result:
                return result
    
    # ===== PRIORIDADE 2: Narrativa com data num√©rica =====
    narrativa_patterns = [
        # "foi admitido/contratado em DD/MM/AAAA"
        r'foi\s+(?:admitid[oa]|contratad[oa])\s+(?:pela\s+)?(?:reclamada\s+)?(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # "admitido na reclamada em DD/MM/AAAA"
        r'(?:admitid[oa]|contratad[oa])\s+(?:na|pela)\s+(?:reclamada|empresa|r[√©e])[,\s]+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # "contratado em DD/MM/AAAA"
        r'contratad[oa]\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # "iniciou suas atividades em DD/MM/AAAA"
        r'iniciou\s+suas?\s+atividades?.{0,50}?(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # "reclamante foi contratado em DD/MM/AAAA"
        r'reclamante\s+foi\s+(?:contratad[oa]|admitid[oa]).{0,50}?em\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "come√ßou a trabalhar em DD/MM/AAAA"
        r'come[√ßc]ou\s+a\s+trabalhar\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "ingressou na empresa em DD/MM/AAAA"
        r'ingressou\s+(?:na|na\s+empresa)\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "desde DD/MM/AAAA" (pr√≥ximo a v√≠nculo/contrato)
        r'v[√≠i]nculo.{0,30}?desde\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "a partir de DD/MM/AAAA"
        r'(?:admitid[oa]|contratad[oa]).{0,20}?a\s+partir\s+de\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "admitida pela reclamada em DD/MM/AAAA" (ordem diferente)
        # Aceita espa√ßos opcionais dentro da palavra (problema PyPDF2: "admitid a")
        r'admitid\s*[oa]\s+pela\s+[Rr]eclamada\s+em\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'contratad\s*[oa]\s+pela\s+[Rr]eclamada\s+em\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "admiss√£o" em contexto CTPS digital: "06/03/2017 - admiss√£o"
        r'(\d{2}[/.\-]\d{2}[/.\-]\d{4})\s*[-‚Äì]\s*admiss[√£a]o',
        # üÜï "foi admitida pela reclamada em" com espa√ßos
        r'foi\s+admitid\s*[oa]\s+pela\s+[Rr]eclamada\s+em\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
    ]
    
    for pattern in narrativa_patterns:
        match = re.search(pattern, text_lower, re.I | re.S)
        if match:
            data = format_date(match.group(1))
            result = validate_and_return(match, data, "Narrativa")
            if result:
                return result
    
    # ===== PRIORIDADE 3: M√™s por extenso (SOMENTE com dia expl√≠cito) =====
    # NOTA: Removidos padr√µes s√≥ m√™s/ano para evitar datas inv√°lidas como "01/00/2024"
    meses_pattern = '|'.join(MESES_MAP.keys())
    ano_pattern = r'(\d{4}|\d{1,2}\s*\d{2,3})'  # Aceita "2024" ou "2 024" do PyPDF2
    
    extenso_patterns = [
        # "admitido em 01 de junho de 2024" - dia OBRIGAT√ìRIO
        r'(?:admitid[oa]|contratad[oa])\s+(?:em\s+)?(\d{1,2})[¬∫oa]?\s+de\s+(' + meses_pattern + r')\.?\s+de\s+' + ano_pattern,
        # "foi admitido em 01 de junho de 2024" - dia OBRIGAT√ìRIO
        r'foi\s+(?:admitid[oa]|contratad[oa])\s+(?:em\s+)?(\d{1,2})[¬∫oa]?\s+de\s+(' + meses_pattern + r')\.?\s+de\s+' + ano_pattern,
        # "come√ßou a trabalhar em 15 de mar√ßo de 2024" - dia OBRIGAT√ìRIO
        r'(?:iniciou|come[√ßc]ou)\s+(?:a\s+trabalhar|suas?\s+atividades?)\s+(?:em\s+)?(\d{1,2})[¬∫oa]?\s+de\s+(' + meses_pattern + r')\.?\s+de\s+' + ano_pattern,
        # üÜï "admitida no dia 19 de julho de 2023" - com "no dia"
        r'(?:admitid[oa]|contratad[oa])\s+no\s+dia\s+(\d{1,2})[¬∫oa]?\s+de\s+(' + meses_pattern + r')\.?\s+(?:de\s+)?' + ano_pattern,
        # üÜï "foi admitido no dia 19 de julho de 2023"
        r'foi\s+(?:admitid[oa]|contratad[oa])\s+no\s+dia\s+(\d{1,2})[¬∫oa]?\s+de\s+(' + meses_pattern + r')\.?\s+(?:de\s+)?' + ano_pattern,
    ]
    
    for pattern in extenso_patterns:
        match = re.search(pattern, text_lower, re.I)
        if match:
            groups = match.groups()
            # S√≥ processa se tiver 3 grupos: dia, m√™s, ano
            if len(groups) >= 3:
                dia = groups[0].zfill(2)
                mes_nome = groups[1].lower().replace('.', '')
                ano = groups[2].replace(' ', '')
                
                if mes_nome in MESES_MAP:
                    data = f"{dia}/{MESES_MAP[mes_nome]}/{ano}"
                    if is_valid_brazilian_date(data):
                        logger.debug(f"[DATA_ADMISSAO] ‚úÖ Extenso: {data}")
                        return data
    
    # ===== PRIORIDADE 4: Per√≠odo (fallback) =====
    periodo_patterns = [
        r'per[√≠i]odo\s*[:\s]+(\d{2}[/.\-]\d{2}[/.\-]\d{4})\s+a\s+\d{2}[/.\-]\d{2}[/.\-]\d{4}',
        r'trabalhou.{0,30}?de\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})\s+(?:a|at[√©e])',
        r'laborou.{0,30}?de\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})\s+(?:a|at[√©e])',
        r'v[√≠i]nculo.{0,30}?(\d{2}[/.\-]\d{2}[/.\-]\d{4})\s+(?:a|at[√©e])',
    ]
    
    for pattern in periodo_patterns:
        match = re.search(pattern, text_lower, re.I)
        if match:
            data = format_date(match.group(1))
            if is_valid_brazilian_date(data):
                logger.debug(f"[DATA_ADMISSAO] ‚úÖ Per√≠odo: {data}")
                return data
    
    logger.debug("[DATA_ADMISSAO] ‚ùå Nenhuma data encontrada")
    return None


def extract_data_demissao(text: str) -> str | None:
    """
    Extrai data de demiss√£o/dispensa do trabalhador.
    
    2025-12-01: OTIMIZA√á√ÉO COMPLETA - Plano Batman
    - Usa utilit√°rios compartilhados (normalize_text, MESES_MAP, is_invalid_date_context)
    - Novos padr√µes para formatos menos comuns
    - Valida√ß√£o de data mais robusta
    
    PRIORIDADE DE FONTES:
    1. TRCT / CTPS (tabelas estruturadas)
    2. Peti√ß√£o inicial (narrativa)
    3. M√™s por extenso
    4. Per√≠odo (fallback - pega 2¬™ data)
    """
    logger = _extract_logger
    
    if not text:
        return None
    
    # NORMALIZA√á√ÉO usando utilit√°rio compartilhado
    text_norm = normalize_text(text)
    text_lower = text_norm.lower()
    
    def format_date(raw: str) -> str:
        """Formata data para DD/MM/AAAA"""
        return raw.strip().replace('.', '/').replace('-', '/')
    
    def validate_and_return(match_obj, data: str, source: str) -> str | None:
        """Valida contexto e retorna data se v√°lida"""
        if is_invalid_date_context(match_obj, text_lower, [
            'assinado eletronicamente', 'documento assinado', 
            'data da autua√ß√£o', 'data da distribui√ß√£o', 'distribu√≠do em',
            'audi√™ncia', 'audiencia', 'intima√ß√£o', 'notifica√ß√£o',
            'publica√ß√£o', 'certifico'
        ]):
            return None
        if is_valid_brazilian_date(data):
            logger.debug(f"[DATA_DEMISSAO] ‚úÖ {source}: {data}")
            return data
        return None
    
    # ===== PRIORIDADE 1: TRCT/CTPS (alta confian√ßa) =====
    trct_patterns = [
        r'data\s+de\s+(?:demiss[a√£]o|dispensa|desligamento)\s*[:\s]+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'(?:demiss[a√£]o|dispensa|desligamento|sa[√≠i]da)\s*[:\s]+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'data\s+de\s+sa[√≠i]da\s*[:\s]+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï TRCT campo num√©rico: "03. Data de Demiss√£o 01/01/2020"
        r'\d+\.\s*(?:data\s+de\s+)?(?:demiss[a√£]o|dispensa)\s*[:\s]*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï Tabela com pipe: "| Demiss√£o | 01/01/2020 |"
        r'\|\s*(?:demiss[a√£]o|dispensa)\s*\|\s*(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
    ]
    
    for pattern in trct_patterns:
        match = re.search(pattern, text_lower, re.I)
        if match:
            data = format_date(match.group(1))
            result = validate_and_return(match, data, "TRCT/CTPS")
            if result:
                return result
    
    # ===== PRIORIDADE 2: Narrativa com data num√©rica =====
    narrativa_patterns = [
        # "foi demitido/dispensado em DD/MM/AAAA"
        r'foi\s+(?:demitid[oa]|dispensad[oa]|desligad[oa])\s+(?:sem\s+justa\s+causa\s+)?(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # "dispensado sem justo motivo em DD/MM/AAAA"
        r'(?:dispensad[oa]|demitid[oa])\s+(?:sem\s+(?:justo\s+)?(?:motivo|causa)\s+)?(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # "tendo sido dispensado em DD/MM/AAAA"
        r'tendo\s+sido\s+(?:dispensad[oa]|demitid[oa]|desligad[oa])\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # "rescindido/desligado em DD/MM/AAAA"
        r'(?:rescindid[oa]|desligad[oa])\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # "pediu demiss√£o em DD/MM/AAAA"
        r'pedi(?:u|do|r)\s+demiss[a√£]o\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "deixou a empresa em DD/MM/AAAA"
        r'deixou\s+(?:a\s+)?(?:empresa|r[√©e])\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "encerrou o contrato em DD/MM/AAAA"
        r'encerrou\s+(?:o\s+)?contrato\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "teve seu contrato encerrado em DD/MM/AAAA"
        r'teve\s+(?:seu\s+)?contrato\s+(?:encerrad[oa]|rescindid[oa])\s+(?:em\s+)?(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "at√© DD/MM/AAAA quando foi demitido"
        r'at[√©e]\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})\s+(?:quando\s+)?(?:foi\s+)?(?:demitid[oa]|dispensad[oa])',
        # üÜï "demiss√£o no dia DD/MM/AAAA" - com "no dia"
        r'demiss[a√£]o\s+no\s+dia\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "dispensado no dia DD/MM/AAAA" - com "no dia"
        r'(?:dispensad[oa]|demitid[oa]|desligad[oa])\s+no\s+dia\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        # üÜï "foi dispensado no dia DD/MM/AAAA"
        r'foi\s+(?:dispensad[oa]|demitid[oa]|desligad[oa])\s+no\s+dia\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
    ]
    
    for pattern in narrativa_patterns:
        match = re.search(pattern, text_lower, re.I | re.S)
        if match:
            data = format_date(match.group(1))
            result = validate_and_return(match, data, "Narrativa")
            if result:
                return result
    
    # ===== PRIORIDADE 3: M√™s por extenso =====
    meses_pattern = '|'.join(MESES_MAP.keys())
    
    extenso_patterns = [
        # "dispensado/demitido em DD de MES de AAAA"
        r'(?:dispensad[oa]|demitid[oa]|desligad[oa])\s+(?:sem\s+justa\s+causa\s+)?(?:em\s+)?(\d{1,2})[¬∫oa]?\s+de\s+(' + meses_pattern + r')\.?\s+de\s+(\d{4})',
        # "foi demitida em DD de MES de AAAA"
        r'foi\s+(?:demitid[oa]|dispensad[oa])\s+(?:em\s+)?(\d{1,2})[¬∫oa]?\s+de\s+(' + meses_pattern + r')\.?\s+de\s+(\d{4})',
        # "rescis√£o em DD de MES de AAAA"
        r'(?:rescis[a√£]o|dispensa|demiss[a√£]o).{0,50}em\s+(\d{1,2})[¬∫oa]?\s+de\s+(' + meses_pattern + r')\.?\s+de\s+(\d{4})',
    ]
    
    for pattern in extenso_patterns:
        match = re.search(pattern, text_lower, re.I)
        if match:
            dia = match.group(1).zfill(2)
            mes_nome = match.group(2).lower().replace('.', '')
            ano = match.group(3)
            if mes_nome in MESES_MAP:
                data = f"{dia}/{MESES_MAP[mes_nome]}/{ano}"
                if is_valid_brazilian_date(data):
                    logger.debug(f"[DATA_DEMISSAO] ‚úÖ Extenso: {data}")
                    return data
    
    # ===== PRIORIDADE 4: Per√≠odo (fallback - pega 2¬™ data) =====
    periodo_patterns = [
        r'per[√≠i]odo\s*[:\s]+\d{2}[/.\-]\d{2}[/.\-]\d{4}\s+(?:a|at[√©e])\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'trabalhou.{0,30}?\d{2}[/.\-]\d{2}[/.\-]\d{4}\s+(?:a|at[√©e])\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'laborou.{0,30}?\d{2}[/.\-]\d{2}[/.\-]\d{4}\s+(?:a|at[√©e])\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
        r'v[√≠i]nculo.{0,30}?\d{2}[/.\-]\d{2}[/.\-]\d{4}\s+(?:a|at[√©e])\s+(\d{2}[/.\-]\d{2}[/.\-]\d{4})',
    ]
    
    for pattern in periodo_patterns:
        match = re.search(pattern, text_lower, re.I)
        if match:
            data = format_date(match.group(1))
            if is_valid_brazilian_date(data):
                logger.debug(f"[DATA_DEMISSAO] ‚úÖ Per√≠odo: {data}")
                return data
    
    logger.debug("[DATA_DEMISSAO] ‚ùå Nenhuma data encontrada")
    return None


def extract_salario(text: str) -> str | None:
    """
    Extrai sal√°rio efetivo do trabalhador (n√£o piso salarial).
    Prioriza: "perceb", "recebia", "ganhava" sobre "deveria receber", "piso"
    
    2025-12-01: OTIMIZA√á√ÉO COMPLETA - Plano Batman
    - Usa normalize_monetary() para corrigir espa√ßos em valores
    - Novos padr√µes para TRCT, contracheques, tabelas
    - Valida√ß√£o de contexto mais robusta
    - Suporte a formatos brasileiros e internacionais
    """
    logger = _extract_logger
    
    if not text:
        return None
    
    # NORMALIZA√á√ÉO: usar utilit√°rio compartilhado + normaliza√ß√£o monet√°ria
    text_norm = normalize_text(text)
    text_norm = normalize_monetary(text_norm)
    
    # Regex para capturar valores monet√°rios brasileiros
    # Suporta: 3.093,10 / 3093,10 / 1.516,00 / 10000,00
    valor_pattern = r'([0-9]{1,3}(?:\.[0-9]{3})*,[0-9]{1,2}|[0-9]+,[0-9]{1,2})'
    
    def format_valor(raw: str) -> str:
        """Formata valor extra√≠do para padr√£o R$ X.XXX,XX"""
        valor = re.sub(r'\s+', '', raw.strip())
        # Garantir 2 casas decimais
        if ',' in valor and len(valor.split(',')[1]) == 1:
            valor = valor + '0'
        return f"R$ {valor}"
    
    # ===== PRIORIDADE 1: TRCT / Documentos Estruturados =====
    # Estes s√£o os mais confi√°veis pois v√™m de documentos oficiais
    patterns_trct = [
        # TRCT: "Sal√°rio Base: R$ 1.516,00" ou "Remunera√ß√£o: R$ 2.500,00"
        r'(?:sal[a√°]rio\s+(?:base|contratual)|remunera[c√ß][a√£]o)\s*[:\-]?\s*R\$\s*' + valor_pattern,
        # Tabela: "| Sal√°rio | R$ 1.500,00 |"
        r'\|\s*sal[a√°]rio\s*\|\s*R\$\s*' + valor_pattern,
        # TRCT campo: "03. Remunera√ß√£o R$ 1.234,56"
        r'\d+\.\s*(?:sal[a√°]rio|remunera[c√ß][a√£]o)\s*R\$\s*' + valor_pattern,
    ]
    
    for pattern in patterns_trct:
        match = re.search(pattern, text_norm, re.I)
        if match:
            logger.debug(f"[SALARIO] ‚úÖ TRCT/Estruturado: {match.group(1)}")
            return format_valor(match.group(1))
    
    # ===== PRIORIDADE 2: Verbos de recebimento (alta confian√ßa) =====
    patterns_efetivo = [
        # "percebia/recebia/ganhava R$ X"
        r'\b(?:percebia|percebeu|percebesse|recebia|recebeu|ganhava|ganhou|percebendo|recebendo)\b\s+(?:o\s+)?(?:valor\s+de\s+)?(?:apenas\s+)?(?:como\s+sal[a√°]rio\s+)?(?:sal[a√°]rio\s+(?:de\s+|mensal\s+)?)?R\$\s*' + valor_pattern,
        # "com sal√°rio de R$ X"
        r'com\s+(?:o\s+)?sal[a√°]rio\s+(?:de\s+)?R\$\s*' + valor_pattern,
        # "contratado/admitido com sal√°rio de R$ X"
        r'(?:contratad[oa]|admitid[oa])\s+(?:com\s+)?(?:o\s+)?sal[a√°]rio\s+(?:de\s+)?R\$\s*' + valor_pattern,
        # "sal√°rio vigente era de R$ X"
        r'sal[a√°]rio\s+(?:vigente|atual)\s+[^\n]{0,30}?(?:era\s+de\s+|de\s+)?R\$\s*' + valor_pattern,
        # "remunera√ß√£o fixa de R$ X"
        r'remunera[c√ß][a√£]o\s+(?:fixa|mensal)\s+(?:de\s+|no\s+valor\s+de\s+)?R\$\s*' + valor_pattern,
    ]
    
    for pattern in patterns_efetivo:
        match = re.search(pattern, text_norm, re.I)
        if match:
            logger.debug(f"[SALARIO] ‚úÖ Verbo recebimento: {match.group(1)}")
            return format_valor(match.group(1))
    
    # ===== PRIORIDADE 3: Padr√µes gen√©ricos com valida√ß√£o de contexto =====
    patterns_genericos = [
        # √öltimo sal√°rio
        r'[√∫u]ltim[oa]\s+(?:remunera[c√ß][a√£]o|sal[a√°]rio)\s+(?:mensal\s+)?(?:foi\s+de\s+|de\s+|era\s+)?R\$\s*' + valor_pattern,
        # Sal√°rio de R$ X
        r'sal[a√°]rio\s+(?:de\s+|base\s+de\s+|mensal\s+(?:de\s+)?)?R\$\s*' + valor_pattern,
        # Remunera√ß√£o de R$ X
        r'remunera[c√ß][a√£]o\s+(?:de\s+|mensal\s+(?:de\s+)?)?R\$\s*' + valor_pattern,
        # Sal√°rio-base
        r'sal[a√°]rio[\s\-]base\s+(?:de\s+)?R\$\s*' + valor_pattern,
        # Vencimentos
        r'vencimentos?\s+(?:de\s+)?R\$\s*' + valor_pattern,
        # Holerite/contracheque
        r'(?:holerite|contracheque).{0,50}R\$\s*' + valor_pattern,
        # Remunera√ß√£o total
        r'remunera[c√ß][a√£]o\s+total\s+(?:de\s+)?R\$\s*' + valor_pattern,
        # "R$ X por m√™s" / "R$ X mensais"
        r'R\$\s*' + valor_pattern + r'\s+(?:por\s+m[√™e]s|mensais?)',
        # üÜï "no importe de R$ X" / "no valor de R$ X" (pr√≥ximo a sal√°rio)
        r'sal[a√°]rio.{0,30}?(?:no\s+)?(?:importe|valor)\s+de\s+R\$\s*' + valor_pattern,
        # üÜï "m√©dia salarial de R$ X"
        r'm[√©e]dia\s+salarial\s+(?:de\s+)?R\$\s*' + valor_pattern,
        # üÜï "proventos de R$ X"
        r'proventos?\s+(?:de\s+)?R\$\s*' + valor_pattern,
    ]
    
    # Contextos inv√°lidos (n√£o √© sal√°rio real)
    contextos_invalidos = [
        'deveria', 'piso', 'devem receber', 'deveriam', 'base de c√°lculo',
        'valor da causa', 'multa', 'indeniza√ß√£o', 'honor√°rios', 'custas',
        'm√≠nimo nacional', 'sal√°rio m√≠nimo'
    ]
    
    for pattern in patterns_genericos:
        match = re.search(pattern, text_norm, re.I)
        if match:
            # Validar contexto: n√£o deve estar perto de palavras que indicam valor te√≥rico
            start_ctx = max(0, match.start() - 60)
            end_ctx = min(len(text_norm), match.end() + 60)
            contexto = text_norm[start_ctx:end_ctx].lower()
            
            if any(kw in contexto for kw in contextos_invalidos):
                continue
            
            logger.debug(f"[SALARIO] ‚úÖ Gen√©rico: {match.group(1)}")
            return format_valor(match.group(1))
    
    # ===== PRIORIDADE 4: Fallback - primeiro valor monet√°rio significativo =====
    # Buscar em contexto de emprego (primeiros 5000 chars)
    texto_emprego = text_norm[:5000]
    
    # Padr√£o gen√©rico: R$ seguido de valor > 500 (filtrar valores muito baixos)
    all_valores = re.findall(r'R\$\s*' + valor_pattern, texto_emprego, re.I)
    for valor_match in all_valores:
        try:
            valor_num = float(valor_match.replace('.', '').replace(',', '.'))
            if 500 <= valor_num <= 100000:  # Faixa salarial razo√°vel
                logger.debug(f"[SALARIO] ‚úÖ Fallback: {valor_match}")
                return format_valor(valor_match)
        except ValueError:
            continue
    
    logger.debug("[SALARIO] ‚ùå Nenhum valor encontrado")
    return None


def extract_cargo_funcao(text: str) -> str | None:
    """
    Extrai cargo/fun√ß√£o do trabalhador.
    
    2025-12-01: OTIMIZA√á√ÉO COMPLETA - Plano Batman
    - Usa utilit√°rios compartilhados
    - Valida√ß√£o melhorada de cargos truncados
    - Rejei√ß√£o de frases inv√°lidas
    
    FONTES DE EXTRA√á√ÉO:
    1. TRCT / CTPS (alta confian√ßa)
    2. Narrativa da peti√ß√£o inicial
    3. Tabela de dados
    """
    logger = _extract_logger
    
    if not text:
        return None
    
    # Normalizar usando utilit√°rio compartilhado
    text_norm = normalize_text(text)
    
    # Lista para armazenar todas as fun√ß√µes encontradas (pegar √∫ltima)
    funcoes_encontradas = []
    
    # Palavras proibidas (falsos positivos comuns)
    palavras_proibidas = [
        'direito', 'pessoa', 'acordo', 'contratada', 'reclamada', 'reclamante',
        'advogado', 'juiz', 'processo', 'trabalho', 'empresa', 'autor', 'reu',
        'janeiro', 'fevereiro', 'mar√ßo', 'marco', 'abril', 'maio', 'junho',
        'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'
    ]
    
    # Abordagem GREEDY: capturar o m√°ximo poss√≠vel e depois limpar no p√≥s-processamento
    # Isso evita problemas com cargos longos como "T√©cnico em Seguran√ßa do Trabalho"
    
    patterns = [
        # PRIORIDADE 1: Padr√µes espec√≠ficos de contrata√ß√£o (case sensitive para cargos em mai√∫sculo)
        # Captura at√© 60 caracteres greedy, depois limpa
        r'para\s+exercer\s+(?:a\s+)?fun[c√ß][a√£]o\s+de\s+([A-Z√Ä-√ö][A-Z√Ä-√ö\s]{3,60})',
        r'o\s+cargo\s+de\s+([A-Z√Ä-√ö][A-Z√Ä-√ö\s]{3,60})',
        r'exercendo\s+(?:a\s+)?fun[c√ß][a√£]o\s+de\s+([A-Z√Ä-√ö][A-Z√Ä-√ö\s]{3,60})',
        r'exercia\s+(?:a\s+)?fun[c√ß][a√£]o\s+de\s+([A-Z√Ä-√ö][A-Z√Ä-√ö\s]{3,60})',
        
        # PRIORIDADE 2: Padr√µes de narrativa (case insensitive) - GREEDY
        r'fun[c√ß][a√£]o\s+de\s+([A-Za-z√Ä-√∫][A-Za-z√Ä-√∫\s]{3,60})',
        r'cargo\s+de\s+([A-Za-z√Ä-√∫][A-Za-z√Ä-√∫\s]{3,60})',
        r'contratad[oa]\s+como\s+([A-Za-z√Ä-√∫][A-Za-z√Ä-√∫\s]{3,60})',
        
        # PRIORIDADE 3: Tabelas TRCT/CTPS
        r'fun[c√ß][a√£]o\s*:\s*([A-Za-z√Ä-√∫][A-Za-z√Ä-√∫\s]{3,60})',
        r'cargo\s*:\s*([A-Za-z√Ä-√∫][A-Za-z√Ä-√∫\s]{3,60})',
    ]
    
    def limpar_cargo(funcao: str) -> str | None:
        """Limpa e valida o cargo extra√≠do
        
        Abordagem: Captura greedy seguida de limpeza de palavras de contexto
        que n√£o fazem parte do cargo (verbos, preposi√ß√µes de continua√ß√£o, etc)
        
        2025-11-27: Adicionada rejei√ß√£o de textos inv√°lidos como:
        - "CONDI√á√ïES ESPECIAIS EM QUE O TRABALHO √â REALIZADO"
        - Frases longas com verbos conjugados
        """
        if not funcao:
            return None
        
        funcao = funcao.strip()
        funcao = re.sub(r'\s+', ' ', funcao)
        
        # üÜï REJEITAR FRASES INV√ÅLIDAS ANTES DE QUALQUER PROCESSAMENTO
        # Estes padr√µes indicam que capturamos texto descritivo, n√£o um cargo
        frases_invalidas = [
            r'condi[√ßc][o√µ]es?\s+especiais?',  # "CONDI√á√ïES ESPECIAIS"
            r'em\s+que\s+o\s+trabalho',  # "EM QUE O TRABALHO √â REALIZADO"
            r'realizado\s+e\s+com',  # "REALIZADO E COM ELES"
            r'trabalho\s+[e√©]\s+realizado',  # "TRABALHO √â REALIZADO"
            r'desempenha(?:va|ndo)',  # "desempenhava", "desempenhando"
            r'(?:foi|era|estava)\s+(?:contratad[oa]|admitid[oa])',  # "foi contratada"
            r'exerc(?:ia|eu|endo)\s+as?\s+atividade',  # "exercia as atividades"
            r'atividades?\s+(?:de|do|da)',  # "atividades de..."
            r'exerc[i√≠]cio\s+(?:de|da|do)',  # "exerc√≠cio de..."
            r'fun[c√ß][o√µ]es?\s+de\s+(?:nature|car[a√°]ter)',  # "fun√ß√µes de natureza"
            # üÜï 2025-11-27: Rejeitar padr√µes CIPA (Comiss√£o Interna de Preven√ß√£o de Acidentes)
            r'comiss[o√µ]es?\s+internas?',  # "COMISS√ïES INTERNAS"
            r'preven[√ßc][a√£]o\s+de\s+acidentes?',  # "PREVEN√á√ÉO DE ACIDENTES"
            r'dire[√ßc][a√£]o\s+de\s+comiss',  # "DIRE√á√ÉO DE COMISS√ïES"
            r'\bcipa\b',  # "CIPA"
            r'desde\s+o\s+registro',  # "desde o registro de sua candidatura"
            r'prote[√ßc][a√£]o\s+social',  # "prote√ß√£o social da CIPA"
        ]
        
        funcao_lower = funcao.lower()
        for pattern in frases_invalidas:
            if re.search(pattern, funcao_lower, re.I):
                return None
        
        # Palavras que indicam FIM DO CARGO e in√≠cio de outra parte da frase
        # Essas palavras e tudo depois delas devem ser removidas
        corte_palavras = [
            r'\s+sendo\b.*$',
            r'\s+foi\b.*$',
            r'\s+e\s+foi\b.*$',
            r'\s+percebendo\b.*$',
            r'\s+recebendo\b.*$',
            r'\s+ganhando\b.*$',
            r'\s+sob\b.*$',
            r'\s+onde\b.*$',
            r'\s+quando\b.*$',
            r'\s+contratad[oa]\b.*$',
            r'\s+para\s+(?!de\b).*$',  # "para" mas n√£o "para de"
            r'\s+com\s+(?:sal[a√°]rio|remunera|vencimento).*$',  # "com sal√°rio"
            r'\s+na\s+(?:empresa|reclamada|r√©|reclam).*$',  # "na empresa"
            r'\s+no\s+(?:setor|departamento|estabelecimento).*$',  # "no setor"
            r'\s+da\s+(?:empresa|reclamada|r√©|reclam|companhia|sociedade).*$',  # "da empresa"
            r'\s+do\s+(?:setor|departamento|estabelecimento).*$',  # "do setor"
        ]
        
        for pattern in corte_palavras:
            funcao = re.sub(pattern, '', funcao, flags=re.I)
        
        funcao = funcao.strip()
        
        # Limpar trailing de artigos/preposi√ß√µes/conjun√ß√µes soltas
        # Loop para remover m√∫ltiplos trailing (ex: "Diretor da" ‚Üí "Diretor")
        for _ in range(3):  # M√°ximo 3 itera√ß√µes
            old_len = len(funcao)
            # S√≥ remove se for palavra solta no final (n√£o seguida de substantivo)
            funcao = re.sub(r'\s+(e|ou|com|para|em|no|na|da|do|de|das|dos|a|o|os|as|at√©|ate)$', '', funcao, flags=re.I)
            if len(funcao) == old_len:
                break
        
        funcao = funcao.strip()
        
        # Rejeitar se termina em preposi√ß√£o (cargo incompleto)
        if re.search(r'\s+(de|da|do|das|dos)$', funcao, re.I):
            return None
        
        # üÜï Rejeitar se tem mais de 6 palavras (provavelmente √© frase, n√£o cargo)
        palavras = funcao.split()
        if len(palavras) > 6:
            return None
        
        # Validar tamanho m√≠nimo
        if len(funcao) <= 3:
            return None
        
        return funcao
    
    for pattern in patterns:
        for match in re.finditer(pattern, text_norm, re.I):
            funcao = match.group(1).strip()
            
            # Limpar e validar
            funcao = limpar_cargo(funcao)
            
            if not funcao:
                continue
            
            # Validar:
            # 1. N√£o √© palavra proibida
            # 2. N√£o come√ßa com artigo/preposi√ß√£o
            if (funcao.lower() not in palavras_proibidas and
                not re.match(r'^(o|a|os|as|de|do|da|em|no|na|para)\s', funcao, re.I)):
                
                funcoes_encontradas.append(funcao.upper())
    
    # Retornar a √∫ltima fun√ß√£o encontrada (mais recente no texto)
    if funcoes_encontradas:
        # Deduplicate mantendo ordem
        seen = set()
        unique = []
        for f in funcoes_encontradas:
            if f not in seen:
                seen.add(f)
                unique.append(f)
        
        logger.debug(f"[CARGO] Fun√ß√µes encontradas: {unique}")
        return unique[-1]  # Retorna a √∫ltima (mais recente)
    
    return None


def extract_pis(text: str) -> str | None:
    """
    Extrai n√∫mero do PIS.
    
    Padr√µes suportados (2025-11-28 atualizado):
    - "PIS 123.45678.90-1"
    - "cadastrado no PIS sob o n¬∫. 164.295.786-75"
    - "PIS-PASEP: 123.45678.90-1"
    - "NIT: 12345678901"
    - "NIS 123.45678.90-1"
    - "inscrito no PIS/PASEP sob o n√∫mero 123..."
    
    2025-11-28: Melhorada busca com janela de contexto ¬±2 linhas
    para capturar n√∫meros que aparecem em linhas vizinhas da √¢ncora.
    """
    import logging
    logger = logging.getLogger(__name__)
    
    logger.info(f"[PIS] ‚ö° FUN√á√ÉO CHAMADA com texto de {len(text) if text else 0} chars")
    
    if not text:
        logger.info("[PIS] ‚ùå Texto vazio, retornando None")
        return None
    
    # NORMALIZAR TEXTO COM REGEX: remover TODAS as variantes de "n¬∫" (com/sem espa√ßos, quebras de linha)
    # Captura: n¬∞, n¬∫, N¬∞, N¬∫ com pontos opcionais e WHITESPACE entre "n" e "¬∞/¬∫"
    text_norm = re.sub(r'n\s*[¬∫¬∞]\.?', '', text, flags=re.I)
    # Normalizar h√≠fens especiais
    text_norm = text_norm.replace('‚Äì', '-').replace('‚Äî', '-')
    # 2025-12-01: CR√çTICO - Normalizar espa√ßos m√∫ltiplos (ap√≥s remo√ß√£o de "n¬∫" ficam espa√ßos duplos)
    text_norm = re.sub(r'\s+', ' ', text_norm)
    
    logger.info(f"[PIS] Buscando em texto normalizado de {len(text_norm)} chars")
    
    # Padr√µes PIS: 11 d√≠gitos com separadores opcionais (pontos, h√≠fens, espa√ßos m√∫ltiplos)
    # PyPDF2 pode adicionar espa√ßos extras: "cadastrad o" e "786 -75"
    # Aceita variantes: 204.05911.17.8, 124.13653.63-7, 164.29578.67-5
    # 2025-11-27: Adicionados PIS-PASEP, NIT, NIS + formatos com pontos em posi√ß√µes variadas
    
    # Regex UNIVERSAL para 11 d√≠gitos com qualquer combina√ß√£o de pontos/h√≠fens/espa√ßos
    # Ex: 204.05911.17.8, 204.05911.17-8, 124.13653.63-7, 161.94839.72-5
    UNIVERSAL_PIS = r'(\d{2,3}[\.\s\-]*\d{3,5}[\.\s\-]*\d{2,5}[\.\s\-]*\d{1,2})'
    
    patterns = [
        # üÜï PIS-PASEP com h√≠fen
        r'(?:pis[-\s]*pasep|pis/pasep)\s*[:\-]?\s*' + UNIVERSAL_PIS,
        # üÜï NIT (N√∫mero de Identifica√ß√£o do Trabalhador)
        r'(?:^|[\s:])nit\s*[:\-]?\s*' + UNIVERSAL_PIS,
        r'(?:^|[\s:])nit\s*[:\-]?\s*(\d{11})\b',
        # üÜï NIS (N√∫mero de Identifica√ß√£o Social)
        r'(?:^|[\s:])nis\s*[:\-]?\s*' + UNIVERSAL_PIS,
        r'(?:^|[\s:])nis\s*[:\-]?\s*(\d{11})\b',
        # üÜï "inscrito no PIS sob o n√∫mero..."
        r'inscrit[oa]\s+no\s+pis\s*(?:/pasep)?\s*(?:sob\s+o?\s*)?(?:n[√∫u]mero\s+)?' + UNIVERSAL_PIS,
        # Gen√©rico: qualquer combina√ß√£o de 11 d√≠gitos com separadores (mais flex√≠vel)
        r'(?:^|[\s:,])pis\s*[:\-]?\s*' + UNIVERSAL_PIS,
        # "cadastrado no pis sob o 164.295.786-75" (aceita espa√ßos extras)
        r'cadastrad\s*o\s+no\s+pis\s*(?:sob\s+o?\s*)?\s*' + UNIVERSAL_PIS,
        # "pis 12345678901" (sem separadores)
        r'(?:^|[\s:])pis\s*[:\-]?\s*(\d{11})\b',
        # üÜï "portador do PIS 123..."
        r'portador[a]?\s+(?:do|da)\s+pis\s*(?:/pasep)?\s*' + UNIVERSAL_PIS,
    ]
    
    for i, pattern in enumerate(patterns):
        match = re.search(pattern, text_norm, re.I)
        if match:
            pis = match.group(1).strip()
            # Normalizar: remover pontos, h√≠fens e espa√ßos
            pis_digits = re.sub(r'[\.\-\s]', '', pis)
            # VALIDA√á√ÉO: exatamente 11 d√≠gitos (evita capturar n√∫meros maiores)
            if len(pis_digits) == 11 and pis_digits.isdigit():
                logger.info(f"[PIS] ‚úÖ Match pattern {i}: {pis_digits} ‚Üí formatado")
                return f"{pis_digits[:3]}.{pis_digits[3:8]}.{pis_digits[8:10]}-{pis_digits[10]}"
            else:
                logger.debug(f"[PIS] ‚ùå Rejeitado (n√£o tem 11 d√≠gitos): {pis_digits}")
    
    # üÜï 2025-11-28: BUSCA COM JANELA DE CONTEXTO ¬±2 LINHAS
    # Procura √¢ncora "PIS" e depois busca n√∫mero de 11 d√≠gitos nas linhas vizinhas
    lines = text_norm.split('\n')
    for i, line in enumerate(lines):
        if re.search(r'\bpis\b', line, re.I):
            # Janela de contexto: linha atual + 2 linhas seguintes
            context_lines = lines[i:i+3]
            context = ' '.join(context_lines)
            
            # Buscar n√∫mero de 11 d√≠gitos no contexto expandido
            nums = re.findall(r'\d{2,3}[\.\s\-]*\d{3,5}[\.\s\-]*\d{2,5}[\.\s\-]*\d{1,2}', context)
            for num in nums:
                digits = re.sub(r'[\.\-\s]', '', num)
                if len(digits) == 11 and digits.isdigit():
                    logger.info(f"[PIS] ‚úÖ Match via janela de contexto: {digits}")
                    return f"{digits[:3]}.{digits[3:8]}.{digits[8:10]}-{digits[10]}"
    
    logger.info("[PIS] ‚ùå Nenhum match encontrado")
    return None


def extract_ctps(text: str) -> str | None:
    """
    Extrai n√∫mero da CTPS (Carteira de Trabalho).
    Formatos: "CTPS n¬∫ 95524 s√©rie 149/RJ", "CTPS sob n¬∫ 0048610-00080/RJ"
    
    2025-11-27: Novos formatos adicionados:
    - "CTPS DIGITAL" (sem n√∫mero) - apenas como fallback final
    - "CTPS n¬∫ 1210996, s√©rie 2780/RJ" (s√©rie com espa√ßo)
    - Espa√ßos extras do OCR: "CTPS   n¬∫  95524  s√©rie  149/RJ"
    - Formato com h√≠fen na s√©rie: "936665 s√©rie 00014-PB"
    
    2025-11-28: Corre√ß√£o cr√≠tica - "DIGITAL" s√≥ retorna se n√£o houver n√∫mero real
    """
    if not text:
        return None
    
    # Normalizar: remover "n¬∫" e normalizar h√≠fens
    text_norm = re.sub(r'n\s*[¬∫¬∞]\.?', '', text, flags=re.I)
    text_norm = text_norm.replace('‚Äì', '-').replace('‚Äî', '-')
    # Normalizar espa√ßos m√∫ltiplos
    text_norm = re.sub(r'\s+', ' ', text_norm)
    
    # PADR√ïES COM N√öMERO (priorit√°rios - tentar todos primeiro)
    patterns_with_number = [
        # Formato COMPACTO: "CTPS sob n¬∫ 0048610 -00080/RJ" (PyPDF2 adiciona espa√ßos)
        r'(?:portador\s+da\s+)?CTPS\s+(?:sob\s+)?(\d+[\s\-]+\d+[/][A-Z]{2})',
        # üÜï Formato com s√©rie: "CTPS n¬∫ 1210996, s√©rie 2780/RJ" ou "CTPS 1210996, s√©rie 2780/MA"
        r'CTPS\s*(\d+)\s*,?\s*s[√©e]rie\s+(\d+)\s*/?\s*([A-Z]{2})',
        # Formato SEPARADO com v√≠rgula: "CTPS n¬∫ 1210996, s√©rie 149/RJ"
        r'CTPS\s*(\d+)\s*,?\s*s[√©e]rie\s+(\d+[-/][A-Z]{2})',
        # üÜï Formato s√©rie com h√≠fen: "936665 s√©rie 00014-PB"
        r'CTPS\s*(\d+)\s*,?\s*s[√©e]rie\s+(\d+[-]\s*[A-Z]{2})',
        # Formato apenas s√©rie: "s√©rie 149/RJ" ou "serie 00014-PB"
        r'CTPS\s*(\d+)\s*,?\s*s[√©e]rie\s+([\dA-Z\-/]+)',
        # Formato COMPACTO gen√©rico: "CTPS 98765-00123/SP"
        r'CTPS\s*(\d+[-/]\d+[-/][A-Z]{2})',
        # Apenas n√∫mero com contexto: "portador da CTPS 123456" ou "CTPS 123456"
        # ‚ö†Ô∏è IMPORTANTE: N√£o capturar "CTPS DIGITAL" como n√∫mero
        r'(?:portador\s+da\s+)?CTPS\s+(?!DIGITAL)(\d{5,})',
        # üÜï Formato sem prefixo CTPS: "n√∫mero s√©rie" perto de contexto Carteira
        r'(?:Carteira\s+de\s+Trabalho|CTPS)[^\d]*(\d{5,8})\s*(?:s[√©e]rie\s+)?(\d{3,6}[-/]?[A-Z]{0,2})',
        # üÜï Formato com par√™ntese colado: "CTPS)1173470" ou "CTPS )1173470"
        r'CTPS\s*\)\s*(\d{5,})',
        # üÜï Formato "CTPSSCarteira": texto corrompido OCR "CTPSS" ou "CTPS S"
        r'CTPSS?\s*(?:Carteira[^\d]+)?(\d{5,})',
    ]
    
    for pattern in patterns_with_number:
        match = re.search(pattern, text_norm, re.I)
        if match:
            if match.lastindex == 3:
                # Formato com s√©rie e UF separados: (numero, serie, UF)
                numero = match.group(1).strip()
                serie = match.group(2).strip()
                uf = match.group(3).strip().upper()
                return f"{numero} s√©rie {serie}/{uf}"
            elif match.lastindex == 2:
                # Formato com s√©rie separada - validar UF OU ser num√©rica pura
                serie = match.group(2).strip()
                
                # VALIDA√á√ÉO: s√©rie deve ter /UF (ex: 149/RJ) OU ser apenas num√©rica (ex: 00014-PB)
                tem_uf = re.search(r'[/-][A-Z]{2}$', serie)
                eh_numerica = re.match(r'^[\d\-/A-Z]+$', serie) and any(c.isdigit() for c in serie)
                
                if tem_uf or (eh_numerica and len(serie) <= 15):
                    return f"{match.group(1)} s√©rie {serie}"
                # Rejeitar s√©ries que n√£o t√™m UF nem s√£o num√©ricas (ex: "DO R√âU")
            else:
                # Limpar espa√ßos extras
                ctps = match.group(1).strip()
                ctps = re.sub(r'\s+', '', ctps)  # Remove espa√ßos internos
                
                # VALIDA√á√ÉO: se tem barra, deve terminar com /UF (2 letras mai√∫sculas)
                if '/' in ctps:
                    if not re.search(r'/[A-Z]{2}$', ctps):
                        continue  # Rejeitar se n√£o termina com /UF
                
                return ctps
    
    # üÜï FALLBACK: CTPS DIGITAL (quando n√£o h√° n√∫mero f√≠sico)
    # 2025-11-28: Retornar "CTPS DIGITAL" como valor v√°lido para eLaw
    # 2025-12-01: Extrair CPF associado √† CTPS Digital como identificador
    if re.search(r'[Cc]arteira\s+de\s+[Tt]rabalho\s+[Dd]igital', text, re.I):
        # Tentar extrair CPF pr√≥ximo √† CTPS Digital
        cpf_patterns = [
            r'CPF\s*[:\-]?\s*(\d{3}[.\s]?\d{3}[.\s]?\d{3}[.\-]?\d{2})',
            r'Dados\s+Pessoais[^\d]*(\d{3}\.\d{3}\.\d{3}[-.\s]\d{2})',
        ]
        for cpf_pattern in cpf_patterns:
            cpf_match = re.search(cpf_pattern, text, re.I | re.S)
            if cpf_match:
                cpf_raw = cpf_match.group(1).replace(' ', '').replace('.', '').replace('-', '')
                if len(cpf_raw) == 11 and cpf_raw.isdigit():
                    # Formatar CPF: 123.456.789-01
                    cpf_fmt = f'{cpf_raw[:3]}.{cpf_raw[3:6]}.{cpf_raw[6:9]}-{cpf_raw[9:]}'
                    return f"Digital ({cpf_fmt})"
        
        # Fallback sem CPF
        return "CTPS DIGITAL"
    
    return None


def extract_local_trabalho(text: str) -> str | None:
    """
    Extrai local de trabalho (endere√ßo completo).
    Padr√µes: "local de trabalho:", "√öltimo local de trabalho:", "prestou servi√ßos em"
    """
    if not text:
        return None
    
    patterns = [
        # Padr√µes expl√≠citos de local (mais espec√≠ficos primeiro)
        r'[√∫u]ltimo\s+local\s+de\s+trabalho[:\s]+([^\n\.]+)',
        r'local\s+(?:de\s+)?trabalho[:\s]+([^\n\.]+)',
        # Endere√ßo espec√≠fico com indicadores geogr√°ficos
        r'(?:laborou|trabalhou|prestou\s+servi[c√ß]os)\s+(?:em|na|no)\s+([^,\.]+,\s*[^,\.]+(?:,\s*[^,\.]+)?)',
    ]
    
    # Buscar em TODO o texto (n√£o limitar a 3000 chars)
    for pattern in patterns:
        match = re.search(pattern, text, re.I)
        if match:
            local = match.group(1).strip()
            # Limpar quebras de linha excessivas e espa√ßos
            local = re.sub(r'\s+', ' ', local)
            # Parar em pontos que indicam fim do endere√ßo
            local = re.split(r'(?:\s+CEP|\s+para\s+|\s+conforme)', local)[0].strip()
            
            # FILTRO M√çNIMO: apenas bloquear falsos positivos conhecidos
            local_lower = local.lower()
            blacklist = [
                'do reclamante, se o objeto', 'versar sobre pedido', 
                'condi√ß√µes ambientais de trabalho', 'informa o autor que em toda',
                'era realizada dedetiza√ß√£o', 'coincidia com a sua jornada',
                'para a segunda reclamada', 'para a primeira reclamada',
                'desde sua admiss√£o'
            ]
            
            # Se cont√©m falso positivo conhecido, pular
            if any(lixo in local_lower for lixo in blacklist):
                continue
            
            # Valida√ß√£o: deve ter pelo menos um indicador de endere√ßo real
            indicadores = ['rua', 'avenida', 'av.', 'largo', 'pra√ßa', 'rodovia', 
                          'estrada', 'bairro', ' - ', 'n¬∫', 'n¬∞', 'n√∫mero']
            tem_indicador = any(ind in local_lower for ind in indicadores)
            
            # Aceitar se tiver tamanho razo√°vel (>10 chars) E indicador de endere√ßo
            if local and len(local) > 10 and tem_indicador:
                return local
    
    return None


def extract_empregador(text: str) -> str | None:
    """
    Extrai nome da empresa empregadora.
    Se n√£o encontrar men√ß√£o expl√≠cita, retorna None (fallback ser√° feito em extract_metadata).
    
    2025-11-27: Melhorada valida√ß√£o para evitar falsos positivos como:
    - "RECLAMADA" literal (sem nome da empresa)
    - Frases como "sempre controlou a jornada de seus funcionarios"
    """
    if not text:
        return None
    
    # Normalizar texto para busca
    text_norm = re.sub(r'\s+', ' ', text).strip()
    
    # PRIORIDADE 1: Padr√µes de RECLAMADO na capa do processo (mais confi√°vel)
    # Ex: "RECLAMADO: CBSI - COMPANHIA BRASILEIRA DE SERVICOS DE INFRAESTRUTURA"
    capa_patterns = [
        r'RECLAMAD[OA]:\s*([A-Z√Ä-√ö][A-Z√Ä-√öa-z√†-√∫\s\.\-&,]{10,150}?)(?:\n|RECLAMAD|ADVOGAD|PAGINA)',
        r'R√âU:\s*([A-Z√Ä-√ö][A-Z√Ä-√öa-z√†-√∫\s\.\-&,]{10,150}?)(?:\n|ADVOGAD|PAGINA)',
    ]
    
    for pattern in capa_patterns:
        match = re.search(pattern, text_norm)
        if match:
            empregador = match.group(1).strip()
            empregador = re.sub(r'\s+', ' ', empregador).strip(' ,-')
            if _validar_empregador(empregador):
                return empregador
    
    # PRIORIDADE 2: Padr√µes de narrativa (admitido pela EMPRESA)
    narrativa_patterns = [
        # "admitido pela primeira reclamada NOME" ou "admitido pela NOME"
        r'admitid[oa]\s+pel[oa]\s+(?:primeira\s+)?(?:reclamada\s+)?([A-Z√Ä-√ö][A-Z√Ä-√öa-z√†-√∫\s\.\-&]{5,100}?)(?:\s*,|\s+em\s+\d{2}/|\s+CNPJ)',
        # "contratado pela EMPRESA"
        r'contratad[oa]\s+pel[oa]\s+(?:empresa\s+)?([A-Z√Ä-√ö][A-Z√Ä-√öa-z√†-√∫\s\.\-&]{5,100}?)(?:\s*,|\s+em\s+\d{2}/|\s+para)',
        # "em face de EMPRESA NOME COMPLETO, pessoa jur√≠dica"
        r'em\s+face\s+de\s+([A-Z√Ä-√ö][A-Z√Ä-√öa-z√†-√∫\s\.\-&]{5,100}?),?\s+pessoa\s+jur[√≠i]dica',
    ]
    
    for pattern in narrativa_patterns:
        match = re.search(pattern, text_norm, re.I)
        if match:
            empregador = match.group(1).strip()
            empregador = re.sub(r'\s+', ' ', empregador).strip(' ,-')
            if _validar_empregador(empregador):
                return empregador
    
    return None


def _validar_empregador(empregador: str) -> bool:
    """
    Valida se o texto extra√≠do √© um nome de empresa v√°lido.
    Evita falsos positivos como "RECLAMADA", frases descritivas, etc.
    """
    if not empregador or len(empregador) < 5:
        return False
    
    lixo_lower = empregador.lower()
    
    # Blacklist de palavras que indicam falso positivo
    blacklist_exato = [
        'reclamada', 'reclamado', 'reclamante', 'autor', 'autora', 'reu', 'r√©',
        'primeira reclamada', 'segunda reclamada', 'terceira reclamada'
    ]
    
    # Se √© exatamente uma dessas palavras, rejeitar
    if lixo_lower in blacklist_exato:
        return False
    
    # Blacklist de frases que N√ÉO s√£o nomes de empresa
    blacklist_frases = [
        'se enquadra', 'enquadra em', '√°rea de risco', 'area de risco',
        'na presente lide', 'presente lide', 'benef√≠cio da',
        'documento assinado', 'condenada a pagar', 'for condenada',
        'presente demanda', 'presente a√ß√£o', 'da inicial',
        'na inicial', 'dos autos', 'aos autos',
        # 2025-11-27: Novos falsos positivos identificados
        'sempre controlou', 'controlou a jornada', 'de seus funcionarios',
        'seus funcion√°rios', 'seus empregados', 'foi demitida', 'foi dispensada',
        'em benef√≠cio', 'dever√° responder', 'deve responder'
    ]
    
    if any(lixo in lixo_lower for lixo in blacklist_frases):
        return False
    
    # Verbos conjugados indicam que √© uma frase, n√£o um nome
    verbos_proibidos = [
        'for', 'seja', 'fica', 'tenha', 'deve', 'possa', 'foi', 'era', 'est√°',
        'sempre', 'controlou', 'pagou', 'demitiu', 'dispensou', 'contratou',
        'realizou', 'efetuou', 'cumpriu', 'prestou', 'laborou', 'trabalhou'
    ]
    palavras = lixo_lower.split()
    if any(verbo in palavras for verbo in verbos_proibidos):
        return False
    
    # Nome de empresa deve ter pelo menos uma palavra capitalizada ou sigla
    # e n√£o deve come√ßar com artigo/preposi√ß√£o
    palavras_iniciais_invalidas = ['a', 'o', 'as', 'os', 'de', 'da', 'do', 'em', 'no', 'na', 'que', 'e']
    if palavras and palavras[0] in palavras_iniciais_invalidas:
        return False
    
    return True


def extract_motivo_demissao(text: str) -> str | None:
    """
    Extrai motivo da demiss√£o.
    
    2025-11-27: Atualizado com padr√µes expandidos:
    - "sem justa causa", "pedido de demiss√£o", "rescis√£o indireta"
    - "dispensado injustamente", "demiss√£o imotivada"
    - "t√©rmino de contrato de experi√™ncia"
    - "acordo m√∫tuo", "distrato"
    """
    if not text:
        return None
    
    # Lista de motivos comuns (ordem importa: mais espec√≠fico primeiro)
    motivos = [
        # Rescis√£o indireta (alta prioridade)
        (r'rescis[a√£]o\s+indireta', 'Rescis√£o Indireta'),
        (r'pede\s+(?:a\s+)?rescis[a√£]o\s+indireta', 'Rescis√£o Indireta'),
        (r'requerer\s+(?:a\s+)?rescis[a√£]o\s+indireta', 'Rescis√£o Indireta'),
        
        # Rescis√£o contratual gen√©rica
        (r'rescis[a√£]o\s+contratual', 'Rescis√£o Contratual'),
        
        # Dispensa sem justa causa (padr√µes espec√≠ficos)
        (r'dispens(?:a|ad[oa])\s+sem\s+justa\s+causa', 'Dispensa Sem Justa Causa'),
        (r'demitid[oa]\s+sem\s+justa\s+causa', 'Dispensa Sem Justa Causa'),
        (r'desligad[oa]\s+sem\s+justa\s+causa', 'Dispensa Sem Justa Causa'),
        # üÜï "dispensado injustamente", "demiss√£o imotivada"
        (r'dispens(?:a|ad[oa])\s+injustamente', 'Dispensa Sem Justa Causa'),
        (r'demiss[a√£]o\s+imotivada', 'Dispensa Sem Justa Causa'),
        (r'demitid[oa]\s+imotivadamente', 'Dispensa Sem Justa Causa'),
        # üÜï "foi desligado pela empregadora" (sem especificar causa = sem justa causa)
        (r'desligad[oa]\s+(?:pela?\s+)?(?:empregador|empresa|reclamada)', 'Dispensa Sem Justa Causa'),
        
        # Dispensa com justa causa
        (r'dispens(?:a|ad[oa])\s+com\s+justa\s+causa', 'Dispensa Com Justa Causa'),
        (r'demitid[oa]\s+(?:por|com)\s+justa\s+causa', 'Dispensa Com Justa Causa'),
        (r'justa\s+causa(?!\s+(?:na|para))', 'Dispensa Com Justa Causa'),
        # üÜï "despedimento por justa causa"
        (r'despediment[oa]\s+(?:por|com)\s+justa\s+causa', 'Dispensa Com Justa Causa'),
        
        # Pedido de demiss√£o
        (r'pedido\s+(?:de\s+)?demiss[a√£]o', 'Pedido de Demiss√£o'),
        # üÜï "demitiu-se", "pediu para sair"
        (r'demitiu[\-\s]se', 'Pedido de Demiss√£o'),
        (r'pediu\s+para\s+sair', 'Pedido de Demiss√£o'),
        (r'requereu\s+(?:sua\s+)?demiss[a√£]o', 'Pedido de Demiss√£o'),
        
        # T√©rmino de contrato
        (r't[√©e]rmino\s+(?:de\s+|do\s+)contrato', 'T√©rmino de Contrato'),
        # üÜï "t√©rmino de contrato de experi√™ncia", "encerramento de contrato tempor√°rio"
        (r't[√©e]rmino\s+(?:do\s+)?contrato\s+(?:de\s+)?experi[√™e]ncia', 'T√©rmino de Contrato'),
        (r'encerramento\s+(?:do\s+)?contrato', 'T√©rmino de Contrato'),
        (r'fim\s+(?:do\s+)?contrato\s+(?:de\s+)?experi[√™e]ncia', 'T√©rmino de Contrato'),
        
        # Acordo entre as partes
        (r'acordo\s+entre\s+as\s+partes', 'Acordo Entre as Partes'),
        # üÜï "acordo m√∫tuo", "distrato"
        (r'acordo\s+m[√∫u]tuo', 'Acordo Entre as Partes'),
        (r'\bdistrato\b', 'Acordo Entre as Partes'),
        (r'comum\s+acordo', 'Acordo Entre as Partes'),
        
        # Padr√µes gen√©ricos (menor prioridade - fallback)
        (r'(?:foi\s+)?dispensad[oa](?!\s+com)', 'Dispensa Sem Justa Causa'),
    ]
    
    # Buscar primeiros 5000 caracteres para contexto de demiss√£o
    texto_inicial = text[:5000]
    
    for pattern, motivo_label in motivos:
        if re.search(pattern, texto_inicial, re.I):
            return motivo_label
    
    return None


def extract_pedidos(text: str) -> list:
    """
    Extrai lista de pedidos da peti√ß√£o inicial.
    
    FONTE: Se√ß√£o "DOS PEDIDOS" ou "DOS REQUERIMENTOS"
    
    REGRAS:
    - Localizar t√≠tulo "DOS PEDIDOS" 
    - Capturar at√© marcadores de fim: "Nestes termos", "D√°-se √† causa"
    - Identificar cada pedido por bullets/letras: a), b), c)... ou Requer/Seja/Condenar
    
    Returns:
        Lista de strings com cada pedido
    """
    import logging
    logger = logging.getLogger(__name__)
    
    if not text:
        return []
    
    # Normalizar texto
    text_norm = re.sub(r'\s+', ' ', text).strip()
    
    # Localizar in√≠cio da se√ß√£o de pedidos
    # 2025-11-27 FIX: Abordagem simplificada - encontrar in√≠cio e capturar bloco de at√© 6000 chars
    # 2025-11-28 FIX: Adicionados padr√µes para formatos com numeral romano e variantes
    inicio_patterns = [
        r'D\s*O\s*S\s+P\s*E\s*D\s*I\s*D\s*O\s*S\s*(?:Diante\s+o\s+exposto,?\s*)?requer\s*:?\s*',
        r'DOS\s+PEDIDOS\s*[:\s]*',
        r'DOS\s+REQUERIMENTOS\s*[:\s]*',
        r'PEDIDOS\s+FINAIS\s*[:\s]*',
        r'(?:Diante|Ante)\s+(?:do|o)\s+exposto,?\s*requer\s*:?\s*',
        r'(?:Pelo\s+exposto|Diante\s+disso),?\s*requer\s*:?\s*',
        # 2025-11-28: Formatos com numeral romano (VI-PEDIDOS, VII-PEDIDOS, etc)
        r'[IVX]{1,4}\s*[-‚Äì]\s*PEDIDOS?\s*:?\s*(?:Assim\s+[√©e]\s+a\s+presente\s+para\s+reclamar\s*:?\s*)?',
        # 2025-11-28: "PEDIDOS:" simples no in√≠cio de se√ß√£o
        r'\bPEDIDOS\s*:\s*(?:Assim\s+[√©e]\s+a\s+presente\s+para\s+reclamar\s*:?\s*)?',
        # 2025-11-28: "Assim requer:" ou "Requer:" como in√≠cio de lista de pedidos
        r'Assim\s+[√©e]\s+a\s+presente\s+para\s+reclamar\s*:?\s*',
    ]
    
    inicio_match = None
    for pattern in inicio_patterns:
        match = re.search(pattern, text_norm, re.I)
        if match:
            inicio_match = match
            logger.debug(f"[PEDIDOS] In√≠cio encontrado com '{pattern[:30]}...' em pos {match.end()}")
            break
    
    if not inicio_match:
        logger.debug("[PEDIDOS] Nenhum padr√£o de in√≠cio de pedidos encontrado")
        return []
    
    # Capturar bloco de at√© 12000 chars a partir do fim do match inicial
    # 2025-11-27: Aumentado para 12000 para peti√ß√µes com 30+ pedidos
    start_pos = inicio_match.end()
    max_len = 12000
    raw_block = text_norm[start_pos:start_pos + max_len]
    
    # Tentar encontrar um terminador pr√≥ximo para delimitar melhor
    # 2025-11-28: Adicionados terminadores para texto p√≥s-lista de pedidos
    terminators = [
        (r'Atribui-se\s+[√†a]\s+causa', 'Atribui-se'),
        (r'Termos\s+em\s+que', 'Termos em que'),
        (r'Nestes\s+termos', 'Nestes termos'),
        (r'D[√°a]-se\s+[√†a]\s+causa', 'D√°-se √† causa'),
        (r'P\.\s*Deferimento', 'P. Deferimento'),
        (r'Pede\s+deferimento', 'Pede deferimento'),
        (r'TUDO\s+A\s+SER\s+APURADO', 'TUDO A SER APURADO'),
        (r'Isto\s+posto\s+requer', 'Isto posto requer'),
        (r'Protesta\s+pela\s+produ[√ßc][√£a]o', 'Protesta pela produ√ß√£o'),
    ]
    
    end_pos = len(raw_block)
    for pattern, name in terminators:
        term_match = re.search(pattern, raw_block, re.I)
        if term_match:
            end_pos = min(end_pos, term_match.start())
            logger.debug(f"[PEDIDOS] Terminador '{name}' encontrado em pos {term_match.start()}")
            break
    
    secao_pedidos = raw_block[:end_pos].strip()
    logger.debug(f"[PEDIDOS] Se√ß√£o encontrada com {len(secao_pedidos)} chars")
    
    pedidos = []
    
    # Padr√£o 1: Letras a), b), c)... - split por letra seguida de par√™ntese
    # Usa split para dividir corretamente
    partes = re.split(r'(?:^|\s)([a-z]\))', secao_pedidos, flags=re.I)
    
    # partes ser√° algo como ['Ante o exposto, requer:', 'a)', 'condena√ß√£o...', 'b)', 'pagamento...', etc]
    i = 1
    while i < len(partes) - 1:
        if re.match(r'^[a-z]\)$', partes[i], re.I):
            # Pr√≥ximo elemento √© o texto do pedido
            if i + 1 < len(partes):
                pedido = partes[i + 1].strip()
                # Limpar ponto e v√≠rgula do final
                pedido = re.sub(r';?\s*$', '', pedido)
                pedido = re.sub(r'\s+', ' ', pedido)
                if pedido and len(pedido) > 10:
                    pedidos.append(pedido)
            i += 2
        else:
            i += 1
    
    # üÜï 2025-11-28: Padr√£o 1.2: Letras a-, b-, c-... (h√≠fen ao inv√©s de par√™ntese)
    if not pedidos:
        partes_hifen = re.split(r'(?:^|\s)([a-z]-)', secao_pedidos, flags=re.I)
        i = 1
        while i < len(partes_hifen) - 1:
            if re.match(r'^[a-z]-$', partes_hifen[i], re.I):
                if i + 1 < len(partes_hifen):
                    pedido = partes_hifen[i + 1].strip()
                    pedido = re.sub(r';?\s*$', '', pedido)
                    pedido = re.sub(r'\s+', ' ', pedido)
                    if pedido and len(pedido) > 10:
                        pedidos.append(pedido)
                i += 2
            else:
                i += 1
    
    # üÜï 2025-11-27: Padr√£o 1.5: N√∫meros 1), 2), 3)... (formato numerado)
    if not pedidos:
        partes_num = re.split(r'(?:^|\s)(\d{1,2}\))', secao_pedidos)
        i = 1
        while i < len(partes_num) - 1:
            if re.match(r'^\d{1,2}\)$', partes_num[i]):
                if i + 1 < len(partes_num):
                    pedido = partes_num[i + 1].strip()
                    pedido = re.sub(r';?\s*$', '', pedido)
                    pedido = re.sub(r'\s+', ' ', pedido)
                    if pedido and len(pedido) > 10:
                        pedidos.append(pedido)
                i += 2
            else:
                i += 1
    
    # Se n√£o encontrou por letras, tentar por verbos
    if not pedidos:
        # Padr√£o 2: Verbos imperativos (Requer, Seja, Condenar)
        verbo_patterns = [
            r'(?:Requer(?:-se)?|Requeiro)\s+([^\.]{20,300}\.)',
            r'(?:Seja|Sejam)\s+([^\.]{20,300}\.)',
            r'(?:Condenar|A\s+condena√ß√£o)\s+([^\.]{20,300}\.)',
        ]
        
        for pattern in verbo_patterns:
            for match in re.finditer(pattern, secao_pedidos, re.I):
                pedido = match.group(0).strip()
                pedido = re.sub(r'\s+', ' ', pedido)
                if pedido and len(pedido) > 20:
                    pedidos.append(pedido)
    
    # 2025-11-28: Limpar texto residual de cada pedido (frases p√≥s-lista)
    post_list_markers = [
        r'\s*TUDO\s+A\s+SER\s+APURADO.*',
        r'\s*Isto\s+posto\s+requer.*',
        r'\s*Protesta\s+pela\s+produ[√ßc][√£a]o.*',
        r'\s*Os\s+valores\s+acima\s+s[√£a]o\s+de\s+al[√ßc]ada.*',
    ]
    pedidos_limpos = []
    for pedido in pedidos:
        for marker in post_list_markers:
            pedido = re.sub(marker, '', pedido, flags=re.I | re.DOTALL)
        pedido = pedido.strip()
        if pedido and len(pedido) > 10:
            pedidos_limpos.append(pedido)
    
    # Remover duplicatas mantendo ordem
    seen = set()
    unique_pedidos = []
    for p in pedidos_limpos:
        p_norm = p.lower()[:50]  # Comparar primeiros 50 chars
        if p_norm not in seen:
            seen.add(p_norm)
            unique_pedidos.append(p)
    
    logger.debug(f"[PEDIDOS] Extra√≠dos {len(unique_pedidos)} pedidos")
    return unique_pedidos[:15]  # Limitar a 15 pedidos


def extract_advogado_adverso(text: str) -> tuple:
    """
    Extrai advogado da parte adversa (RECLAMADO/empregador).
    
    REGRAS:
    - Em processos trabalhistas, a parte adversa √© o RECLAMADO (empregador)
    - Buscar advogado listado ap√≥s RECLAMADO/R√âU na capa do processo
    - Retornar (nome, OAB) ou (None, None)
    
    Returns:
        Tupla (advogado_nome, advogado_oab)
    """
    import logging
    logger = logging.getLogger(__name__)
    
    if not text:
        return None, None
    
    # Normalizar texto
    text_norm = re.sub(r'\s+', ' ', text).strip()
    
    # PADR√ÉO 1: Advogado com OAB em qualquer contexto de contesta√ß√£o/defesa
    # "Advogado Dr. CARLOS ALBERTO SOUZA, OAB/RJ 98765"
    # "por seu Advogado MARIA SILVA OAB/SP 12345"
    contestacao_patterns = [
        # "Advogado Dr. NOME, OAB/XX 12345"
        r'(?:Advogado|Procurador)\s+(?:Dr\.?\s+|Dra\.?\s+)?([A-Z√Ä-√ö][A-Z√Ä-√öa-z√†-√∫\s\.]+?)[,\s]+OAB[/\s\-]*([A-Z]{2})\s*[:\s\-]*(\d+)',
        # "Advogado NOME OAB/XX 12345" (sem v√≠rgula)
        r'(?:Advogado|Procurador)\s+(?:Dr\.?\s+|Dra\.?\s+)?([A-Z√Ä-√ö][A-Z√Ä-√öa-z√†-√∫\s\.]+?)\s+OAB[/\s\-]*([A-Z]{2})\s*[:\s\-]*(\d+)',
        # "por seu Advogado NOME, OAB/XX 12345"  
        r'por\s+seu\s+(?:Advogado|Procurador)\s+(?:Dr\.?\s+|Dra\.?\s+)?([A-Z√Ä-√ö][A-Z√Ä-√öa-z√†-√∫\s\.]+?)[,\s]+OAB[/\s\-]*([A-Z]{2})\s*[:\s\-]*(\d+)',
    ]
    
    # Buscar primeiro no contexto de contesta√ß√£o/defesa (mais prov√°vel ser adverso)
    for pattern in contestacao_patterns:
        match = re.search(pattern, text_norm, re.I)
        if match:
            nome = match.group(1).strip()
            nome = re.sub(r'\s+', ' ', nome)
            # Limpar trailing como v√≠rgulas
            nome = nome.rstrip(',. ')
            oab = f"OAB/{match.group(2).upper()} {match.group(3)}"
            
            # Validar que n√£o √© muito curto
            if len(nome) > 5:
                logger.debug(f"[ADV_ADVERSO] Encontrado: {nome}, {oab}")
                return nome, oab
    
    # PADR√ÉO 2: Capa do processo - ap√≥s "RECLAMADO/R√âU"
    # "RECLAMADO: EMPRESA ADVOGADO: NOME OAB/XX 12345"
    reu_advogado = re.search(
        r'(?:RECLAMADO|RECLAMADA|R[√âE]U)[:\s]+.{5,200}?(?:ADVOGADO|ADV\.?)[:\s]+([A-Z√Ä-√öa-z√†-√∫\s\.]+?)\s+OAB[/\s\-]*([A-Z]{2})\s*[:\s\-]*(\d+)',
        text_norm,
        re.I
    )
    
    if reu_advogado:
        nome = reu_advogado.group(1).strip()
        nome = re.sub(r'\s+', ' ', nome)
        nome = nome.rstrip(',. ')
        oab = f"OAB/{reu_advogado.group(2).upper()} {reu_advogado.group(3)}"
        
        if len(nome) > 5:
            logger.debug(f"[ADV_ADVERSO] Encontrado na capa: {nome}, {oab}")
            return nome, oab
    
    return None, None


# ============================================================================
# M√öLTIPLAS RECLAMADAS - Extra√ß√£o de todas as partes reclamadas
# ============================================================================

def _normalizar_nome_reclamada(nome: str) -> str:
    """
    Normaliza o nome de uma reclamada para compara√ß√£o e deduplica√ß√£o.
    Remove sufixos de metadados do PDF, espa√ßos extras, etc.
    """
    if not nome:
        return ""
    
    nome_norm = nome.upper().strip()
    
    sufixos_remover = [
        r'\s+PAGINA_CAPA_PROCESSO_PJE?$',
        r'\s+PAGINA_CAPA_PROCESSO$',
        r'\s+CAPA_PROCESSO$',
        r'\s+PJE$',
        r'\s+\(POLO PASSIVO\)$',
        r'\s+\(RECLAMAD[OA]\)$',
        r'\s+\(R[√âE]U?\)$',
    ]
    
    for sufixo in sufixos_remover:
        nome_norm = re.sub(sufixo, '', nome_norm, flags=re.I)
    
    nome_norm = re.sub(r'\s+', ' ', nome_norm).strip()
    nome_norm = nome_norm.rstrip('.,;:-')
    
    return nome_norm


def _is_nome_invalido(nome: str) -> bool:
    """
    Verifica se o nome √© inv√°lido/lixo que n√£o deveria ser considerado como reclamada.
    """
    if not nome or len(nome) < 5:
        return True
    
    nome_upper = nome.upper()
    
    termos_invalidos = [
        'AUDIENCIA',
        'AUDI√äNCIA',
        'DOMICILIO ELETRONICO',
        'DOMIC√çLIO ELETR√îNICO',
        'NOTIFICA√á√ÉO',
        'NOTIFICACAO',
        'DATA AJUIZAMENTO',
        'PERIODO DO CALCULO',
        'PER√çODO DO C√ÅLCULO',
        'PLANILHA DE',
        'PAGINA_',
        'CAPA_PROCESSO',
        'POLO PASSIVO',
        'VALOR DA CAUSA',
        'CLASSE JUDICIAL',
        'ASSUNTO CNJ',
        'DISTRIBUICAO',
        'DISTRIBUI√á√ÉO',
        'COMPETENCIA',
        'COMPET√äNCIA',
        'ORGAO JULGADOR',
        '√ìRG√ÉO JULGADOR',
        'RELATOR',
        'JULGAMENTO',
        'RECUSA EM',
        'CONDUTA DA',
        'EXPOSI√á√ÉO AOS',
        'PRODU√á√ÉO DE PROVA',
        'MEDIANTE',
        'INSTRU√á√ÉO',
        'PERFIL PRO',
        'RETIFICA√á√ÉO',
        'AGENTES NOCIVOS',
        'PROVA DOCUMENTAL',
        'PROVA PERICIAL',
        'PEDIDO DE',
        'PEDIDOS PREVI',
        'PPP E O LTCAT',
        'EMITIR O PPP',
    ]
    
    for termo in termos_invalidos:
        if termo in nome_upper:
            return True
    
    if re.match(r'^\d{2}/\d{2}/\d{4}', nome_upper):
        return True
    
    if re.match(r'^\d+\s+[A-Z]{2},?\s+RELATOR', nome_upper):
        return True
    
    if not re.search(r'[A-Z√Ä-√ö]{3,}', nome_upper):
        return True
    
    palavras = nome_upper.split()
    if len(palavras) < 2:
        return True
    
    if len(palavras[0]) < 2 or not palavras[0][0].isalpha():
        return True
    
    if any(termo in nome_upper for termo in ['DOLOSA', 'RECUSA', 'ADOTAR', 'GISTRO', 'TIFICA√á√ÉO', 'CLAMADA']):
        if not any(termo in nome_upper for termo in ['LTDA', 'S.A', 'S/A', 'EIRELI', 'ME', 'EPP', 'CIA', 'COMPANHIA']):
            return True
    
    return False


def _nomes_sao_similares(nome1: str, nome2: str, threshold: float = 0.85) -> bool:
    """
    Verifica se dois nomes s√£o similares usando fuzzy matching.
    Retorna True se a similaridade for >= threshold.
    """
    from rapidfuzz import fuzz
    
    n1 = _normalizar_nome_reclamada(nome1)
    n2 = _normalizar_nome_reclamada(nome2)
    
    if not n1 or not n2:
        return False
    
    if n1 == n2:
        return True
    
    if n1 in n2 or n2 in n1:
        return True
    
    ratio = fuzz.ratio(n1, n2) / 100.0
    return ratio >= threshold


def extract_todas_reclamadas(text: str) -> list:
    """
    Extrai TODAS as partes reclamadas do texto do PDF.
    
    Identifica todas as partes com papel de r√©/reclamada, como:
    - RECLAMADO, RECLAMADA, RECLAMADOS, RECLAMADAS
    - R√âU, R√â, R√âUS
    - APELADO, AGRAVADO, etc.
    
    Inclui:
    - Normaliza√ß√£o de nomes (remove sufixos de metadados do PDF)
    - Deduplica√ß√£o com fuzzy matching
    - Filtro de nomes inv√°lidos
    
    Returns:
        Lista de dicion√°rios, cada um contendo:
        {
            "nome": "<NOME COMPLETO DA RECLAMADA>",
            "posicao": "<posi√ß√£o no processo: RECLAMADO, R√âU, etc>",
            "tipo_pessoa": "fisica" | "juridica" | None
        }
        
        A primeira posi√ß√£o (√≠ndice 0) √© a reclamada principal.
        As demais (√≠ndice 1+) s√£o reclamadas extras.
    """
    import logging
    logger = logging.getLogger(__name__)
    
    if not text:
        logger.debug("[RECLAMADAS][EXTRACT] Texto vazio, retornando lista vazia")
        return []
    
    t = text
    candidatas = []
    
    pattern = r'\b(RECLAMAD[OA]S?|R[√âE]US?|R[√âE]\b|APOLAD[OA]|AGRAVAD[OA]|EMBARGAD[OA]|EXECUTAD[OA]|REQUERID[OA]|DEMANDAD[OA])\s*[:\-]\s*([^\n]+)'
    
    for match in re.finditer(pattern, t, re.I):
        label = match.group(1).upper()
        nome_bruto = match.group(2).strip()
        
        tokens_fim = [
            r'\s+ADVOGADO\b', r'\s+ADV\.', r'\s+CPF\b', r'\s+CNPJ\b',
            r'\s+RECLAMANTE\b', r'\s+AUTOR\b', r'\s+PARTES\b',
            r'\s+\d{2}\.\d{3}\.\d{3}',
            r'\s+\d{2}\.\d{3}\.\d{3}/\d{4}',
        ]
        
        nome_limpo = nome_bruto
        for tok in tokens_fim:
            nome_limpo = re.split(tok, nome_limpo, flags=re.I)[0].strip()
        
        nome_limpo = nome_limpo.rstrip('.,;:')
        nome_limpo = re.sub(r'\s+', ' ', nome_limpo).strip()
        
        nome_normalizado = _normalizar_nome_reclamada(nome_limpo)
        
        if _is_nome_invalido(nome_normalizado):
            logger.debug(f"[RECLAMADAS][EXTRACT] Ignorando nome inv√°lido: {nome_limpo[:50]}")
            continue
        
        label_norm = label.replace("√â", "E").replace("√É", "A")
        if "RECLAM" in label_norm:
            posicao = "RECLAMADO"
        elif "REU" in label_norm or "RE" in label_norm:
            posicao = "REU"
        else:
            posicao = label
        
        tipo = "juridica" if is_pessoa_juridica(nome_limpo) else "fisica"
        
        candidatas.append({
            "nome": nome_normalizado,
            "nome_original": nome_limpo,
            "posicao": posicao,
            "tipo_pessoa": tipo
        })
    
    reclamadas = []
    for candidata in candidatas:
        is_duplicata = False
        for existente in reclamadas:
            if _nomes_sao_similares(candidata["nome"], existente["nome"]):
                is_duplicata = True
                logger.debug(f"[RECLAMADAS][EXTRACT] Duplicata ignorada: '{candidata['nome'][:40]}' similar a '{existente['nome'][:40]}'")
                break
        
        if not is_duplicata:
            reclamadas.append({
                "nome": candidata["nome"],
                "posicao": candidata["posicao"],
                "tipo_pessoa": candidata["tipo_pessoa"]
            })
            logger.info(f"[RECLAMADAS][EXTRACT] Encontrada: {candidata['nome']} ({candidata['posicao']}, {candidata['tipo_pessoa']})")
    
    reclamadas_pj = [r for r in reclamadas if r["tipo_pessoa"] == "juridica"]
    reclamadas_pf = [r for r in reclamadas if r["tipo_pessoa"] != "juridica"]
    reclamadas = reclamadas_pj + reclamadas_pf
    
    logger.info(f"[RECLAMADAS][EXTRACT] Total: {len(reclamadas)} reclamadas √∫nicas (PJ: {len(reclamadas_pj)}, PF: {len(reclamadas_pf)})")
    
    return reclamadas



================================================================================
FILE: extractors/ocr_utils.py
================================================================================
# extractors/ocr_utils.py
"""
M√≥dulo OCR para extra√ß√£o de PDFs escaneados usando Tesseract.
Aplica OCR seletivo apenas quando texto nativo √© insuficiente.
"""
import logging
import os
from typing import Optional, Dict, List
from pdf2image import convert_from_path
import pytesseract
from PIL import Image

def _get_poppler_path() -> Optional[str]:
    """
    Encontra o caminho do poppler no ambiente Nix.
    O poppler_utils pode estar em diferentes locais dependendo da instala√ß√£o.
    Retorna None se n√£o estiver em ambiente Nix ou poppler n√£o estiver instalado.
    """
    nix_store = "/nix/store"
    
    if not os.path.isdir(nix_store):
        return None
    
    possible_paths = [
        "/nix/store/ibb9lajxj2jr8z0bmriqyc43648b7fql-poppler-utils-25.05.0/bin",
    ]
    
    try:
        for nix_dir in os.listdir(nix_store):
            if "poppler" in nix_dir.lower() and "utils" in nix_dir.lower():
                path = f"{nix_store}/{nix_dir}/bin"
                if os.path.exists(path):
                    possible_paths.append(path)
    except (PermissionError, OSError) as e:
        logging.getLogger(__name__).warning(f"[OCR] N√£o foi poss√≠vel listar {nix_store}: {e}")
    
    for path in possible_paths:
        pdftoppm = os.path.join(path, "pdftoppm")
        if os.path.exists(pdftoppm):
            return path
    
    return None

POPPLER_PATH = _get_poppler_path()
if POPPLER_PATH:
    logging.getLogger(__name__).info(f"[OCR] Poppler encontrado: {POPPLER_PATH}")
else:
    logging.getLogger(__name__).warning("[OCR] Poppler n√£o encontrado - OCR usar√° configura√ß√£o padr√£o do sistema")


def detect_scanned_pages(pdf_path: str, min_text_len: int = 50) -> List[int]:
    """
    Detecta p√°ginas escaneadas em um PDF usando heur√≠stica robusta.
    
    2025-12-01: Plano Batman - Mapeamento cir√∫rgico para OCR seletivo.
    
    Heur√≠stica: Uma p√°gina √© considerada escaneada se:
    - Tem menos de 50 caracteres de texto nativo E
    - Est√° nas √∫ltimas 30% do documento (onde anexos como TRCT/contracheques costumam estar)
    
    Args:
        pdf_path: Caminho do PDF
        min_text_len: M√≠nimo de caracteres para considerar p√°gina como texto (default: 50)
    
    Returns:
        Lista de n√∫meros de p√°ginas escaneadas nas √∫ltimas 30% do PDF (1-indexed)
    """
    from PyPDF2 import PdfReader
    
    scanned_pages = []
    logger = logging.getLogger(__name__)
    
    try:
        reader = PdfReader(pdf_path)
        total_pages = len(reader.pages)
        
        # S√≥ considera p√°ginas nas √∫ltimas 30% do PDF (onde anexos costumam estar)
        annex_start = max(1, int(total_pages * 0.7))
        
        for i, page in enumerate(reader.pages, 1):
            # Pular p√°ginas que n√£o est√£o na zona de anexos
            if i < annex_start:
                continue
            
            text = page.extract_text() or ""
            text_len = len(text.strip())
            
            # P√°gina com menos de 50 chars na zona de anexos = prov√°vel scan
            if text_len < min_text_len:
                scanned_pages.append(i)
                logger.debug(f"[DETECT_SCANNED] P√°gina {i}/{total_pages}: {text_len} chars - ESCANEADA")
        
        if scanned_pages:
            logger.info(f"[DETECT_SCANNED] {len(scanned_pages)} p√°ginas escaneadas na zona de anexos: {scanned_pages}")
        
    except Exception as e:
        logger.debug(f"[DETECT_SCANNED] Erro ao analisar PDF: {e}")
    
    return scanned_pages


def ocr_extract_from_pages(pdf_path: str, pages: List[int]) -> Dict[str, str]:
    """
    Aplica OCR apenas nas p√°ginas espec√≠ficas e extrai campos trabalhistas.
    
    2025-12-01: Plano Batman - OCR cir√∫rgico apenas nas p√°ginas mapeadas.
    
    Args:
        pdf_path: Caminho do PDF
        pages: Lista de n√∫meros de p√°ginas para processar (1-indexed)
    
    Returns:
        Dict com campos extra√≠dos: {"salario": "...", "pis": "...", "ctps": "..."}
    """
    import re
    
    result = {}
    
    if not pages:
        return result
    
    try:
        logger = logging.getLogger(__name__)
        logger.info(f"[OCR_CIRURGICO] Processando {len(pages)} p√°ginas: {pages}")
        
        texto_ocr = ""
        for page_num in pages:
            try:
                images = convert_from_path(
                    pdf_path,
                    dpi=150,
                    first_page=page_num,
                    last_page=page_num,
                    poppler_path=POPPLER_PATH
                )
                
                for img in images:
                    img_gray = img.convert('L')
                    config = '--psm 6 -l por+eng'
                    texto_pagina = pytesseract.image_to_string(img_gray, config=config)
                    texto_ocr += f"\n{texto_pagina}"
            except Exception as e:
                logger.debug(f"[OCR_CIRURGICO] Erro p√°gina {page_num}: {e}")
        
        if not texto_ocr:
            return result
        
        # Extrair sal√°rio
        salario_patterns = [
            r'(?:sal[a√°]rio|remunera[c√ß][a√£]o|vencimento)[:\s]*R?\$?\s*([\d.,]+)',
            r'R\$\s*([\d]{1,3}(?:\.?\d{3})*[,\.]\d{2})',
        ]
        for pattern in salario_patterns:
            m = re.search(pattern, texto_ocr, re.IGNORECASE)
            if m:
                val = m.group(1).replace('.', '').replace(',', '.')
                try:
                    if float(val) > 500:
                        result["salario"] = f"R$ {m.group(1)}"
                        logger.info(f"[OCR_CIRURGICO] Sal√°rio: {result['salario']}")
                        break
                except:
                    pass
        
        # Extrair PIS
        pis_patterns = [
            r'(?:PIS|PASEP|NIT)[:\s/]*(\d{3}[.\s]?\d{5}[.\s]?\d{2}[.\s-]?\d)',
            r'\b(\d{3}\.\d{5}\.\d{2}[.-]\d)\b',
        ]
        for pattern in pis_patterns:
            m = re.search(pattern, texto_ocr, re.IGNORECASE)
            if m:
                pis_raw = m.group(1).replace(' ', '').replace('.', '').replace('-', '')
                if len(pis_raw) == 11:
                    result["pis"] = f"{pis_raw[:3]}.{pis_raw[3:8]}.{pis_raw[8:10]}-{pis_raw[10]}"
                    logger.info(f"[OCR_CIRURGICO] PIS: {result['pis']}")
                    break
        
        # Extrair CTPS (com UF quando dispon√≠vel)
        ctps_patterns = [
            # Formato com UF: "CTPS 1234567 s√©rie 123/RJ" ou "1234567/123/RJ"
            r'(?:CTPS|Carteira)[:\s]*(\d{5,7})[/\s]*(?:s[e√©]rie|s√©rie)[:\s]*(\d{3,5})[/\s-]*([A-Z]{2})',
            r'(\d{5,7})[/\s-]+(\d{3,5})[/\s-]+([A-Z]{2})',
            # Formato sem UF: "CTPS 1234567 s√©rie 123"
            r'(?:CTPS|Carteira)[:\s]*(\d{5,7})[/\s]*(?:s[e√©]rie|s√©rie)[:\s]*(\d{3,5})',
        ]
        for pattern in ctps_patterns:
            m = re.search(pattern, texto_ocr, re.IGNORECASE)
            if m:
                if len(m.groups()) >= 3 and m.group(3):
                    # Com UF
                    result["ctps"] = f"{m.group(1)} s√©rie {m.group(2)}/{m.group(3)}"
                elif len(m.groups()) >= 2:
                    # Sem UF
                    result["ctps"] = f"{m.group(1)} s√©rie {m.group(2)}"
                else:
                    result["ctps"] = m.group(1)
                logger.info(f"[OCR_CIRURGICO] CTPS: {result['ctps']}")
                break
        
        logger.info(f"[OCR_CIRURGICO] ‚úÖ Extra√≠dos {len(result)} campos via OCR cir√∫rgico")
        return result
        
    except Exception as e:
        logging.getLogger(__name__).error(f"[OCR_CIRURGICO] ‚ùå Erro: {e}")
        return result


# Integra√ß√£o com monitor remoto
try:
    from monitor_integration import log_info, log_error
    MONITOR_AVAILABLE = True
except ImportError:
    MONITOR_AVAILABLE = False
    def log_info(msg, region=""): pass
    def log_error(msg, exc=None, region=""): pass

logger = logging.getLogger(__name__)

def is_scanned_pdf(text: str, page_count: int = 1) -> bool:
    """
    Detecta se PDF √© escaneado (densidade de texto baixa).
    
    Args:
        text: Texto extra√≠do do PDF
        page_count: N√∫mero de p√°ginas do PDF
    
    Returns:
        True se densidade < 200 chars/p√°gina (prov√°vel scan)
    """
    if not text or len(text.strip()) == 0:
        return True
    
    densidade = len(text) / page_count if page_count > 0 else 0
    return densidade < 200


def extract_text_with_ocr(pdf_path: str, first_pages: int = 3) -> str:
    """
    Extrai texto usando OCR (Tesseract) nas primeiras p√°ginas do PDF.
    
    Args:
        pdf_path: Caminho do arquivo PDF
        first_pages: N√∫mero de p√°ginas para processar (default: 3)
    
    Returns:
        Texto extra√≠do via OCR
    """
    try:
        logger.info(f"[OCR] Iniciando extra√ß√£o OCR: {pdf_path}")
        if POPPLER_PATH:
            logger.info(f"[OCR] Usando poppler de: {POPPLER_PATH}")
        
        # Converter PDF para imagens (primeiras N p√°ginas)
        images = convert_from_path(
            pdf_path, 
            dpi=300,  # Alta resolu√ß√£o para melhor OCR
            first_page=1,
            last_page=first_pages,
            poppler_path=POPPLER_PATH
        )
        
        logger.info(f"[OCR] Converteu {len(images)} p√°ginas para imagem")
        
        # Aplicar OCR em cada p√°gina
        texto_completo = []
        for i, img in enumerate(images, 1):
            # Pr√©-processamento: converter para escala de cinza
            img_gray = img.convert('L')
            
            # OCR com Tesseract (pt-BR + eng)
            config = '--psm 6 -l por+eng'  # PSM 6 = blocos de texto, portugu√™s + ingl√™s
            texto_pagina = pytesseract.image_to_string(img_gray, config=config)
            
            texto_completo.append(f"\n--- P√ÅGINA {i} (OCR) ---\n{texto_pagina}")
            logger.debug(f"[OCR] P√°gina {i}: {len(texto_pagina)} chars")
        
        texto_final = "\n".join(texto_completo)
        logger.info(f"[OCR] ‚úÖ Extra√ß√£o conclu√≠da: {len(texto_final)} chars total")
        
        return texto_final
        
    except Exception as e:
        logger.error(f"[OCR] ‚ùå Erro ao processar PDF: {e}")
        return ""


def ocr_extract_labor_fields(pdf_path: str, max_pages: int = 8) -> Dict[str, str]:
    """
    Extrai campos trabalhistas cr√≠ticos (sal√°rio, PIS, CTPS) via OCR seletivo.
    
    Faz OCR nas √öLTIMAS p√°ginas do PDF onde geralmente est√£o TRCT/contracheques.
    
    Args:
        pdf_path: Caminho do PDF
        max_pages: M√°ximo de p√°ginas para processar (default: 8)
    
    Returns:
        Dict com campos extra√≠dos: {"salario": "...", "pis": "...", "ctps": "..."}
    """
    import re
    
    result = {}
    
    try:
        from PyPDF2 import PdfReader
        
        reader = PdfReader(pdf_path)
        total_pages = len(reader.pages)
        
        start_page = max(1, total_pages - max_pages + 1)
        
        logger.info(f"[OCR_LABOR] Extraindo campos trabalhistas via OCR: p√°ginas {start_page}-{total_pages}")
        
        images = convert_from_path(
            pdf_path,
            dpi=150,
            first_page=start_page,
            last_page=total_pages,
            poppler_path=POPPLER_PATH
        )
        
        texto_ocr = ""
        for i, img in enumerate(images, start_page):
            img_gray = img.convert('L')
            config = '--psm 6 -l por+eng'
            texto_pagina = pytesseract.image_to_string(img_gray, config=config)
            texto_ocr += f"\n{texto_pagina}"
        
        if not texto_ocr:
            return result
        
        salario_patterns = [
            r'(?:sal[a√°]rio|remunera[c√ß][a√£]o|vencimento)[:\s]*R?\$?\s*([\d.,]+)',
            r'R\$\s*([\d]{1,3}(?:\.?\d{3})*[,\.]\d{2})',
        ]
        for pattern in salario_patterns:
            m = re.search(pattern, texto_ocr, re.IGNORECASE)
            if m:
                val = m.group(1).replace('.', '').replace(',', '.')
                try:
                    if float(val) > 500:
                        result["salario"] = f"R$ {m.group(1)}"
                        logger.info(f"[OCR_LABOR] Sal√°rio: {result['salario']}")
                        break
                except:
                    pass
        
        pis_patterns = [
            r'(?:PIS|PASEP|NIT)[:\s/]*(\d{3}[.\s]?\d{5}[.\s]?\d{2}[.\s-]?\d)',
            r'\b(\d{3}\.\d{5}\.\d{2}[.-]\d)\b',
        ]
        for pattern in pis_patterns:
            m = re.search(pattern, texto_ocr, re.IGNORECASE)
            if m:
                result["pis"] = m.group(1).replace(' ', '').replace('.', '').replace('-', '')
                logger.info(f"[OCR_LABOR] PIS: {result['pis']}")
                break
        
        ctps_patterns = [
            r'(?:CTPS|Carteira)[:\s]*(\d{5,7})[/\s]*(?:s[e√©]rie|s√©rie)[:\s]*(\d{3,5})',
            r'(\d{5,7})[/\s-]+(\d{3,5})[/\s-]*([A-Z]{2})',
        ]
        for pattern in ctps_patterns:
            m = re.search(pattern, texto_ocr, re.IGNORECASE)
            if m:
                if len(m.groups()) >= 2:
                    result["ctps"] = f"{m.group(1)} s√©rie {m.group(2)}"
                else:
                    result["ctps"] = m.group(1)
                logger.info(f"[OCR_LABOR] CTPS: {result['ctps']}")
                break
        
        logger.info(f"[OCR_LABOR] ‚úÖ Extra√≠dos {len(result)} campos via OCR")
        return result
        
    except Exception as e:
        logger.error(f"[OCR_LABOR] ‚ùå Erro: {e}")
        return result


def extract_text_from_annex_pages(pdf_path: str, last_pages: int = 5) -> str:
    """
    Extrai texto via OCR das √öLTIMAS p√°ginas do PDF (onde est√£o anexos como TRCT/contracheques).
    
    2025-11-28: Fun√ß√£o criada para resolver problema de PDFs h√≠bridos:
    - Peti√ß√£o inicial nas primeiras p√°ginas (texto nativo)
    - Anexos (TRCT, contracheques) nas √∫ltimas p√°ginas (escaneados/imagens)
    
    Args:
        pdf_path: Caminho do arquivo PDF
        last_pages: N√∫mero de p√°ginas finais para processar (default: 5)
    
    Returns:
        Texto extra√≠do via OCR das √∫ltimas p√°ginas
    """
    try:
        from PyPDF2 import PdfReader
        
        reader = PdfReader(pdf_path)
        total_pages = len(reader.pages)
        
        if total_pages <= last_pages:
            start_page = 1
        else:
            start_page = total_pages - last_pages + 1
        
        logger.info(f"[OCR_ANNEX] Processando p√°ginas {start_page}-{total_pages} de {total_pages}")
        
        images = convert_from_path(
            pdf_path, 
            dpi=150,
            first_page=start_page,
            last_page=total_pages,
            poppler_path=POPPLER_PATH
        )
        
        texto_completo = []
        for i, img in enumerate(images, start_page):
            img_gray = img.convert('L')
            config = '--psm 6 -l por+eng'
            texto_pagina = pytesseract.image_to_string(img_gray, config=config)
            
            if texto_pagina and len(texto_pagina.strip()) > 50:
                texto_completo.append(f"\n--- ANEXO P√ÅGINA {i} (OCR) ---\n{texto_pagina}")
                logger.debug(f"[OCR_ANNEX] P√°gina {i}: {len(texto_pagina)} chars")
        
        texto_final = "\n".join(texto_completo)
        logger.info(f"[OCR_ANNEX] ‚úÖ Extra√ß√£o de anexos: {len(texto_final)} chars")
        
        return texto_final
        
    except Exception as e:
        logger.error(f"[OCR_ANNEX] ‚ùå Erro ao processar anexos: {e}")
        return ""


def _parse_sumario_for_annex_ranges(reader, scanned_pages: List[int]) -> Dict[str, List[int]]:
    """
    Analisa p√°ginas de sum√°rio/√≠ndice para inferir quais p√°ginas escaneadas 
    correspondem a cada tipo de documento.
    
    Estrat√©gia: O sum√°rio lista documentos em ordem. Identificamos a ordem
    e mapeamos para as p√°ginas escaneadas na mesma sequ√™ncia.
    """
    import re
    
    annex_order = []
    
    for i, page in enumerate(reader.pages):
        text = page.extract_text() or ""
        text_lower = text.lower()
        
        if "sum√°rio" in text_lower or "documentos" in text_lower:
            lines = text.split('\n')
            for line in lines:
                line_lower = line.lower()
                if "trct" in line_lower or "termo de rescis" in line_lower:
                    annex_order.append('trct')
                elif any(kw in line_lower for kw in ["contracheque", "holerite", "recibo de"]):
                    annex_order.append('contracheque')
                elif "ficha de registro" in line_lower:
                    annex_order.append('ficha_registro')
                elif "ctps" in line_lower or "carteira de trabalho" in line_lower:
                    annex_order.append('ctps')
    
    result = {'trct': [], 'contracheque': [], 'ficha_registro': [], 'ctps': []}
    
    if annex_order and scanned_pages:
        pages_per_annex = max(1, len(scanned_pages) // max(1, len(annex_order)))
        
        for idx, annex_type in enumerate(annex_order):
            start_idx = idx * pages_per_annex
            end_idx = min(start_idx + pages_per_annex, len(scanned_pages))
            if start_idx < len(scanned_pages):
                result[annex_type].extend(scanned_pages[start_idx:end_idx])
    
    return result


def map_pdf_annexes(pdf_path: str) -> Dict[str, List[int]]:
    """
    MAPEAMENTO CIR√öRGICO: Identifica localiza√ß√£o exata de cada tipo de anexo no PDF.
    
    Estrat√©gia (melhorada):
    1. Analisa texto nativo de cada p√°gina para identificar tipo de documento
    2. P√°ginas com < 200 chars = escaneadas (candidatas a OCR)
    3. Se n√£o encontrar tipos espec√≠ficos, usa sum√°rio para inferir ordem
    4. Fallback: divide p√°ginas escaneadas em grupos l√≥gicos
    
    Returns:
        Dict com listas de p√°ginas por tipo:
        {
            'trct': [17, 18],        # P√°ginas do TRCT
            'contracheque': [19, 20, 21],  # P√°ginas de contracheques
            'ficha_registro': [22],  # Ficha de registro
            'ctps': [23, 24],        # CTPS
            'audiencia': [35, 36],   # Notifica√ß√µes de audi√™ncia
            'scanned': [17, 18, 19, 20, 21, 22, 23, 24]  # Todas p√°ginas escaneadas
            'salary_candidates': [17, 18, 19]  # P√°ginas prov√°veis para sal√°rio
        }
    """
    from PyPDF2 import PdfReader
    
    try:
        reader = PdfReader(pdf_path)
        total_pages = len(reader.pages)
        
        mapping = {
            'trct': [],
            'contracheque': [],
            'ficha_registro': [],
            'ctps': [],
            'audiencia': [],
            'scanned': [],
            'salary_candidates': [],
            'total_pages': total_pages
        }
        
        SCANNED_THRESHOLD = 200
        
        for i, page in enumerate(reader.pages):
            page_num = i + 1
            text = page.extract_text() or ""
            text_lower = text.lower()
            text_len = len(text.strip())
            
            is_scanned = text_len < SCANNED_THRESHOLD
            
            if is_scanned:
                mapping['scanned'].append(page_num)
            
            if "termo de rescis" in text_lower or ("trct" in text_lower and "contrato" in text_lower):
                mapping['trct'].append(page_num)
            
            if any(kw in text_lower for kw in ["contracheque", "holerite", "demonstrativo de pagamento", "folha de pagamento"]):
                mapping['contracheque'].append(page_num)
            
            if "ficha de registro" in text_lower or "registro de empregado" in text_lower:
                mapping['ficha_registro'].append(page_num)
            
            if "carteira de trabalho" in text_lower or ("ctps" in text_lower and len(text_lower) > 100):
                mapping['ctps'].append(page_num)
            
            if any(kw in text_lower for kw in ["notifica√ß√£o", "audi√™ncia", "comparecimento"]):
                if "data" in text_lower and ("hora" in text_lower or ":" in text):
                    mapping['audiencia'].append(page_num)
        
        has_specific_types = any([
            [p for p in mapping['trct'] if p in mapping['scanned']],
            [p for p in mapping['contracheque'] if p in mapping['scanned']],
            [p for p in mapping['ficha_registro'] if p in mapping['scanned']],
            [p for p in mapping['ctps'] if p in mapping['scanned']]
        ])
        
        if not has_specific_types and mapping['scanned']:
            inferred = _parse_sumario_for_annex_ranges(reader, mapping['scanned'])
            for key in ['trct', 'contracheque', 'ficha_registro', 'ctps']:
                if inferred.get(key):
                    mapping[key] = inferred[key]
        
        if mapping['scanned']:
            scanned = mapping['scanned']
            
            if len(scanned) <= 10:
                mapping['salary_candidates'] = scanned[:]
            else:
                first_chunk = scanned[:5]
                
                mid_start = len(scanned) // 3
                mid_chunk = scanned[mid_start:mid_start+3]
                
                mapping['salary_candidates'] = list(set(first_chunk + mid_chunk))
                mapping['salary_candidates'].sort()
        
        scanned_count = len(mapping['scanned'])
        logger.info(f"[MAP] PDF mapeado: {total_pages} p√°ginas, {scanned_count} escaneadas")
        logger.info(f"[MAP] TRCT: {mapping['trct']}, Contracheque: {mapping['contracheque']}, Audi√™ncia: {mapping['audiencia']}")
        logger.info(f"[MAP] Candidatos sal√°rio: {mapping['salary_candidates'][:8]}")
        
        return mapping
        
    except Exception as e:
        logger.error(f"[MAP] Erro ao mapear PDF: {e}")
        return {'trct': [], 'contracheque': [], 'ficha_registro': [], 'ctps': [], 'audiencia': [], 'scanned': [], 'salary_candidates': [], 'total_pages': 0}


def extract_ocr_from_specific_pages(pdf_path: str, pages: List[int], max_pages: int = 10) -> str:
    """
    OCR CIR√öRGICO: Processa APENAS p√°ginas espec√≠ficas identificadas pelo mapeamento.
    
    Otimiza√ß√£o m√°xima:
    - Processa somente p√°ginas relevantes (n√£o o PDF inteiro)
    - Limita a max_pages para evitar processamento excessivo
    - 150dpi para balan√ßo entre qualidade e velocidade
    
    Args:
        pdf_path: Caminho do PDF
        pages: Lista de p√°ginas espec√≠ficas para processar (1-indexed)
        max_pages: Limite de p√°ginas para processar (default: 10)
    
    Returns:
        Texto extra√≠do via OCR das p√°ginas especificadas
    """
    if not pages:
        return ""
    
    pages_to_process = pages[:max_pages]
    
    try:
        texto_completo = []
        
        for page_num in pages_to_process:
            try:
                images = convert_from_path(
                    pdf_path,
                    dpi=150,
                    first_page=page_num,
                    last_page=page_num,
                    poppler_path=POPPLER_PATH
                )
                
                if images:
                    img_gray = images[0].convert('L')
                    config = '--psm 6 -l por+eng'
                    texto_pagina = pytesseract.image_to_string(img_gray, config=config)
                    
                    if texto_pagina and len(texto_pagina.strip()) > 30:
                        texto_completo.append(f"\n--- P√ÅGINA {page_num} (OCR) ---\n{texto_pagina}")
                        logger.debug(f"[OCR_SURGICAL] P√°gina {page_num}: {len(texto_pagina)} chars")
                        
            except Exception as e:
                logger.warning(f"[OCR_SURGICAL] Erro na p√°gina {page_num}: {e}")
                continue
        
        texto_final = "\n".join(texto_completo)
        logger.info(f"[OCR_SURGICAL] ‚úÖ Processadas {len(pages_to_process)} p√°ginas: {len(texto_final)} chars")
        
        return texto_final
        
    except Exception as e:
        logger.error(f"[OCR_SURGICAL] ‚ùå Erro: {e}")
        return ""


def extract_salario_from_contracheque_ocr(texto: str) -> Optional[str]:
    """
    Extrai sal√°rio de texto OCR de contracheque.
    
    Prioridade:
    1. Sal√°rio Base/Sal√°rio Contratual
    2. Maior Remunera√ß√£o
    3. √öltimo sal√°rio no hist√≥rico de altera√ß√µes
    
    Padr√µes espec√≠ficos de contracheque:
    - "Sal√°rio 220,000 1.632,31" (c√≥digo + qtd + valor)
    - "Sal√°rio Base: 1.632,31"
    - "Maior Remunera√ß√£o: 2.160,31"
    - Hist√≥rico: "01/05/2025 2.255,56 2.255,56 Acordo/Convencao"
    """
    import re
    
    if not texto:
        return None
    
    texto_norm = re.sub(r'\s+', ' ', texto).strip()
    texto_norm = re.sub(r'R\s*\$', 'R$', texto_norm)
    texto_norm = re.sub(r',\s+', ',', texto_norm)
    texto_norm = re.sub(r'\.\s+', '.', texto_norm)
    texto_norm = re.sub(r'\s+\.', '.', texto_norm)
    
    valor_pattern = r'([0-9]+(?:[\.][0-9]{3})*[,][0-9]{2})'
    
    patterns_priority = [
        (r'sal[a√°]rio\s*(?:base|contratual)?[:\s]+[0-9,\.]+\s+' + valor_pattern, 'Sal√°rio Base'),
        (r'Sal\.?\s*Contr\.?\s*(?:INSS)?\s+' + valor_pattern, 'Sal. Contr.'),
        (r'maior\s*remunera[√ßc][a√£]o[:\s]+' + valor_pattern, 'Maior Remunera√ß√£o'),
        (r'(?:Total\s*)?Vencimentos[:\s]+' + valor_pattern, 'Total Vencimentos'),
    ]
    
    for pattern, name in patterns_priority:
        match = re.search(pattern, texto_norm, re.IGNORECASE)
        if match:
            valor = match.group(1)
            valor_float = float(valor.replace('.', '').replace(',', '.'))
            if 800 < valor_float < 50000:
                logger.debug(f"[OCR_CONTRA] {name}: R$ {valor}")
                return f"R$ {valor}"
    
    hist_pattern = r'(\d{2}/\d{2}/\d{4})\s+[\d/]+\s+' + valor_pattern + r'\s+' + valor_pattern
    historico = re.findall(hist_pattern, texto_norm)
    
    if historico:
        ultimo = historico[-1]
        valor = ultimo[1]
        valor_float = float(valor.replace('.', '').replace(',', '.'))
        if 800 < valor_float < 50000:
            logger.debug(f"[OCR_CONTRA] Hist√≥rico (√∫ltimo): R$ {valor}")
            return f"R$ {valor}"
    
    return None


def extract_salario_from_annexes(pdf_path: str) -> Optional[str]:
    """
    Extrai sal√°rio dos anexos do PDF (TRCT, contracheques) via OCR CIR√öRGICO.
    
    PLANO BATMAN - Estrat√©gia otimizada (v2):
    1. Mapeia estrutura do PDF para identificar p√°ginas de TRCT/contracheques
    2. Identifica p√°ginas escaneadas (< 200 chars)
    3. Usa salary_candidates que inclui p√°ginas do in√≠cio E do meio
    4. Prioriza fontes: TRCT > Contracheque > Ficha > Candidatos
    5. Se n√£o encontrar, tenta mais p√°ginas em chunks
    
    Returns:
        Sal√°rio no formato "R$ X.XXX,XX" ou None
    """
    from .regex_utils import extract_salario
    
    logger.info(f"[OCR_SURGICAL] Iniciando extra√ß√£o cir√∫rgica de sal√°rio: {pdf_path}")
    log_info("Mapeando anexos para extra√ß√£o cir√∫rgica de sal√°rio", region="OCR_EXTRACTOR")
    
    mapping = map_pdf_annexes(pdf_path)
    
    scanned_pages = set(mapping['scanned'])
    
    trct_scanned = [p for p in mapping['trct'] if p in scanned_pages]
    contracheque_scanned = [p for p in mapping['contracheque'] if p in scanned_pages]
    ficha_scanned = [p for p in mapping['ficha_registro'] if p in scanned_pages]
    ctps_scanned = [p for p in mapping['ctps'] if p in scanned_pages]
    
    pages_to_ocr = []
    source_priority = []
    
    if trct_scanned:
        pages_to_ocr.extend(trct_scanned[:3])
        source_priority.append(f"TRCT({trct_scanned[:3]})")
    if contracheque_scanned:
        pages_to_ocr.extend(contracheque_scanned[:3])
        source_priority.append(f"Contracheque({contracheque_scanned[:3]})")
    if ficha_scanned:
        pages_to_ocr.extend(ficha_scanned[:2])
        source_priority.append(f"Ficha({ficha_scanned[:2]})")
    if ctps_scanned:
        pages_to_ocr.extend(ctps_scanned[:2])
        source_priority.append(f"CTPS({ctps_scanned[:2]})")
    
    if not pages_to_ocr:
        salary_candidates = mapping.get('salary_candidates', [])
        if salary_candidates:
            pages_to_ocr = salary_candidates[:8]
            source_priority.append(f"Candidatos({len(salary_candidates)} total, processando {len(pages_to_ocr)})")
    
    if not pages_to_ocr:
        logger.info("[OCR_SURGICAL] Nenhuma p√°gina candidata identificada")
        return None
    
    pages_to_ocr = list(dict.fromkeys(pages_to_ocr))[:8]
    
    logger.info(f"[OCR_SURGICAL] Prioridade: {' > '.join(source_priority)}")
    log_info(f"OCR cir√∫rgico em {len(pages_to_ocr)} p√°ginas: {source_priority}", region="OCR_EXTRACTOR")
    
    texto_ocr = extract_ocr_from_specific_pages(pdf_path, pages_to_ocr, max_pages=8)
    
    if not texto_ocr:
        return None
    
    salario = extract_salario_from_contracheque_ocr(texto_ocr)
    
    if not salario:
        salario = extract_salario(texto_ocr)
    
    if salario:
        logger.info(f"[OCR_SURGICAL] ‚úÖ Sal√°rio extra√≠do: {salario}")
        log_info(f"Sal√°rio via OCR cir√∫rgico: {salario}", region="OCR_EXTRACTOR")
        return salario
    
    all_scanned = mapping.get('scanned', [])
    remaining = [p for p in all_scanned if p not in pages_to_ocr]
    
    if remaining and len(remaining) >= 3:
        mid_start = len(remaining) // 2
        extra_pages = remaining[mid_start:mid_start+3]
        
        logger.info(f"[OCR_SURGICAL] Tentando chunk adicional: {extra_pages}")
        texto_extra = extract_ocr_from_specific_pages(pdf_path, extra_pages, max_pages=3)
        
        if texto_extra:
            salario = extract_salario_from_contracheque_ocr(texto_extra)
            if not salario:
                salario = extract_salario(texto_extra)
            
            if salario:
                logger.info(f"[OCR_SURGICAL] ‚úÖ Sal√°rio encontrado no chunk adicional: {salario}")
                return salario
    
    logger.info("[OCR_SURGICAL] Sal√°rio n√£o encontrado em nenhuma p√°gina")
    return None


def extract_audiencia_from_mapping(pdf_path: str) -> Optional[Dict[str, str]]:
    """
    Extrai data de audi√™ncia das p√°ginas mapeadas como notifica√ß√µes.
    
    PLANO BATMAN - Estrat√©gia para audi√™ncia:
    1. Mapeia p√°ginas com notifica√ß√£o de audi√™ncia
    2. Extrai texto (nativo ou OCR se necess√°rio)
    3. Aplica regex espec√≠ficos para data/hora de audi√™ncia
    
    Returns:
        Dict com data_audiencia e hora_audiencia, ou None
    """
    import re
    
    logger.info(f"[OCR_SURGICAL] Extraindo audi√™ncia via mapeamento: {pdf_path}")
    
    mapping = map_pdf_annexes(pdf_path)
    
    audiencia_pages = mapping.get('audiencia', [])
    
    if not audiencia_pages:
        logger.info("[OCR_SURGICAL] Nenhuma p√°gina de audi√™ncia identificada no mapeamento")
        return None
    
    from PyPDF2 import PdfReader
    
    try:
        reader = PdfReader(pdf_path)
        
        patterns_data = [
            r'(?:designad[ao]|marcad[ao]|realiz[ao]r)[^0-9]{0,30}(\d{1,2})[/.-](\d{1,2})[/.-](\d{2,4})',
            r'(?:dia|data)[:\s]*(\d{1,2})[/.-](\d{1,2})[/.-](\d{2,4})',
            r'(\d{1,2})\s+de\s+(\w+)\s+de\s+(\d{4})',
            r'comparec\w+[^0-9]{0,30}(\d{1,2})[/.-](\d{1,2})[/.-](\d{2,4})',
        ]
        
        patterns_hora = [
            r'(?:√†s|as|hora)[:\s]*(\d{1,2})[h:](\d{2})',
            r'(\d{1,2})[h:](\d{2})\s*(?:h|hora|min)',
            r'hor√°rio[:\s]*(\d{1,2})[h:](\d{2})',
        ]
        
        meses = {
            'janeiro': '01', 'fevereiro': '02', 'mar√ßo': '03', 'abril': '04',
            'maio': '05', 'junho': '06', 'julho': '07', 'agosto': '08',
            'setembro': '09', 'outubro': '10', 'novembro': '11', 'dezembro': '12'
        }
        
        for page_num in audiencia_pages:
            if page_num > len(reader.pages):
                continue
                
            page = reader.pages[page_num - 1]
            text = page.extract_text() or ""
            
            if len(text.strip()) < 100:
                ocr_text = extract_ocr_from_specific_pages(pdf_path, [page_num], max_pages=1)
                if ocr_text:
                    text = ocr_text
            
            text_lower = text.lower()
            
            data_encontrada = None
            hora_encontrada = None
            
            for pattern in patterns_data:
                match = re.search(pattern, text_lower, re.IGNORECASE)
                if match:
                    groups = match.groups()
                    if len(groups) == 3:
                        dia, mes_ou_nome, ano = groups
                        
                        if mes_ou_nome in meses:
                            mes = meses[mes_ou_nome]
                        else:
                            mes = mes_ou_nome
                        
                        if len(str(ano)) == 2:
                            ano = f"20{ano}"
                        
                        data_encontrada = f"{dia.zfill(2)}/{mes.zfill(2)}/{ano}"
                        break
            
            for pattern in patterns_hora:
                match = re.search(pattern, text_lower, re.IGNORECASE)
                if match:
                    hora, minuto = match.groups()
                    hora_encontrada = f"{hora.zfill(2)}:{minuto}"
                    break
            
            if data_encontrada:
                logger.info(f"[OCR_SURGICAL] ‚úÖ Audi√™ncia encontrada p√°gina {page_num}: {data_encontrada} {hora_encontrada or ''}")
                return {
                    'data_audiencia': data_encontrada,
                    'hora_audiencia': hora_encontrada
                }
        
        logger.info("[OCR_SURGICAL] Audi√™ncia n√£o encontrada nas p√°ginas mapeadas")
        return None
        
    except Exception as e:
        logger.error(f"[OCR_SURGICAL] Erro ao extrair audi√™ncia: {e}")
        return None


def extract_pis_ctps_from_annexes(pdf_path: str) -> Dict[str, Optional[str]]:
    """
    Extrai PIS e CTPS de anexos escaneados (CTPS, TRCT, Ficha de Registro).
    
    PLANO BATMAN - OCR cir√∫rgico para campos de identifica√ß√£o:
    1. Mapeia estrutura do PDF para identificar p√°ginas de CTPS/TRCT/Ficha
    2. Identifica p√°ginas escaneadas (< 200 chars)
    3. Faz OCR apenas nas p√°ginas relevantes
    4. Aplica regex espec√≠ficos para PIS e CTPS
    
    Args:
        pdf_path: Caminho do arquivo PDF
    
    Returns:
        Dict com 'pis' e 'ctps' extra√≠dos via OCR
    """
    import re
    from .regex_utils import extract_pis, extract_ctps
    
    logger.info(f"[OCR_SURGICAL] Iniciando extra√ß√£o de PIS/CTPS dos anexos: {pdf_path}")
    log_info("Mapeando anexos para extra√ß√£o cir√∫rgica de PIS/CTPS", region="OCR_EXTRACTOR")
    
    result = {'pis': None, 'ctps': None}
    
    try:
        mapping = map_pdf_annexes(pdf_path)
        scanned_pages = set(mapping.get('scanned', []))
        
        # P√°ginas priorit√°rias para PIS/CTPS (ordem de prioridade)
        priority_sources = [
            ('trct', mapping.get('trct', []), 3),       # TRCT tem PIS/CTPS
            ('ctps', mapping.get('ctps', []), 3),       # CTPS f√≠sica tem n√∫mero
            ('ficha_registro', mapping.get('ficha_registro', []), 2),  # Ficha tem PIS
        ]
        
        pages_to_ocr = []
        for source_name, pages, max_pages in priority_sources:
            scanned = [p for p in pages if p in scanned_pages]
            if scanned:
                pages_to_ocr.extend(scanned[:max_pages])
                logger.debug(f"[OCR_SURGICAL] {source_name}: {scanned[:max_pages]}")
        
        # Limitar a 8 p√°ginas para performance
        pages_to_ocr = list(dict.fromkeys(pages_to_ocr))[:8]
        
        # üÜï FALLBACK: Se n√£o encontrou p√°ginas mapeadas, usar as √∫ltimas N p√°ginas escaneadas
        # 2025-11-28: Muitos PDFs t√™m anexos no final que n√£o s√£o detectados por keywords
        if not pages_to_ocr and scanned_pages:
            # Ordenar e pegar as √∫ltimas 5 p√°ginas escaneadas
            sorted_scanned = sorted(scanned_pages)
            pages_to_ocr = sorted_scanned[-5:] if len(sorted_scanned) > 5 else sorted_scanned
            logger.info(f"[OCR_SURGICAL] Fallback: usando √∫ltimas {len(pages_to_ocr)} p√°ginas escaneadas: {pages_to_ocr}")
        
        if not pages_to_ocr:
            logger.info("[OCR_SURGICAL] Nenhuma p√°gina escaneada encontrada para OCR")
            return result
        
        logger.info(f"[OCR_SURGICAL] Processando {len(pages_to_ocr)} p√°ginas: {pages_to_ocr}")
        
        # OCR nas p√°ginas selecionadas
        texto_ocr = extract_ocr_from_specific_pages(pdf_path, pages_to_ocr, max_pages=8)
        
        if not texto_ocr or len(texto_ocr.strip()) < 50:
            logger.info("[OCR_SURGICAL] OCR retornou texto insuficiente")
            return result
        
        logger.debug(f"[OCR_SURGICAL] OCR extraiu {len(texto_ocr)} chars")
        
        # Extrair PIS
        pis = extract_pis(texto_ocr)
        if pis:
            result['pis'] = pis
            logger.info(f"[OCR_SURGICAL] ‚úÖ PIS encontrado: {pis}")
        
        # Extrair CTPS
        ctps = extract_ctps(texto_ocr)
        if ctps and ctps != "DIGITAL":  # Ignorar "DIGITAL"
            result['ctps'] = ctps
            logger.info(f"[OCR_SURGICAL] ‚úÖ CTPS encontrado: {ctps}")
        
        # Se n√£o encontrou CTPS com regex padr√£o, tentar padr√µes espec√≠ficos de OCR
        if not result['ctps']:
            # Padr√µes espec√≠ficos para texto OCR (mais tolerantes a erros)
            ocr_ctps_patterns = [
                r'(\d{5,8})\s*[-/]?\s*(\d{3,6})\s*[-/]?\s*([A-Z]{2})',  # 123456-789/RJ
                r'N[¬∞¬∫]?\s*(\d{5,8})',  # N¬∫ 123456
                r'(?:CTPS|Carteira)[^\d]{0,20}(\d{5,8})',  # CTPS ... 123456
            ]
            
            for pattern in ocr_ctps_patterns:
                match = re.search(pattern, texto_ocr, re.I)
                if match:
                    if match.lastindex >= 3:
                        ctps_val = f"{match.group(1)} s√©rie {match.group(2)}/{match.group(3)}"
                    else:
                        ctps_val = match.group(1)
                    
                    result['ctps'] = ctps_val
                    logger.info(f"[OCR_SURGICAL] ‚úÖ CTPS (padr√£o OCR): {ctps_val}")
                    break
        
        return result
        
    except Exception as e:
        logger.error(f"[OCR_SURGICAL] Erro na extra√ß√£o de PIS/CTPS: {e}")
        return result


def extract_fields_with_ocr(pdf_path: str) -> Dict[str, Optional[str]]:
    """
    Extrai campos trabalhistas de PDF escaneado usando OCR + regex.
    
    Args:
        pdf_path: Caminho do arquivo PDF
    
    Returns:
        Dict com campos extra√≠dos via OCR
    """
    log_info(f"Iniciando extra√ß√£o OCR para PDF escaneado: {pdf_path}", region="OCR_EXTRACTOR")
    
    from .regex_utils import (
        extract_pis, extract_ctps, extract_local_trabalho,
        extract_motivo_demissao, extract_empregador,
        extract_data_admissao, extract_data_demissao, extract_salario
    )
    
    # Extrair texto via OCR
    texto_ocr = extract_text_with_ocr(pdf_path)
    
    if not texto_ocr:
        log_error("OCR n√£o conseguiu extrair texto do PDF", region="OCR_EXTRACTOR")
        return {}
    
    # Aplicar regex patterns no texto OCR
    result = {
        'pis': extract_pis(texto_ocr),
        'ctps': extract_ctps(texto_ocr),
        'local_trabalho': extract_local_trabalho(texto_ocr),
        'motivo_demissao': extract_motivo_demissao(texto_ocr),
        'empregador': extract_empregador(texto_ocr),
        'data_admissao': extract_data_admissao(texto_ocr),
        'data_demissao': extract_data_demissao(texto_ocr),
        'salario': extract_salario(texto_ocr)
    }
    
    extracted_count = len([v for v in result.values() if v])
    log_info(f"OCR extraiu {extracted_count} campos", region="OCR_EXTRACTOR")
    
    return result



================================================================================
FILE: extractors/header_parser.py
================================================================================
# extractors/header_parser.py
"""
Parser centralizado para cabe√ßalho de processos judiciais.
Combina informa√ß√µes do filename (ATSum/ATOrd) + conte√∫do PDF + regex robusto.
"""
import re
from typing import Dict, Any, Optional


# Mapeamento comarca ‚Üí UF (expandido para cobrir principais comarcas brasileiras)
COMARCA_UF_MAP = {
    # Rio de Janeiro
    "rio de janeiro": "RJ", "niter√≥i": "RJ", "s√£o gon√ßalo": "RJ", "duque de caxias": "RJ",
    "nova igua√ßu": "RJ", "belford roxo": "RJ", "s√£o jo√£o de meriti": "RJ", "campos dos goytacazes": "RJ",
    "petr√≥polis": "RJ", "volta redonda": "RJ", "maca√©": "RJ", "cabo frio": "RJ",
    "nova friburgo": "RJ", "barra mansa": "RJ", "niter\u00f3i": "RJ", "angra dos reis": "RJ",
    "mesquita": "RJ", "teres√≥polis": "RJ", "mag√©": "RJ", "itabora√≠": "RJ",
    "maric√°": "RJ", "itagua√≠": "RJ", "resende": "RJ", "araruama": "RJ",
    "queimados": "RJ", "s√£o pedro da aldeia": "RJ", "nil√≥polis": "RJ",
    "tr√™s rios": "RJ", "tres rios": "RJ",  # Adicionado para suporte a recurso ordin√°rio
    
    # S√£o Paulo
    "s√£o paulo": "SP", "guarulhos": "SP", "campinas": "SP", "s√£o bernardo do campo": "SP",
    "santo andr√©": "SP", "osasco": "SP", "sorocaba": "SP", "ribeir√£o preto": "SP",
    "santos": "SP", "mau√°": "SP", "s√£o jos√© dos campos": "SP", "diadema": "SP",
    "carapicu√≠ba": "SP", "mogi das cruzes": "SP", "piracicaba": "SP", "bauru": "SP",
    "s√£o vicente": "SP", "itaquaquecetuba": "SP", "jundia√≠": "SP", "franca": "SP",
    "praia grande": "SP", "guaruj√°": "SP", "taubat√©": "SP", "s√£o carlos": "SP",
    "limeira": "SP", "suzano": "SP", "tabo√£o da serra": "SP", "embu das artes": "SP",
    
    # Minas Gerais
    "belo horizonte": "MG", "uberl√¢ndia": "MG", "contagem": "MG", "juiz de fora": "MG",
    "betim": "MG", "montes claros": "MG", "ribeir√£o das neves": "MG", "uberaba": "MG",
    "governador valadares": "MG", "ipatinga": "MG", "sete lagoas": "MG", "divin√≥polis": "MG",
    "santa luzia": "MG", "ibirit√©": "MG", "po√ßos de caldas": "MG", "patos de minas": "MG",
    
    # Outras capitais e grandes cidades
    "salvador": "BA", "fortaleza": "CE", "recife": "PE", "porto alegre": "RS",
    "curitiba": "PR", "bras√≠lia": "DF", "manaus": "AM", "bel√©m": "PA",
    "goi√¢nia": "GO", "s√£o lu√≠s": "MA", "macei√≥": "AL", "natal": "RN",
    "teresina": "PI", "jo√£o pessoa": "PB", "aracaju": "SE", "cuiab√°": "MT",
    "campo grande": "MS", "florian√≥polis": "SC", "vit√≥ria": "ES", "palmas": "TO",
}


def _extract_comarca_from_text(text: str) -> Optional[str]:
    """
    Extrai comarca do cabe√ßalho usando pipeline hier√°rquico de 3 tiers.
    
    TIER 1: Regex autoritativo para frases judiciais can√¥nicas
    TIER 2: Busca de cidades conhecidas pr√≥ximas a palavras-chave judiciais
    TIER 3: (implementar futuramente) Fallback CNJ-based
    """
    # Normaliza√ß√£o: remove underscores, normaliza espa√ßos, pega primeiros 3000 chars
    cabecalho = text[:3000]
    cabecalho_norm = re.sub(r'[_\s]+', ' ', cabecalho)
    
    # ============================================================================
    # TIER 1: Regex autoritativo para frases judiciais can√¥nicas
    # ============================================================================
    
    # Padr√£o 1a: "F√ìRUM TRABALHISTA DE [CIDADE]"
    m = re.search(r'F[O√ìU]R[UO]M\s+(?:TRABALHISTA|CRIMINAL|C[I√ç]VEL)\s+DE\s+([A-Z√Ä√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√†√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+?)(?:\s*[-‚Äì/]\s*[A-Z]{2}|\s*[-‚Äì])', cabecalho_norm, re.IGNORECASE)
    if m:
        comarca = m.group(1).strip()
        return _clean_comarca(comarca)
    
    # Padr√£o 1b: "VARA DO TRABALHO DE/DO [CIDADE]" (cidades compostas espec√≠ficas)
    padroes_vara = [
        (r'VARA\s+DO\s+TRABALHO\s+D[EOA]\s+RIO\s+DE\s+JANEIRO', 'Rio de Janeiro'),
        (r'VARA\s+DO\s+TRABALHO\s+D[EOA]\s+S√ÉO\s+PAULO', 'S√£o Paulo'),
        (r'VARA\s+DO\s+TRABALHO\s+D[EOA]\s+BELO\s+HORIZONTE', 'Belo Horizonte'),
        (r'VARA\s+DO\s+TRABALHO\s+D[EOA]\s+PORTO\s+ALEGRE', 'Porto Alegre'),
    ]
    
    for pattern, cidade_oficial in padroes_vara:
        if re.search(pattern, cabecalho_norm, re.IGNORECASE):
            return cidade_oficial
    
    # Padr√£o 1c: "COMARCA DE [CIDADE]"
    m = re.search(r'COMARCA\s+D[EOA]\s+([A-Z√Ä√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√†√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+?)(?:\s*[-‚Äì,/]\s*[A-Z]{2}|\s*[-‚Äì]|$)', cabecalho_norm, re.IGNORECASE)
    if m:
        comarca = m.group(1).strip()
        return _clean_comarca(comarca)
    
    # ============================================================================
    # TIER 2: Ranking de cidades candidatas por proximidade a keywords judiciais
    # ============================================================================
    # Mapeamento cidade uppercase ‚Üí nome oficial formatado (expandido)
    # Gerado dinamicamente do COMARCA_UF_MAP para consist√™ncia
    CIDADES_CONHECIDAS = {k.upper(): k.title() if ' de ' not in k and ' da ' not in k and ' do ' not in k 
                          else ' '.join(palavra.capitalize() if i == 0 or palavra not in ['de', 'da', 'do', 'das', 'dos'] 
                                      else palavra for i, palavra in enumerate(k.split()))
                          for k in COMARCA_UF_MAP.keys()}
    
    candidatos = []
    cabecalho_upper = cabecalho_norm.upper()
    
    # Busca cada cidade no cabe√ßalho (do maior para o menor nome)
    for cidade_upper, cidade_oficial in sorted(CIDADES_CONHECIDAS.items(), key=lambda x: -len(x[0])):
        idx = cabecalho_upper.find(cidade_upper)
        if idx >= 0:
            # Calcula score baseado em proximidade a palavras judiciais
            contexto_antes = cabecalho_upper[max(0, idx-300):idx]
            contexto_depois = cabecalho_upper[idx+len(cidade_upper):min(len(cabecalho_upper), idx+len(cidade_upper)+50)]
            
            # Palavras judiciais aumentam score
            palavras_judiciais = ['VARA', 'JUIZ', 'JU√çZO', 'TRIBUNAL', 'F√ìRUM', 'FORUM', 'TRABALHO']
            score_judicial = sum(1 for kw in palavras_judiciais if kw in contexto_antes)
            
            # Palavras de endere√ßo diminuem score
            palavras_endereco = [
                'RESIDENTE', 'DOMICILIAD', 'ESCRIT√ìRIO', 'ESCRITORIO',
                'ADVOGADO', 'PROCURADOR', 'ESTABELECID', 'INSCRIT'
            ]
            penalidade = sum(1 for kw in palavras_endereco if kw in contexto_antes)
            
            score_final = score_judicial - penalidade * 2
            
            # Se score √© positivo, √© candidato v√°lido
            if score_final > 0:
                candidatos.append((cidade_oficial, score_final, idx))
    
    # Retorna candidato com maior score (mais prov√°vel de ser comarca)
    if candidatos:
        candidatos.sort(key=lambda x: (-x[1], x[2]))  # Maior score, menor √≠ndice
        return candidatos[0][0]
    
    # ============================================================================
    # TIER 3: Fallback gen√©rico - extrai qualquer cidade ap√≥s palavra judicial
    # ============================================================================
    # Se Tier 1 e 2 falharam, tenta extrair qualquer nome de cidade ap√≥s keywords judiciais
    # Padr√£o permissivo: captura at√© 5 palavras ap√≥s preposi√ß√£o, incluindo preposi√ß√µes internas
    
    # Busca padr√£o muito permissivo: qualquer sequ√™ncia de palavras at√© encontrar sufixo UF ou quebra
    m = re.search(
        r'(?:VARA|JUIZ|JU√çZO|TRIBUNAL|F[√ìO]R[UO]M)\s+(?:[\w\s]{0,40}?)\s+(?:DA|DE|DO)\s+([A-Z√Ä√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][\w√†√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]+?)(?:\s*[-‚Äì/]\s*[A-Z]{2}|\s*RJ|\s*SP|\s*MG|$)',
        cabecalho_norm,
        re.IGNORECASE
    )
    if m:
        cidade = m.group(1).strip()
        # Remove palavras-chave judiciais que podem ter sido capturadas
        cidade = re.sub(r'\b(VARA|TRABALHO|JUSTI√áA|TRIBUNAL|FEDERAL|ESTADUAL|JUIZ|JU√çZO)\b', '', cidade, flags=re.IGNORECASE).strip()
        cidade = re.sub(r'\s+', ' ', cidade).strip()  # Normaliza espa√ßos
        
        # Se sobrou algo e n√£o √© apenas preposi√ß√£o/n√∫mero
        if cidade and len(cidade) > 2 and not re.match(r'^(da|de|do|das|dos|\d+[a¬™¬∫]?)$', cidade, re.IGNORECASE):
            return _clean_comarca(cidade)
    
    # √öltimo recurso: procura por "DE [CIDADE]" nas primeiras linhas
    linhas = cabecalho_norm.split('\n')[:5]
    for linha in linhas:
        if any(kw in linha.upper() for kw in ['VARA', 'JUIZ', 'TRIBUNAL', 'F√ìRUM']):
            # Procura padr√£o simples: preposi√ß√£o + palavras capitalizadas + sufixo UF
            m = re.search(r'\b(?:DE|DO|DA)\s+([A-Z√Ä√Å√Ç√É√â√ä√ç√ì√î√ï√ö√á][\w√†√°√¢√£√©√™√≠√≥√¥√µ√∫√ß\s]{3,40}?)(?:\s*[-‚Äì/]?\s*[A-Z]{2}\b|\s*[-‚Äì]\s|$)', linha)
            if m:
                cidade = m.group(1).strip()
                cidade = re.sub(r'\b(VARA|TRABALHO|JUSTI√áA|TRIBUNAL)\b', '', cidade, flags=re.IGNORECASE).strip()
                cidade = re.sub(r'\s+', ' ', cidade).strip()
                if cidade and len(cidade) > 2:
                    return _clean_comarca(cidade)
    
    return None


def _clean_comarca(comarca: str) -> str:
    """
    Limpa e normaliza nome de comarca:
    - Remove sufixos como "/RJ", "- RJ", "RJ", "- SE"
    - Remove prefixos esp√∫rios como "De " inicial
    - Capitaliza corretamente (mant√©m preposi√ß√µes em min√∫sculo)
    - Remove espa√ßos extras
    """
    # Remove sufixos de UF (incluindo variantes como "- SE", "/RJ", etc.)
    comarca = re.sub(r'\s*[-‚Äì/]\s*[A-Z]{2}\s*$', '', comarca)
    comarca = re.sub(r'\s+[A-Z]{2}\s*$', '', comarca)
    
    # Remove prefixos esp√∫rios como "De " no in√≠cio (comum em falsos positivos)
    comarca = re.sub(r'^\s*De\s+', '', comarca, flags=re.IGNORECASE)
    
    # Normaliza espa√ßos
    comarca = re.sub(r'\s+', ' ', comarca).strip()
    
    # Capitaliza corretamente (mant√©m preposi√ß√µes em min√∫sculo)
    palavras = comarca.split()
    palavras_capitalizadas = []
    
    preposicoes = {'de', 'da', 'do', 'das', 'dos'}
    
    for i, palavra in enumerate(palavras):
        palavra_lower = palavra.lower()
        # Primeira palavra sempre mai√∫scula, preposi√ß√µes sempre min√∫sculas
        if i == 0 or palavra_lower not in preposicoes:
            palavras_capitalizadas.append(palavra_lower.capitalize())
        else:
            palavras_capitalizadas.append(palavra_lower)
    
    return ' '.join(palavras_capitalizadas)


def _extract_numero_orgao_from_text(text: str) -> Optional[str]:
    """Extrai n√∫mero do √≥rg√£o (ex: 71¬™ Vara ‚Üí 71)."""
    cabecalho = text[:3000]
    m = re.search(r'(\d+)[¬™¬∫]?\s*VARA\s+DO\s+TRABALHO', cabecalho, re.IGNORECASE)
    if m:
        return m.group(1)
    return None


def _extract_rito_from_text(text: str) -> Optional[str]:
    """
    Extrai rito do processo (Sumar√≠ssimo, Ordin√°rio, Sum√°rio).
    Prioridade para padr√µes mais espec√≠ficos.
    """
    cabecalho = text[:3000]
    
    # Padr√£o 1: "Rito Sumar√≠ssimo" ou "Sumar√≠ssimo"
    if re.search(r"Rito\s+Sumar√≠[sS]+imo|Sumar√≠[sS]+imo|SUMAR√çSSIMO|procedimento\s+sumar√≠[sS]+imo", cabecalho, re.IGNORECASE):
        return "Sumar√≠ssimo"
    
    # Padr√£o 2: "Rito Ordin√°rio" ou "Ordin√°rio"
    if re.search(r"Rito\s+Ordin[a√°]rio|Ordin[a√°]rio|ORDIN√ÅRIO|A√ß√£o\s+Trabalhista\s+[-‚Äì]\s+Rito\s+Ordin[a√°]rio", cabecalho, re.IGNORECASE):
        return "Ordin√°rio"
    
    # Padr√£o 3: "Rito Sum√°rio" (evitar pegar "Sumar√≠ssimo")
    if re.search(r"Rito\s+Sum[a√°]rio(?!\s*[s√≠])|Sum[a√°]rio(?!\s*[s√≠])|SUM√ÅRIO(?!SSI)", cabecalho, re.IGNORECASE):
        return "Sum√°rio"
    
    return None


def _extract_rito_from_filename(filename: Optional[str]) -> Optional[str]:
    """
    Extrai rito do prefixo do filename:
    - ATSum ‚Üí Sumar√≠ssimo
    - ATOrd ‚Üí Ordin√°rio
    """
    if not filename:
        return None
    
    filename_upper = filename.upper()
    
    if filename_upper.startswith("ATSUM"):
        return "Sumar√≠ssimo"
    elif filename_upper.startswith("ATORD"):
        return "Ordin√°rio"
    
    return None


def _infer_estado_from_comarca(comarca: Optional[str]) -> Optional[str]:
    """Infere UF a partir da comarca usando mapeamento."""
    if not comarca:
        return None
    
    comarca_norm = comarca.lower().strip()
    return COMARCA_UF_MAP.get(comarca_norm)


def parse_header_info(text: str, filename: Optional[str] = None) -> Dict[str, Any]:
    """
    Parser centralizado que retorna {comarca, numero_orgao, rito, estado}.
    Combina informa√ß√µes do filename + conte√∫do do PDF.
    
    Prioridade para RITO:
    1. Filename (ATSum/ATOrd) - mais confi√°vel
    2. Conte√∫do do PDF
    
    Prioridade para ESTADO:
    1. Mapeamento comarca ‚Üí UF
    2. Fallback para extract_estado_sigla()
    """
    result = {}
    
    # 1. Extrai comarca
    comarca = _extract_comarca_from_text(text)
    if comarca:
        result["comarca"] = comarca
    
    # 2. Extrai n√∫mero do √≥rg√£o
    numero_orgao = _extract_numero_orgao_from_text(text)
    if numero_orgao:
        result["numero_orgao"] = numero_orgao
    
    # 3. Extrai rito (filename tem prioridade)
    rito_filename = _extract_rito_from_filename(filename)
    rito_content = _extract_rito_from_text(text)
    
    # Prioriza filename, mas valida com conte√∫do se ambos existirem
    if rito_filename and rito_content:
        # Se ambos concordam, usa
        if rito_filename == rito_content:
            result["rito"] = rito_filename
        else:
            # Filename tem prioridade (conven√ß√£o de nomenclatura oficial)
            result["rito"] = rito_filename
    elif rito_filename:
        result["rito"] = rito_filename
    elif rito_content:
        result["rito"] = rito_content
    
    # 4. Infere estado da comarca
    if comarca:
        estado = _infer_estado_from_comarca(comarca)
        if estado:
            result["estado"] = estado
    
    return result



================================================================================
FILE: extractors/section_detector.py
================================================================================
import re
from typing import List, Dict, Tuple
import logging

logger = logging.getLogger(__name__)

class DocumentSection:
    """Representa uma se√ß√£o de documento dentro de um PDF"""
    def __init__(self, start_pos: int, end_pos: int, text: str, break_type: str):
        self.start_pos = start_pos
        self.end_pos = end_pos
        self.text = text
        self.break_type = break_type  # Tipo de quebra detectada
        
    def __repr__(self):
        return f"DocumentSection(start={self.start_pos}, end={self.end_pos}, type={self.break_type}, len={len(self.text)})"

def detect_document_sections(full_text: str) -> List[DocumentSection]:
    """
    Detecta m√∫ltiplas se√ß√µes/documentos dentro de um √∫nico PDF.
    
    Returns:
        Lista de DocumentSection, cada uma representando um documento separado
    """
    if not full_text or len(full_text.strip()) < 50:
        return [DocumentSection(0, len(full_text), full_text, "documento_unico")]
    
    # Padr√µes que indicam IN√çCIO de novo documento
    section_break_patterns = [
        # Peti√ß√£o Inicial
        (r'\n\s*EXMO\.?\s+SR\.?\s+DR\.?\s+JUIZ', 'peticao_inicial'),
        (r'\n\s*PETI√á√ÉO\s+INICIAL', 'peticao_inicial'),
        
        # Notifica√ß√£o/Intima√ß√£o
        (r'\n\s*INTIMA√á√ÉO', 'notificacao'),
        (r'\n\s*NOTIFICA√á√ÉO', 'notificacao'),
        (r'\n\s*FICA\s+.*\s+INTIMAD[OA]', 'notificacao'),
        
        # Decis√£o/Despacho
        (r'\n\s*DECIS√ÉO\s*(INTERLOCUT√ìRIA)?', 'decisao'),
        (r'\n\s*DESPACHO', 'decisao'),
        (r'\n\s*VISTOS?\.?\s*\n', 'decisao'),
        
        # Senten√ßa
        (r'\n\s*SENTEN√áA', 'sentenca'),
        (r'\n\s*S\s*E\s*N\s*T\s*E\s*N\s*[√áC]\s*A', 'sentenca'),  # Espa√ßado
        
        # Ac√≥rd√£o
        (r'\n\s*AC[O√ì]RD[√ÉA]O', 'acordao'),
        (r'\n\s*TRIBUNAL\s+REGIONAL', 'acordao'),
        
        # Ata de Audi√™ncia
        (r'\n\s*ATA\s+DE\s+AUDI[√äE]NCIA', 'ata_audiencia'),
        (r'\n\s*TERMO\s+DE\s+AUDI[√äE]NCIA', 'ata_audiencia'),
        
        # Manifesta√ß√£o/Contesta√ß√£o
        (r'\n\s*CONTESTA√á√ÉO', 'manifestacao'),
        (r'\n\s*IMPUGNA√á√ÉO', 'manifestacao'),
        (r'\n\s*RESPOSTA\s+[A√Ä]', 'manifestacao'),
        
        # Outros marcadores de novo documento
        (r'\n\s*PROCESSO\s+N[¬∫¬∞]', 'novo_processo'),
        (r'\n\s*--- P√°gina \d+ ---\s*\n\s*EXMO', 'nova_pagina_documento'),
    ]
    
    # Encontrar todas as quebras
    breaks = []
    for pattern, break_type in section_break_patterns:
        for match in re.finditer(pattern, full_text, re.IGNORECASE):
            breaks.append({
                'position': match.start(),
                'type': break_type,
                'match': match.group()
            })
    
    # Ordenar quebras por posi√ß√£o
    breaks.sort(key=lambda x: x['position'])
    
    # Se n√£o encontrou quebras, retornar documento √∫nico
    if not breaks:
        logger.info("[SE√á√ïES] Nenhuma quebra detectada - documento √∫nico")
        return [DocumentSection(0, len(full_text), full_text, "documento_unico")]
    
    # Remover quebras muito pr√≥ximas (dentro de 200 caracteres)
    # Isso evita detectar m√∫ltiplas quebras para o mesmo documento
    filtered_breaks = []
    last_pos = -1000
    for brk in breaks:
        if brk['position'] - last_pos > 200:
            filtered_breaks.append(brk)
            last_pos = brk['position']
    
    breaks = filtered_breaks
    
    # SEMPRE adicionar se√ß√£o inicial em 0 se houver quebras E primeira quebra n√£o est√° em 0
    # Isso garante que headers/metadata no in√≠cio n√£o sejam perdidos
    if breaks and breaks[0]['position'] > 0:
        breaks.insert(0, {
            'position': 0,
            'type': 'inicio_documento',
            'match': ''
        })
    
    # Criar se√ß√µes baseadas nas quebras
    sections = []
    for i in range(len(breaks)):
        start_pos = breaks[i]['position']
        end_pos = breaks[i + 1]['position'] if i + 1 < len(breaks) else len(full_text)
        section_text = full_text[start_pos:end_pos].strip()
        
        # SEMPRE preservar primeira se√ß√£o (pode conter headers importantes)
        # Para outras se√ß√µes, exigir conte√∫do significativo (>100 chars)
        if start_pos == 0 or len(section_text) > 100:
            section = DocumentSection(
                start_pos=start_pos,
                end_pos=end_pos,
                text=section_text,
                break_type=breaks[i]['type']
            )
            sections.append(section)
            logger.info(f"[SE√á√ïES] Se√ß√£o {i+1}: {breaks[i]['type']} ({len(section_text)} chars)")
    
    # Se n√£o criou se√ß√µes v√°lidas, retornar documento √∫nico
    if not sections:
        logger.info("[SE√á√ïES] Nenhuma se√ß√£o v√°lida - retornando documento √∫nico")
        return [DocumentSection(0, len(full_text), full_text, "documento_unico")]
    
    logger.info(f"[SE√á√ïES] Total de {len(sections)} se√ß√µes detectadas")
    return sections

def merge_section_results(section_results: List[Dict]) -> Dict:
    """
    Mescla resultados de m√∫ltiplas se√ß√µes de forma inteligente.
    
    Estrat√©gia de mesclagem:
    1. Campos b√°sicos (CNJ, n√∫mero processo): usa o primeiro encontrado
    2. Campos de localiza√ß√£o (vara, comarca): usa o mais completo
    3. Campos de partes: combina todos (autor, r√©u)
    4. Campos de eventos: mant√©m o mais recente (audi√™ncia, decis√£o)
    5. Prazos: mant√©m o mais pr√≥ximo/urgente
    """
    if not section_results:
        return {}
    
    if len(section_results) == 1:
        return section_results[0]
    
    logger.info(f"[MESCLAGEM] Mesclando {len(section_results)} se√ß√µes")
    
    merged = {}
    
    # 1. Campos b√°sicos - primeiro valor encontrado
    basic_fields = ['numero_processo', 'cnj', 'tipo_processo', 'sistema_eletronico', 
                    'area_direito', 'sub_area_direito', 'npc', 'instancia']
    for field in basic_fields:
        for result in section_results:
            if result.get(field) and str(result[field]).strip():
                merged[field] = result[field]
                break
    
    # 2. Campos de localiza√ß√£o - valor mais completo (maior)
    location_fields = ['estado', 'comarca', 'foro', 'vara', 'celula', 'origem', 'orgao', 'numero_orgao']
    for field in location_fields:
        values = [r.get(field, '') for r in section_results if r.get(field) and str(r[field]).strip()]
        if values:
            # Pega o valor mais longo (geralmente mais completo)
            merged[field] = max(values, key=len)
    
    # 3. Campos de partes - combinar (pode haver m√∫ltiplas partes)
    party_fields = ['cliente', 'parte', 'cliente_parte', 'autor', 'reu', 'advogado_autor', 'advogado_reu']
    for field in party_fields:
        values = [r.get(field, '') for r in section_results if r.get(field) and str(r[field]).strip()]
        if values:
            # Remove duplicatas mantendo ordem
            unique_values = []
            seen = set()
            for v in values:
                v_lower = str(v).lower().strip()
                if v_lower not in seen:
                    unique_values.append(v)
                    seen.add(v_lower)
            # Se m√∫ltiplos valores, combina com v√≠rgula
            merged[field] = unique_values[0] if len(unique_values) == 1 else ', '.join(unique_values[:3])
    
    # 4. Campos de eventos - √∫ltimo/mais recente (ordem das se√ß√µes)
    event_fields = ['decisao_tipo', 'decisao_resultado', 'decisao_fundamentacao_resumida',
                    'audiencia_inicial', 'resultado_audiencia', 'prazos_derivados_audiencia']
    for field in event_fields:
        # Percorre de tr√°s pra frente (√∫ltimo tem prioridade)
        for result in reversed(section_results):
            if result.get(field) and str(result[field]).strip():
                merged[field] = result[field]
                break
    
    # 5. Prazos - mant√©m o mais urgente (menor data futura)
    if any(r.get('prazo') for r in section_results):
        prazos = [r.get('prazo') for r in section_results if r.get('prazo')]
        if prazos:
            # Por simplicidade, pega o primeiro prazo encontrado
            # Em produ√ß√£o, deveria comparar datas e pegar o mais pr√≥ximo
            merged['prazo'] = prazos[0]
    
    # 6. Tipo de notifica√ß√£o
    for result in section_results:
        if result.get('tipo_notificacao') and str(result['tipo_notificacao']).strip():
            merged['tipo_notificacao'] = result['tipo_notificacao']
            break
    
    # 7. Assunto/Objeto - valor mais completo
    for field in ['assunto', 'objeto', 'sub_objeto']:
        values = [r.get(field, '') for r in section_results if r.get(field) and str(r[field]).strip()]
        if values:
            merged[field] = max(values, key=len)
    
    # 8. Informa√ß√µes de classifica√ß√£o - √∫ltima se√ß√£o
    if section_results[-1].get('document_type'):
        merged['document_type'] = section_results[-1]['document_type']
        merged['document_type_confidence'] = section_results[-1].get('document_type_confidence', 0)
        # Adicionar flag indicando que √© multi-documento
        merged['multi_document'] = True
        merged['num_sections'] = len(section_results)
    
    logger.info(f"[MESCLAGEM] Resultado mesclado: {list(merged.keys())}")
    return merged



================================================================================
FILE: extractors/document_classifier.py
================================================================================
from enum import Enum
import re
from typing import Tuple, Optional

class DocumentType(Enum):
    PETICAO_INICIAL = "Peti√ß√£o Inicial"
    NOTIFICACAO = "Notifica√ß√£o/Intima√ß√£o"
    DECISAO_INTERLOCUTORIA = "Decis√£o Interlocut√≥ria"
    SENTENCA = "Senten√ßa"
    ACORDAO = "Ac√≥rd√£o"
    ATA_AUDIENCIA = "Ata de Audi√™ncia"
    MANIFESTACAO = "Manifesta√ß√£o/Contesta√ß√£o"
    OUTROS = "Outros"

# Mapeamento: tipo de documento ‚Üí lista de extractors que devem ser executados
DOCUMENT_TYPE_EXTRACTORS = {
    DocumentType.PETICAO_INICIAL: [
        'parse_numero_processo_cnj',
        'parse_numero_processo_antigo',
        'parse_autor',
        'parse_reu', 
        'parse_advogado_autor',
        'parse_advogado_reu',
        'parse_vara',
        'parse_celula',
        'parse_orgao',
        'parse_comarca',
        'parse_uf',
        'parse_id_interno_hilo'
    ],
    DocumentType.NOTIFICACAO: [
        'parse_numero_processo_cnj',
        'parse_numero_processo_antigo',
        'parse_autor',
        'parse_reu',
        'parse_prazo',
        'parse_tipo_notificacao',
        'parse_prazos_derivados',
        'parse_vara',
        'parse_celula',
        'parse_orgao',
        'parse_comarca',
        'parse_uf',
        'parse_id_interno_hilo'
    ],
    DocumentType.DECISAO_INTERLOCUTORIA: [
        'parse_numero_processo_cnj',
        'parse_numero_processo_antigo',
        'parse_autor',
        'parse_reu',
        'parse_decisao_tipo',
        'parse_decisao_resultado',
        'parse_vara',
        'parse_celula',
        'parse_orgao',
        'parse_comarca',
        'parse_uf',
        'parse_fundamentacao_resumida',
        'parse_id_interno_hilo'
    ],
    DocumentType.SENTENCA: [
        'parse_numero_processo_cnj',
        'parse_numero_processo_antigo',
        'parse_autor',
        'parse_reu',
        'parse_decisao_tipo',
        'parse_decisao_resultado',
        'parse_vara',
        'parse_celula',
        'parse_orgao',
        'parse_comarca',
        'parse_uf',
        'parse_fundamentacao_resumida',
        'parse_id_interno_hilo'
    ],
    DocumentType.ACORDAO: [
        'parse_numero_processo_cnj',
        'parse_numero_processo_antigo',
        'parse_autor',
        'parse_reu',
        'parse_decisao_tipo',
        'parse_decisao_resultado',
        'parse_vara',
        'parse_celula',
        'parse_orgao',
        'parse_comarca',
        'parse_uf',
        'parse_fundamentacao_resumida',
        'parse_id_interno_hilo'
    ],
    DocumentType.ATA_AUDIENCIA: [
        'parse_numero_processo_cnj',
        'parse_numero_processo_antigo',
        'parse_autor',
        'parse_reu',
        'parse_audiencia_inicial',
        'parse_resultado_audiencia',
        'parse_vara',
        'parse_celula',
        'parse_orgao',
        'parse_comarca',
        'parse_uf',
        'parse_id_interno_hilo'
    ],
    DocumentType.MANIFESTACAO: [
        'parse_numero_processo_cnj',
        'parse_numero_processo_antigo',
        'parse_autor',
        'parse_reu',
        'parse_vara',
        'parse_celula',
        'parse_orgao',
        'parse_comarca',
        'parse_uf',
        'parse_id_interno_hilo'
    ],
    DocumentType.OUTROS: [
        'parse_numero_processo_cnj',
        'parse_numero_processo_antigo',
        'parse_autor',
        'parse_reu',
        'parse_vara',
        'parse_celula',
        'parse_orgao',
        'parse_comarca',
        'parse_uf',
        'parse_id_interno_hilo'
    ]
}

def classify_document(text: str) -> Tuple[DocumentType, float]:
    """
    Classifica o tipo de documento jur√≠dico baseado em heur√≠sticas.
    
    Returns:
        Tuple[DocumentType, float]: (tipo_documento, confian√ßa 0-1)
    """
    if not text:
        return DocumentType.OUTROS, 0.0
    
    text_lower = text.lower()
    text_sample = text[:3000]  # Primeiras 3000 chars para an√°lise
    
    # Heur√≠sticas por ordem de especificidade
    
    # 1. Ata de Audi√™ncia - muito espec√≠fica
    ata_patterns = [
        r'ata\s+de\s+audi[e√™]ncia',
        r'termo\s+de\s+audi[e√™]ncia',
        r'aos?\s+\d+\s+dias?\s+de\s+\w+.*realizou-se\s+audi[e√™]ncia',
        r'audi[e√™]ncia\s+.*\s+realizada'
    ]
    if any(re.search(pattern, text_lower[:1000]) for pattern in ata_patterns):
        return DocumentType.ATA_AUDIENCIA, 0.95
    
    # 2. Ac√≥rd√£o - detectar antes de senten√ßa
    acordao_patterns = [
        r'ac[o√≥]rd[a√£]o',
        r'tribunal\s+(regional|de\s+justi[c√ß]a)',
        r'relatora?:',
        r'vistos?,?\s+relatados?\s+e\s+discutidos?'
    ]
    acordao_count = sum(1 for p in acordao_patterns if re.search(p, text_lower[:2000]))
    if acordao_count >= 2:
        return DocumentType.ACORDAO, 0.9
    
    # 3. Senten√ßa - muito espec√≠fica
    sentenca_patterns = [
        r'senten[c√ß]a',
        r'julgo\s+(im)?procedente',
        r'ante\s+o\s+exposto.*julgo',
        r'dispositivo:?\s*julgo'
    ]
    sentenca_count = sum(1 for p in sentenca_patterns if re.search(p, text_lower[:2000]))
    if sentenca_count >= 2:
        return DocumentType.SENTENCA, 0.9
    
    # 4. Decis√£o Interlocut√≥ria
    decisao_patterns = [
        r'decis[a√£]o\s+interlocut[o√≥]ria',
        r'(indefiro|defiro)(?!\s+(o\s+)?pedido\s+de)',  # defiro/indefiro mas n√£o "o pedido de"
        r'julgo\s+extinto',
        r'determino\s+a\s+(cita[c√ß][a√£]o|intima[c√ß][a√£]o)',
        r'vistos?\.?\s+(indefiro|defiro|determino)'
    ]
    decisao_count = sum(1 for p in decisao_patterns if re.search(p, text_lower[:2000]))
    if decisao_count >= 1:
        return DocumentType.DECISAO_INTERLOCUTORIA, 0.85
    
    # 5. Notifica√ß√£o/Intima√ß√£o
    notificacao_patterns = [
        r'intima[c√ß][a√£]o',
        r'notifica[c√ß][a√£]o',
        r'fica\s+(v\.?\s*s\.?a?\.?|vossa\s+excel[e√™]ncia|a\s+parte)\s+intimad[ao]',
        r'prazo\s+de\s+\d+\s+dias',
        r'cientificad[ao]'
    ]
    notif_count = sum(1 for p in notificacao_patterns if re.search(p, text_lower[:1500]))
    if notif_count >= 2:
        return DocumentType.NOTIFICACAO, 0.85
    
    # 6. Manifesta√ß√£o/Contesta√ß√£o
    manifestacao_patterns = [
        r'contesta[c√ß][a√£]o',
        r'impugna[c√ß][a√£]o',
        r'resposta\s+[a√†]\s+(inicial|peti[c√ß][a√£]o)',
        r'defesa\s+(pr[√©e]via)?',
        r'vem\s+.*\s+apresentar\s+(contesta[c√ß][a√£]o|impugna[c√ß][a√£]o)'
    ]
    if any(re.search(pattern, text_lower[:1500]) for pattern in manifestacao_patterns):
        return DocumentType.MANIFESTACAO, 0.8
    
    # 7. Peti√ß√£o Inicial - menos espec√≠fica, verificar por √∫ltimo
    peticao_patterns = [
        r'peti[c√ß][a√£]o\s+inicial',
        r'exmo\.?\s+sr\.?\s+dr\.?\s+juiz',
        r'vem\s+.*\s+perante\s+v\.?\s*s\.?a?\.?',
        r'da\s+causa\s+de\s+pedir',
        r'dos\s+fatos',
        r'requer\s+a\s+cita[c√ß][a√£]o',
        # Padr√µes espec√≠ficos por √°rea do direito
        # Trabalhista
        r'reclama[c√ß][a√£]o\s+trabalhista',
        r'reclamante\s*:',
        r'reclamad[ao]\s*:',
        # C√≠vel
        r'a[c√ß][a√£]o\s+(de\s+)?(cobran[c√ß]a|indeniza[c√ß][a√£]o|rescis[a√£]o|despejo)',
        r'autor(?:a)?\s*:.*r[√©e]u',
        # Execu√ß√£o
        r'execu[c√ß][a√£]o\s+(fiscal|de\s+t[i√≠]tulo)',
        r'exequente\s*:',
        r'executad[ao]\s*:',
        # Criminal
        r'den[u√∫]ncia\s+(criminal)?',
        r'minist[√©e]rio\s+p[u√∫]blico\s*:',
        r'acusad[ao]\s*:',
    ]
    peticao_count = sum(1 for p in peticao_patterns if re.search(p, text_lower[:2000]))
    
    # Se tem padr√µes de peti√ß√£o E n√£o tem padr√µes fortes de outros tipos
    if peticao_count >= 2:
        return DocumentType.PETICAO_INICIAL, 0.75
    
    # 8. Fallback - se n√£o classificou, √© OUTROS
    return DocumentType.OUTROS, 0.5


def get_extractors_for_type(doc_type: DocumentType) -> list:
    """
    Retorna lista de extractors que devem ser executados para este tipo de documento.
    """
    return DOCUMENT_TYPE_EXTRACTORS.get(doc_type, DOCUMENT_TYPE_EXTRACTORS[DocumentType.OUTROS])



================================================================================
FILE: extractors/posicao_mapping.py
================================================================================
"""
Mapeamento de posi√ß√µes da parte interessada para o eLaw.
Baseado no dropdown real do sistema eLaw com 61 op√ß√µes.
"""

import re
from typing import Optional, Dict
from rapidfuzz import fuzz
import unicodedata

# Mapeamento completo ID -> LABEL do dropdown do eLaw
ELAW_POSICOES = {
    "1": "AUTOR",
    "2": "REU",
    "3": "TERCEIRO INTERESSADO",
    "4": "ADVOGADO",
    "5": "AGRAVANTE",
    "6": "AGRAVADO",
    "7": "APELADO",
    "8": "APELANTE",
    "9": "AUTUANTE",
    "10": "AUTUADO",
    "11": "ALIMENTANTE",
    "12": "BENEFICI√ÅRIO",
    "13": "CONFINANTE",
    "14": "REQUENTE",
    "15": "CONSIGNANTE",
    "16": "CONSIGNADOV",
    "17": "CREDOR",
    "18": "DEVEDOR",
    "19": "DEMANDANTE",
    "20": "DEMANDADO",
    "21": "DENUNCIANTE",
    "22": "DENUNCIADO",
    "23": "DEPRECANTE",
    "24": "DEPRECADO",
    "25": "EMBARGANTE",
    "26": "EMBARGADO",
    "27": "EXCIPIENTE",
    "28": "EXCEPTO",
    "29": "EXEQUENTE",
    "30": "EXECUTADO",
    "31": "FAL√äNCIA",
    "32": "HABTE",
    "33": "HABILITANTE",
    "34": "HABILITADA",
    "35": "IMPETRANTE",
    "36": "IMPETTRADO",
    "37": "IMPUGNANTE",
    "38": "IMPUGNADO",
    "39": "INTERPELANTE",
    "40": "INTERPELADO",
    "41": "INVENT",
    "42": "REQT",
    "43": "INVENTARIANTE",
    "44": "INVENTARIADO",
    "45": "INTERDITANTE",
    "46": "INTERDITADO",
    "47": "NOTIFICANTE",
    "48": "NOTIFICADO",
    "49": "OPOENTE",
    "50": "OPOSTO",
    "51": "RECLAMANTE",
    "52": "RECLAMADO",
    "53": "RECOVINTE",
    "54": "RECOVINDO",
    "55": "RECORRENTE",
    "56": "RECORRIDO",
    "57": "REQUERENTE",
    "58": "REQUERIDO",
    "59": "SUSCITANTE",
    "60": "SUSCITADO",
    "63": "PARTES",
}

# Mapeamento reverso LABEL -> ID para busca r√°pida
LABEL_TO_ID = {label: id_val for id_val, label in ELAW_POSICOES.items()}

# Sin√¥nimos e varia√ß√µes comuns separados por contexto
# IMPORTANTE: Abrevia√ß√µes amb√≠guas (RTE, RDO, RDA) variam por contexto processual

SINONIMOS_TRABALHISTA = {
    # Trabalhistas (a√ß√µes iniciais)
    "RECLAMANTE": "RECLAMANTE",
    "RECLAMADO": "RECLAMADO",
    "RECLAMADA": "RECLAMADO",
    "RTE": "RECLAMANTE",  # Abrevia√ß√£o trabalhista
    "RDO": "RECLAMADO",   # Abrevia√ß√£o trabalhista
    "RDA": "RECLAMADO",   # Abrevia√ß√£o trabalhista
}

SINONIMOS_RECURSOS = {
    # Recursos trabalhistas e c√≠veis
    "RECORRENTE": "RECORRENTE",
    "RECORRIDO": "RECORRIDO",
    "RECORRIDA": "RECORRIDO",
    "RTE": "RECORRENTE",  # Abrevia√ß√£o em recursos
    "RDO": "RECORRIDO",   # Abrevia√ß√£o em recursos
    "RDA": "RECORRIDO",   # Abrevia√ß√£o em recursos
    
    # Apela√ß√µes
    "APELANTE": "APELANTE",
    "APELADO": "APELADO",
    "APELADA": "APELADO",
    
    # Agravos
    "AGRAVANTE": "AGRAVANTE",
    "AGRAVADO": "AGRAVADO",
    "AGRAVADA": "AGRAVADO",
    
    # Embargos
    "EMBARGANTE": "EMBARGANTE",
    "EMBARGADO": "EMBARGADO",
    "EMBARGADA": "EMBARGADO",
}

SINONIMOS_CIVEIS = {
    # C√≠veis (a√ß√µes iniciais)
    "AUTOR": "AUTOR",
    "AUTORA": "AUTOR",
    "REU": "REU",
    "RE": "REU",
    "R√â": "REU",
    "R√âU": "REU",
    
    # Requerimentos
    "REQUERENTE": "REQUERENTE",
    "REQUERIDO": "REQUERIDO",
    "REQUERIDA": "REQUERIDO",
    
    # Outros c√≠veis
    "DEMANDANTE": "DEMANDANTE",
    "DEMANDADO": "DEMANDADO",
    "DEMANDADA": "DEMANDADO",
}

SINONIMOS_EXECUCAO = {
    # Execu√ß√£o
    "EXEQUENTE": "EXEQUENTE",
    "EXECUTADO": "EXECUTADO",
    "EXECUTADA": "EXECUTADO",
}

SINONIMOS_OUTROS = {
    # Mandado de Seguran√ßa
    "IMPETRANTE": "IMPETRANTE",
    "IMPETRADO": "IMPETTRADO",
    "IMPETTRADO": "IMPETTRADO",
    
    # Den√∫ncias
    "DENUNCIANTE": "DENUNCIANTE",
    "DENUNCIADO": "DENUNCIADO",
    "DENUNCIADA": "DENUNCIADO",
}

# Dicion√°rio consolidado para busca r√°pida (sem abrevia√ß√µes amb√≠guas)
# Usado como fallback quando contexto n√£o √© especificado
SINONIMOS_POSICAO = {
    # Trabalhistas (PRIORIDADE - maior volume)
    "RECLAMANTE": "RECLAMANTE",
    "RECLAMADO": "RECLAMADO",
    "RECLAMADA": "RECLAMADO",
    
    # Recursos
    "RECORRENTE": "RECORRENTE",
    "RECORRIDO": "RECORRIDO",
    "RECORRIDA": "RECORRIDO",
    
    # C√≠veis
    "AUTOR": "AUTOR",
    "AUTORA": "AUTOR",
    "REU": "REU",
    "RE": "REU",
    "R√â": "REU",
    "R√âU": "REU",
    
    # Apela√ß√µes
    "APELANTE": "APELANTE",
    "APELADO": "APELADO",
    "APELADA": "APELADO",
    
    # Agravos
    "AGRAVANTE": "AGRAVANTE",
    "AGRAVADO": "AGRAVADO",
    "AGRAVADA": "AGRAVADO",
    
    # Embargos
    "EMBARGANTE": "EMBARGANTE",
    "EMBARGADO": "EMBARGADO",
    "EMBARGADA": "EMBARGADO",
    
    # Execu√ß√£o
    "EXEQUENTE": "EXEQUENTE",
    "EXECUTADO": "EXECUTADO",
    "EXECUTADA": "EXECUTADO",
    
    # Mandado de Seguran√ßa
    "IMPETRANTE": "IMPETRANTE",
    "IMPETRADO": "IMPETTRADO",
    "IMPETTRADO": "IMPETTRADO",
    
    # Requerimentos
    "REQUERENTE": "REQUERENTE",
    "REQUERIDO": "REQUERIDO",
    "REQUERIDA": "REQUERIDO",
    
    # Outros
    "DEMANDANTE": "DEMANDANTE",
    "DEMANDADO": "DEMANDADO",
    "DEMANDADA": "DEMANDADO",
    "DENUNCIANTE": "DENUNCIANTE",
    "DENUNCIADO": "DENUNCIADO",
    "DENUNCIADA": "DENUNCIADO",
}


def _normalizar(texto: str) -> str:
    """Remove acentos, uppercase, remove espa√ßos extras."""
    if not texto:
        return ""
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto)
    texto = ''.join([c for c in texto if not unicodedata.combining(c)])
    # Uppercase e remove espa√ßos
    return re.sub(r'\s+', ' ', texto.upper().strip())


def resolve_posicao(posicao: str, contexto: str = "trabalhista") -> str:
    """
    Resolve uma posi√ß√£o considerando o contexto processual.
    IMPORTANTE: Use esta fun√ß√£o quando tiver informa√ß√£o de contexto.
    
    Args:
        posicao: Posi√ß√£o extra√≠da do PDF ou abrevia√ß√£o (ex: "RTE", "RECLAMANTE")
        contexto: Contexto processual - "trabalhista" (padr√£o), "recursos", "civeis", "execucao", "outros"
    
    Returns:
        Label oficial do eLaw normalizado por contexto
    
    Examples:
        >>> resolve_posicao("RTE", "trabalhista")
        "RECLAMANTE"
        >>> resolve_posicao("RTE", "recursos")
        "RECORRENTE"
    """
    if not posicao:
        return ""
    
    posicao_norm = _normalizar(posicao)
    
    # Seleciona o dicion√°rio de sin√¥nimos baseado no contexto
    contexto_map = {
        "trabalhista": SINONIMOS_TRABALHISTA,
        "recursos": SINONIMOS_RECURSOS,
        "civeis": SINONIMOS_CIVEIS,
        "execucao": SINONIMOS_EXECUCAO,
        "outros": SINONIMOS_OUTROS,
    }
    
    sinonimos = contexto_map.get(contexto.lower(), SINONIMOS_TRABALHISTA)
    
    # 1. Busca exata no sin√¥nimos do contexto
    if posicao_norm in sinonimos:
        return sinonimos[posicao_norm]
    
    # 2. Busca exata nos labels oficiais
    if posicao_norm in LABEL_TO_ID:
        return posicao_norm
    
    # 3. Fuzzy matching
    best_match = find_posicao_fuzzy(posicao_norm, threshold=85)
    if best_match:
        return best_match
    
    # 4. Fallback
    return posicao_norm


def normalize_posicao(posicao: str, contexto: Optional[str] = None) -> str:
    """
    Normaliza uma posi√ß√£o encontrada no PDF para o label oficial do eLaw.
    
    Args:
        posicao: Posi√ß√£o extra√≠da do PDF (ex: "RECLAMANTE", "Reclamado", "Apelante")
        contexto: (Opcional) Contexto processual para desambiguar abrevia√ß√µes
    
    Returns:
        Label oficial do eLaw (ex: "RECLAMANTE", "RECLAMADO", "APELANTE")
    
    Note:
        Se contexto n√£o for fornecido, assume trabalhista (maior volume de casos).
        Para abrevia√ß√µes amb√≠guas (RTE, RDO), use resolve_posicao() com contexto expl√≠cito.
    """
    if not posicao:
        return ""
    
    # Se contexto foi fornecido, usa resolve_posicao
    if contexto:
        return resolve_posicao(posicao, contexto)
    
    posicao_norm = _normalizar(posicao)
    
    # 1. Busca exata no sin√¥nimos (sem abrevia√ß√µes amb√≠guas)
    if posicao_norm in SINONIMOS_POSICAO:
        return SINONIMOS_POSICAO[posicao_norm]
    
    # 2. Busca exata nos labels oficiais
    if posicao_norm in LABEL_TO_ID:
        return posicao_norm
    
    # 3. Se for abrevia√ß√£o amb√≠gua, assume trabalhista e emite warning
    if posicao_norm in ["RTE", "RDO", "RDA"]:
        import logging
        logging.warning(f"[POSICAO] Abrevia√ß√£o amb√≠gua '{posicao_norm}' sem contexto - assumindo trabalhista. Use resolve_posicao() com contexto expl√≠cito.")
        return resolve_posicao(posicao, "trabalhista")
    
    # 4. Fuzzy matching com labels oficiais
    best_match = find_posicao_fuzzy(posicao_norm, threshold=85)
    if best_match:
        return best_match
    
    # 5. Fallback: retorna normalizado
    return posicao_norm


def find_posicao_fuzzy(posicao: str, threshold: int = 85) -> Optional[str]:
    """
    Busca a posi√ß√£o mais pr√≥xima usando fuzzy matching.
    
    Args:
        posicao: Posi√ß√£o a buscar
        threshold: Threshold de similaridade (0-100)
    
    Returns:
        Label oficial do eLaw ou None se n√£o encontrou
    """
    if not posicao:
        return None
    
    posicao_norm = _normalizar(posicao)
    best_score = 0
    best_label = None
    
    # Busca nos labels oficiais
    for label in LABEL_TO_ID.keys():
        score = fuzz.ratio(posicao_norm, label)
        if score > best_score:
            best_score = score
            best_label = label
    
    if best_score >= threshold:
        return best_label
    
    return None


def get_posicao_id(posicao: str) -> Optional[str]:
    """
    Retorna o ID do eLaw para uma posi√ß√£o.
    
    Args:
        posicao: Posi√ß√£o (pode ser label ou termo do PDF)
    
    Returns:
        ID do eLaw (ex: "51" para RECLAMANTE) ou None
    """
    if not posicao:
        return None
    
    # Normaliza primeiro
    label_oficial = normalize_posicao(posicao)
    
    # Busca o ID
    return LABEL_TO_ID.get(label_oficial)


def get_posicao_label(id_elaw: str) -> Optional[str]:
    """
    Retorna o label oficial do eLaw para um ID.
    
    Args:
        id_elaw: ID do eLaw (ex: "51")
    
    Returns:
        Label oficial (ex: "RECLAMANTE") ou None
    """
    return ELAW_POSICOES.get(str(id_elaw))


def get_all_posicoes() -> Dict[str, str]:
    """Retorna todas as posi√ß√µes dispon√≠veis (ID -> LABEL)."""
    return ELAW_POSICOES.copy()


def get_posicoes_trabalhistas() -> Dict[str, str]:
    """Retorna apenas as posi√ß√µes mais comuns em processos trabalhistas."""
    trabalhistas = {
        "51": "RECLAMANTE",
        "52": "RECLAMADO",
        "55": "RECORRENTE",
        "56": "RECORRIDO",
        "8": "APELANTE",
        "7": "APELADO",
        "25": "EMBARGANTE",
        "26": "EMBARGADO",
    }
    return trabalhistas


# Testes r√°pidos
if __name__ == "__main__":
    print("=== TESTES DE NORMALIZA√á√ÉO DE POSI√á√ïES ===\n")
    
    testes = [
        "RECLAMANTE",
        "Reclamado",
        "RECORRENTE",
        "Recorrido",
        "APELANTE",
        "Apelado",
        "AUTOR",
        "REU",
        "R√â",
        "EMBARGANTE",
        "Executado",
        "IMPETRANTE",
        "Requerente",
    ]
    
    for termo in testes:
        label = normalize_posicao(termo)
        id_elaw = get_posicao_id(termo)
        print(f"{termo:20s} -> Label: {label:20s} | ID eLaw: {id_elaw or 'N/A'}")
    
    print("\n=== BUSCA FUZZY ===\n")
    fuzzy_testes = [
        "RECLAMNTE",  # erro de digita√ß√£o
        "REQUERIDO",
        "APELADA",  # varia√ß√£o feminina
        "AGRAVADO",
    ]
    
    for termo in fuzzy_testes:
        label = normalize_posicao(termo)
        id_elaw = get_posicao_id(termo)
        print(f"{termo:20s} -> Label: {label:20s} | ID eLaw: {id_elaw or 'N/A'}")



================================================================================
FILE: extractors/client_priority.py
================================================================================
"""
Configura√ß√£o de prioridade de PARTES INTERESSADAS para casos onde m√∫ltiplas empresas
do mesmo grupo aparecem no polo reclamado.

IMPORTANTE: Este m√≥dulo trabalha com PARTES INTERESSADAS, n√£o com clientes diferentes.

Exemplo:
  Cliente: CSN (√∫nico)
    ‚îî‚îÄ‚îÄ Partes Interessadas: CBSI, CSN, CSN MINERA√á√ÉO, etc.
    
Quando um processo tem m√∫ltiplas partes do mesmo grupo (ex: CBSI + CSN MINERA√á√ÉO),
este m√≥dulo determina qual deve ser a parte principal (campo parte_interessada)
e qual deve ir para o campo outra_reclamada_cliente.

Regra: CBSI tem prioridade sobre outras partes do grupo CSN.
"""

from typing import List, Dict, Tuple, Optional

# Ordem de prioridade de PARTES INTERESSADAS (do maior para o menor)
# Esta lista define qual parte deve ser a principal quando m√∫ltiplas aparecem no processo
PARTE_PRIORITY_ORDER = [
    # === GRUPO CSN ===
    # Prioridade 1: CBSI (maior prioridade dentro do grupo CSN)
    "CBSI",
    
    # Prioridade 2: CSN Sider√∫rgica Nacional
    "CSN ‚Äì COMPANHIA SIDERURGICA NACIONAL",
    "CSN",
    
    # Prioridade 3: Outras empresas do grupo CSN
    "CSN CIMENTOS BRASIL S/A",
    "CSN MINERA√á√ÉO S.A.",
    "COMPANHIA METALURGICA PRADA",
    "SEPETIBA TECON S.A.",
    "FUNDA√á√ÉO CSN",
    
    # === OUTROS GRUPOS (mantidos para compatibilidade futura) ===
    "Casas Bahia",
    "Profarma",
    "HAZTEC",
    "Grupo P√£o de A√ß√∫car",
    "CNS",
    "GRUPO KPFR",
    "Grupo EBX",
]


def get_parte_priority(parte_nome: str) -> int:
    """
    Retorna o √≠ndice de prioridade de uma parte interessada (menor = maior prioridade).
    Usa fuzzy matching para encontrar a melhor correspond√™ncia.
    
    Args:
        parte_nome: Nome da parte interessada (ex: "CBSI LTDA", "CSN S.A.")
    
    Returns:
        √çndice de prioridade (0 = maior prioridade) ou 999 se n√£o encontrado
    """
    from rapidfuzz import fuzz
    
    parte_upper = parte_nome.upper()
    
    # Tenta matching exato primeiro
    for idx, parte_ref in enumerate(PARTE_PRIORITY_ORDER):
        if parte_ref.upper() in parte_upper or parte_upper in parte_ref.upper():
            return idx
    
    # Fuzzy matching como fallback
    melhor_score = 0
    melhor_idx = 999
    
    for idx, parte_ref in enumerate(PARTE_PRIORITY_ORDER):
        score = fuzz.ratio(parte_upper, parte_ref.upper())
        if score > melhor_score and score >= 85:  # threshold de 85%
            melhor_score = score
            melhor_idx = idx
    
    return melhor_idx


def sort_partes_by_priority(partes: List[str]) -> List[str]:
    """
    Ordena uma lista de partes interessadas por prioridade (maior prioridade primeiro).
    
    Args:
        partes: Lista de nomes de partes interessadas
    
    Returns:
        Lista ordenada por prioridade
    
    Example:
        >>> sort_partes_by_priority(["CSN S.A.", "CBSI LTDA", "CSN MINERA√á√ÉO"])
        ["CBSI LTDA", "CSN S.A.", "CSN MINERA√á√ÉO"]
    """
    return sorted(partes, key=get_parte_priority)


def assign_primary_secondary_partes(
    partes_encontradas: List[str]
) -> Tuple[Optional[str], Optional[str]]:
    """
    Atribui parte interessada principal e secund√°ria baseado na prioridade.
    
    IMPORTANTE: Esta fun√ß√£o trabalha com NOMES DE PARTES INTERESSADAS, n√£o com clientes.
    
    Args:
        partes_encontradas: Lista de nomes de partes interessadas extra√≠das do PDF
                           Ex: ["CBSI LTDA", "CSN MINERA√á√ÉO S.A."]
    
    Returns:
        Tupla (parte_principal, parte_secundaria)
        
    Example:
        >>> partes = ["CSN MINERA√á√ÉO S.A.", "CBSI LTDA"]
        >>> assign_primary_secondary_partes(partes)
        ("CBSI LTDA", "CSN MINERA√á√ÉO S.A.")
    """
    if not partes_encontradas:
        return (None, None)
    
    # Remove duplicatas mantendo ordem
    partes_unicas = list(dict.fromkeys(partes_encontradas))
    
    if not partes_unicas:
        return (None, None)
    
    # Ordena por prioridade
    partes_ordenadas = sort_partes_by_priority(partes_unicas)
    
    # Primeira √© a principal, segunda (se existir) √© a secund√°ria
    parte_principal = partes_ordenadas[0] if len(partes_ordenadas) >= 1 else None
    parte_secundaria = partes_ordenadas[1] if len(partes_ordenadas) >= 2 else None
    
    return (parte_principal, parte_secundaria)


# Mant√©m fun√ß√£o legada para compatibilidade (deprecated)
def assign_primary_secondary_clients(
    clientes_encontrados: List[Dict[str, str]]
) -> Tuple[Optional[str], Optional[str]]:
    """
    DEPRECATED: Use assign_primary_secondary_partes() ao inv√©s desta fun√ß√£o.
    
    Mantido apenas para compatibilidade com c√≥digo existente.
    """
    if not clientes_encontrados:
        return (None, None)
    
    # Extrai nomes das partes
    nomes_partes = [c.get("parte", "") for c in clientes_encontrados if c.get("parte")]
    
    return assign_primary_secondary_partes(nomes_partes)


# Testes r√°pidos
if __name__ == "__main__":
    print("=" * 70)
    print("TESTES DE PRIORIDADE DE PARTES INTERESSADAS (GRUPO CSN)")
    print("=" * 70)
    print()
    
    # Teste 1: Caso CBSI + CSN (cen√°rio real do usu√°rio)
    print("Teste 1: CBSI + CSN (ambas no mesmo processo)")
    partes = [
        "CSN COMPANHIA SIDERURGICA NACIONAL S.A.",
        "CBSI COMPANHIA BRASILEIRA DE SERVI√áOS E INFRAESTRUTURA LTDA"
    ]
    principal, secundaria = assign_primary_secondary_partes(partes)
    print(f"  Partes encontradas: {partes}")
    print(f"  ‚úÖ Principal: {principal}")
    print(f"  ‚úÖ Secund√°ria: {secundaria}")
    print(f"  Esperado: CBSI (principal) e CSN (secund√°ria)")
    # CBSI deve ter prioridade sobre CSN
    assert "CBSI" in (principal or ""), "CBSI deveria ser principal"
    assert "CSN" in (secundaria or "") and "CBSI" not in (secundaria or ""), "CSN deveria ser secund√°ria"
    print("  ‚úÖ PASSOU\n")
    
    # Teste 2: Caso CSN + CSN MINERA√á√ÉO
    print("Teste 2: CSN + CSN MINERA√á√ÉO")
    partes = [
        "CSN MINERA√á√ÉO S.A.",
        "CSN ‚Äì COMPANHIA SIDERURGICA NACIONAL"
    ]
    principal, secundaria = assign_primary_secondary_partes(partes)
    print(f"  Partes encontradas: {partes}")
    print(f"  ‚úÖ Principal: {principal}")
    print(f"  ‚úÖ Secund√°ria: {secundaria}")
    print(f"  Esperado: CSN SIDERURGICA (principal) e CSN MINERA√á√ÉO (secund√°ria)")
    assert "SIDERURGICA" in (principal or "").upper(), "CSN Sider√∫rgica deveria ser principal"
    assert "MINERA√á√ÉO" in (secundaria or "").upper(), "CSN Minera√ß√£o deveria ser secund√°ria"
    print("  ‚úÖ PASSOU\n")
    
    # Teste 3: Apenas CBSI (sem outras partes)
    print("Teste 3: Apenas CBSI (sem outras partes)")
    partes = ["CBSI COMPANHIA BRASILEIRA DE SERVI√áOS E INFRAESTRUTURA"]
    principal, secundaria = assign_primary_secondary_partes(partes)
    print(f"  Partes encontradas: {partes}")
    print(f"  ‚úÖ Principal: {principal}")
    print(f"  ‚úÖ Secund√°ria: {secundaria}")
    print(f"  Esperado: CBSI (principal) e None (secund√°ria)")
    assert "CBSI" in (principal or ""), "CBSI deveria ser principal"
    assert secundaria is None, "N√£o deveria haver parte secund√°ria"
    print("  ‚úÖ PASSOU\n")
    
    # Teste 4: Teste de ordena√ß√£o m√∫ltipla
    print("Teste 4: Ordena√ß√£o de 3+ partes do grupo CSN")
    partes_desordenadas = [
        "CSN CIMENTOS BRASIL S/A",
        "CBSI LTDA",
        "CSN ‚Äì COMPANHIA SIDERURGICA NACIONAL",
        "CSN MINERA√á√ÉO S.A."
    ]
    ordenadas = sort_partes_by_priority(partes_desordenadas)
    print(f"  Original: {[p[:30] + '...' for p in partes_desordenadas]}")
    print(f"  Ordenado: {[p[:30] + '...' for p in ordenadas]}")
    print(f"  Esperado: CBSI primeiro, depois CSN Sider√∫rgica, depois outras")
    assert "CBSI" in ordenadas[0], "CBSI deve estar primeiro"
    assert "SIDERURGICA" in ordenadas[1].upper(), "CSN Sider√∫rgica deve estar segundo"
    print("  ‚úÖ PASSOU\n")
    
    print("=" * 70)
    print("TODOS OS TESTES PASSARAM! ‚úÖ")
    print("=" * 70)



================================================================================
FILE: extractors/brand_map.py
================================================================================
# -*- coding: utf-8 -*-
# extractors/brand_map.py
import unicodedata
import re
import json
import os
from typing import Optional, Dict, List
from rapidfuzz import fuzz, process

# Cache do banco de dados de clientes
_CLIENTES_DB: Optional[Dict] = None

def _load_clientes_database() -> Dict:
    """Carrega o banco de dados de clientes do JSON."""
    global _CLIENTES_DB
    
    if _CLIENTES_DB is not None:
        return _CLIENTES_DB
    
    # Caminho para o JSON
    json_path = os.path.join(os.path.dirname(__file__), "..", "data", "clientes_database.json")
    
    if not os.path.exists(json_path):
        # Fallback: retorna estrutura vazia se JSON n√£o existir
        _CLIENTES_DB = {"clientes": {}, "partes_interessadas": []}
        return _CLIENTES_DB
    
    with open(json_path, "r", encoding="utf-8") as f:
        loaded_data = json.load(f)
        # Garante que sempre retornamos um Dict v√°lido
        _CLIENTES_DB = loaded_data if isinstance(loaded_data, dict) else {"clientes": {}, "partes_interessadas": []}
    
    return _CLIENTES_DB

def _norm(s: str) -> str:
    """Uppercase + remove acentos + colapsa espa√ßos."""
    if not s:
        return ""
    s = unicodedata.normalize("NFD", s)
    s = "".join(ch for ch in s if not unicodedata.combining(ch))
    s = s.upper()
    s = re.sub(r"\s+", " ", s).strip()
    return s

def find_cliente_by_parte_interessada(nome_parte: str, threshold: int = 85) -> Optional[str]:
    """
    Busca o cliente correspondente a uma parte interessada usando fuzzy matching.
    
    Args:
        nome_parte: Nome da parte interessada (empresa) extra√≠da do PDF
        threshold: Score m√≠nimo de similaridade (0-100). Default: 85
        
    Returns:
        Nome do cliente encontrado ou None
        
    Examples:
        find_cliente_by_parte_interessada("PROFARMA DISTRIBUIDORA DE PRODUTOS FARMACEUTICOS SA")
        ‚Üí "Profarma"
        
        find_cliente_by_parte_interessada("ORIZON MEIO AMBIENTE S.A.")
        ‚Üí "HAZTEC"
    """
    if not nome_parte:
        return None
    
    db = _load_clientes_database()
    partes = db.get("partes_interessadas", [])
    
    if not partes:
        return None
    
    # Normaliza o nome da parte para busca
    nome_norm = _norm(nome_parte)
    
    # ‚úÖ BUSCA EXATA PRIMEIRO (mais r√°pida)
    for item in partes:
        if _norm(item["nome"]) == nome_norm:
            return item["cliente"]
    
    # ‚úÖ FUZZY MATCHING: Encontra a melhor correspond√™ncia
    # üîß FIX: Normaliza AMBOS os lados antes do fuzzy matching para ignorar acentos
    nomes_norm_map = {_norm(item["nome"]): item for item in partes}
    nomes_norm = list(nomes_norm_map.keys())
    
    # Usa token_set_ratio para lidar com varia√ß√µes de ordem e abrevia√ß√µes
    result = process.extractOne(
        nome_norm,
        nomes_norm,
        scorer=fuzz.token_set_ratio,
        score_cutoff=threshold
    )
    
    if result:
        nome_encontrado_norm, score, idx = result
        # Encontra o cliente correspondente usando o nome normalizado
        item = nomes_norm_map.get(nome_encontrado_norm)
        if item:
            return item["cliente"]
    
    return None

def detect_grupo(nome_ou_texto: str) -> Optional[str]:
    """
    Detecta se o texto cont√©m qualquer sin√¥nimo do GPA.
    Retorna 'Grupo P√£o de A√ß√∫car' se detectado, None caso contr√°rio.
    
    IMPORTANTE: Esta fun√ß√£o √© mantida por compatibilidade retroativa.
    Use normalize_cliente() para normalizar qualquer cliente.
    """
    # Usa o novo sistema baseado em JSON
    cliente = find_cliente_by_parte_interessada(nome_ou_texto, threshold=80)
    if cliente and "P√£o de A√ß√∫car" in cliente:
        return "Grupo P√£o de A√ß√∫car"
    
    # Fallback: busca hardcoded para GPA
    _GPA_ALIASES = [
        "GRUPO P√ÉO DE A√á√öCAR", "GRUPO PAO DE ACUCAR",
        "P√ÉO DE A√á√öCAR", "PAO DE ACUCAR",
        "GPA", "CBD", "SENDAS", "SENDAS DISTRIBUIDORA",
        "COMPANHIA BRASILEIRA DE DISTRIBUICAO",
        "COMPANHIA BRASILEIRA DE DISTRIBUI√á√ÉO",
        "EXTRA", "ASSA√ç", "ASSAI",
    ]
    
    t = _norm(nome_ou_texto)
    if not t:
        return None
    
    for alias in _GPA_ALIASES:
        if _norm(alias) in t:
            return "Grupo P√£o de A√ß√∫car"
    
    return None

def normalize_cliente(nome_cliente: str) -> str:
    """
    Normaliza o nome do cliente usando o banco de dados JSON com fuzzy matching.
    
    ‚úÖ NOVO: Usa clientes_database.json para reconhecer QUALQUER cliente cadastrado,
    n√£o apenas aliases hardcoded.
    
    Args:
        nome_cliente: Nome do cliente/reclamado extra√≠do do PDF
        
    Returns:
        Nome can√¥nico do cliente do banco de dados ou o nome original se n√£o encontrado
        
    Examples:
        normalize_cliente("PROFARMA DISTRIBUIDORA DE PRODUTOS FARMACEUTICOS SA")
        ‚Üí "Profarma"
        
        normalize_cliente("ORIZON MEIO AMBIENTE S.A.")
        ‚Üí "HAZTEC"
        
        normalize_cliente("CBSI COMPANHIA BRASILEIRA")
        ‚Üí "CSN"
    """
    if not nome_cliente:
        return nome_cliente
    
    # ‚úÖ BUSCA NO BANCO DE DADOS JSON com threshold reduzido (80) para melhor recall
    # üîß FIX: Agora ignora acentos no fuzzy matching (DISTRIBUICAO = DISTRIBUI√á√ÉO)
    cliente_encontrado = find_cliente_by_parte_interessada(nome_cliente, threshold=80)
    
    if cliente_encontrado:
        return cliente_encontrado
    
    # ‚úÖ FALLBACK: Retorna o nome original capitalizado
    return nome_cliente.strip().title() if nome_cliente else nome_cliente

def get_all_clientes() -> List[str]:
    """
    Retorna lista de todos os clientes cadastrados no banco de dados.
    
    Returns:
        Lista com nomes de todos os clientes
    """
    db = _load_clientes_database()
    return list(db.get("clientes", {}).keys())

def get_partes_by_cliente(nome_cliente: str) -> List[str]:
    """
    Retorna todas as partes interessadas de um cliente espec√≠fico.
    
    Args:
        nome_cliente: Nome do cliente
        
    Returns:
        Lista de partes interessadas do cliente
    """
    db = _load_clientes_database()
    clientes = db.get("clientes", {})
    
    if nome_cliente in clientes:
        return clientes[nome_cliente].get("partes", [])
    
    return []



================================================================================
FILE: extractors/audiencia.py
================================================================================
import re
from typing import Optional

def parse_audiencia_inicial(texto: str) -> Optional[str]:
    """
    Extrai data/hora de AUDI√äNCIA INICIAL do texto.
    
    IMPORTANTE: S√≥ retorna se encontrar contexto de "AUDI√äNCIA" pr√≥ximo √† data.
    Isso evita capturar erroneamente a data de distribui√ß√£o do processo.
    
    2025-11-28: CORRE√á√ÉO CR√çTICA - Limitar dist√¢ncia entre "audi√™ncia" e a data
    para evitar capturar timestamps de assinatura eletr√¥nica.
    M√°ximo 200 caracteres entre "audi√™ncia" e a data.
    
    TAMB√âM: Verificar se o PDF menciona "n√£o agendada" antes de retornar audi√™ncia.
    """
    t = texto or ""
    
    # ‚úÖ VERIFICA√á√ÉO: "n√£o agendada" - MOVIDA para o final, ap√≥s tentar todos os padr√µes
    # 2025-11-28: Corrigido - o texto pode ter "Audi√™ncia inicial do processo n√£o agendada automaticamente"
    # MAS tamb√©m ter uma audi√™ncia real agendada. Priorizar a extra√ß√£o da audi√™ncia real.
    # A verifica√ß√£o ser√° feita APENAS se nenhum padr√£o encontrar audi√™ncia.
    
    # Padr√£o 1: "Determino a audi√™ncia INICIAL TELEPRESENCIAL... : DD/MM/AAAA HH:MM"
    # 2025-11-28: Limitado a 200 chars entre audi√™ncia e data para evitar falsos positivos
    m = re.search(
        r'determino\s+a\s+audi[√™e]ncia\s+.{0,100}?inicial.{0,100}?:\s*(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # Padr√£o 2: "audi√™ncia INICIAL... : DD/MM/AAAA HH:MM" (sem "Determino")
    # 2025-11-28: CORRIGIDO - Limitar a 100 chars entre "audi√™ncia" e "inicial"
    # e 100 chars entre "inicial" e a data. Antes era .*? sem limite.
    m = re.search(
        r'audi[√™e]ncia\s+.{0,100}?inicial.{0,100}?:\s*(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # Padr√£o 3: "Determino a audi√™ncia INICIAL... DD/MM/AAAA √†s HH:MM" (com "√†s")
    m = re.search(
        r'determino\s+a\s+audi[√™e]ncia\s+.{0,100}?inicial.{0,100}?(\d{2}/\d{2}/\d{4})\s+[√†a]s\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 3b: "AUDI√äNCIA UNA" - comum em varas que unificam audi√™ncia inicial e de instru√ß√£o
    # 2025-11-28: Limitado a 100 chars
    m = re.search(
        r'audi[√™e]ncia\s+una.{0,100}?(\d{2}/\d{2}/\d{4})\s+[√†a]?s?\s*(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 3c: "audi√™ncia de concilia√ß√£o e instru√ß√£o"
    # 2025-11-28: Limitado a 100 chars
    m = re.search(
        r'audi[√™e]ncia\s+de\s+concilia[√ßc][a√£]o\s+e\s+instru[√ßc][a√£]o.{0,100}?(\d{2}/\d{2}/\d{4})\s+[√†a]?s?\s*(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 3d: "pauta de audi√™ncia" com data
    # 2025-11-28: Limitado a 100 chars
    m = re.search(
        r'pauta\s+de\s+audi[√™e]ncia.{0,100}?(\d{2}/\d{2}/\d{4})\s+[√†a]?s?\s*(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # Padr√£o 4: "AUDI√äNCIA... para DD/MM/AAAA HH:MM"
    m = re.search(
        r'audi[√™e]ncia.{0,80}?\s+para\s+(\d{2}/\d{2}/\d{4}).{0,20}?(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # Padr√£o 5: "Audi√™ncia marcada para DD/MM/AAAA √†s HH:MM"
    m = re.search(
        r'audi[√™e]ncia\s+marcada\s+para\s+(\d{2}/\d{2}/\d{4})\s+[√†a]s\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 5b: "Audi√™ncia designada para DD/MM/AAAA √†s HH:MM"
    m = re.search(
        r'audi[√™e]ncia\s+designada\s+para\s+(\d{2}/\d{2}/\d{4})\s+[√†a]s\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 5c: "Audi√™ncia agendada para DD/MM/AAAA √†s HH:MM"
    m = re.search(
        r'audi[√™e]ncia\s+agendada\s+para\s+(\d{2}/\d{2}/\d{4})\s+[√†a]s\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 5d: "Fica designada audi√™ncia para DD/MM/AAAA HH:MM"
    m = re.search(
        r'fica\s+designada\s+audi[√™e]ncia\s+para\s+(\d{2}/\d{2}/\d{4})\s+[√†a]?s?\s*(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # Padr√£o 6: "dia DD/MM/AAAA HH:MM horas" (comum em notifica√ß√µes de audi√™ncia)
    # Exemplo: "AUDI√äNCIA INICIAL... que se realizar√° no dia 09/12/2025 08:50 horas"
    # 2025-11-28: Limitado a 150 chars entre audi√™ncia e dia
    m = re.search(
        r'audi[√™e]ncia.{0,150}?\bdia\s+(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})\s+horas',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 7: Formato com h√≠fen na data "DD-MM-AAAA HH:MM"
    # 2025-11-28: Limitado a 100 chars
    m = re.search(
        r'audi[√™e]ncia\s+.{0,100}?inicial.{0,100}?:\s*(\d{2}-\d{2}-\d{4})\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        data = m.group(1).replace('-', '/')
        return f"{data} {m.group(2)}"
    
    # üÜï Padr√£o 8: "primeira audi√™ncia" como sin√¥nimo de inicial
    # 2025-11-28: Limitado a 100 chars
    m = re.search(
        r'primeira\s+audi[√™e]ncia.{0,100}?(\d{2}/\d{2}/\d{4})\s+[√†a]?s?\s*(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 9: "UNA a ser realizada em... TELEPRESENCIAL DD/MM/AAAA HH:MM"
    # Batch 97: "UNA a ser realizada em , modalidade TELEPRESENCIAL. 27/01/2026 08:35"
    m = re.search(
        r'UNA\s+a\s+ser\s+realizada.{0,50}?(?:TELEPRESENCIAL|PRESENCIAL).?\s*(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 10: "audi√™ncia que se realizar√° no dia: DD/MM/AAAA HH:MM horas"
    # Batch 97: "comparecer √† audi√™ncia que se realizar√° no dia: 02/12/2025 14:10 horas"
    m = re.search(
        r'audi[√™e]ncia\s+que\s+se\s+realizar[√°a]\s+no\s+dia:?\s*(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 11: "Designo audi√™ncia para , UNA telepresencial DD/MM/AAAA HH:MM"
    # Batch 97: "Designo audi√™ncia para , UNA telepresencial 25/02/2026 10:45"
    m = re.search(
        r'[Dd]esigno\s+audi[√™e]ncia\s+para\s*,?\s*UNA.{0,30}?(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 12: "pauta INICIAL PRESENCIAL DD/MM/AAAA"
    # Batch 97: "Processo inclu√≠do em pauta INICIAL PRESENCIAL 09/12/2025"
    # Nota: Este padr√£o geralmente n√£o tem hora, usamos 09:00 como default
    m = re.search(
        r'pauta\s+(?:INICIAL|UNA)\s+(?:TELEPRESENCIAL|PRESENCIAL)\s+(\d{2}/\d{2}/\d{4})',
        t,
        re.IGNORECASE
    )
    if m:
        # Tentar encontrar hora nas proximidades
        hora_match = re.search(
            r'pauta.{0,80}?' + re.escape(m.group(1)) + r'\s+(\d{1,2}:\d{2})',
            t,
            re.IGNORECASE | re.DOTALL
        )
        if hora_match:
            return f"{m.group(1)} {hora_match.group(1)}"
        return f"{m.group(1)} 09:00"  # Hora default
    
    # üÜï Padr√£o 13: "AUDI√äNCIA... instru√ß√£o e julgamento... dia DD/MM/AAAA HH:MM"
    # Para audi√™ncias de instru√ß√£o quando n√£o h√° inicial
    m = re.search(
        r'audi[√™e]ncia\s+de\s+instru[√ßc][a√£]o.{0,80}?dia\s+(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 14: Data antes de "horas" com contexto de audi√™ncia
    # "audi√™ncia... 02/12/2025 14:10 horas" (sem "dia")
    m = re.search(
        r'audi[√™e]ncia.{0,100}?(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})\s+horas',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        return f"{m.group(1)} {m.group(2)}"
    
    # üÜï Padr√£o 15: Formato gen√©rico "audi√™ncia... DD/MM/AAAA HH:MM" (fallback com limite)
    # Captura padr√µes n√£o cobertos pelos anteriores
    m = re.search(
        r'audi[√™e]ncia.{0,80}?(\d{2}/\d{2}/\d{4})\s+(\d{1,2}:\d{2})',
        t,
        re.IGNORECASE | re.DOTALL
    )
    if m:
        # Verificar se n√£o √© contexto inv√°lido
        start = max(0, m.start() - 30)
        context = t[start:m.end()].lower()
        invalid = ['distribui√ß√£o', 'autua√ß√£o', 'assinado', 'publica√ß√£o']
        if not any(inv in context for inv in invalid):
            return f"{m.group(1)} {m.group(2)}"
    
    # Se n√£o encontrou NENHUM padr√£o espec√≠fico de audi√™ncia, retorna None
    # Isso evita capturar datas de distribui√ß√£o ou outras datas aleat√≥rias
    return None



================================================================================
FILE: extractors/cadastro.py
================================================================================
# extractors/cadastro.py
from __future__ import annotations
from typing import Dict, Any

from .pipeline import run_extraction_from_text  # usa a vers√£o correta do pipeline

def parse_pdf_text(texto: str, filename: str | None = None, **kwargs) -> Dict[str, Any]:
    data = run_extraction_from_text(texto or "", filename=filename)
    # garante chaves que o template espera
    defaults = {
        "comarca": "",
        "numero_orgao": "",
        "instancia": "",
        "celula": "",
        "parte_interessada": "",
        "cpf_cnpj_parte_adversa": "",
    }
    for k, v in defaults.items():
        data.setdefault(k, v)
    return data



================================================================================
FILE: extractors/decisao.py
================================================================================
import re
import logging
logger = logging.getLogger(__name__)

def parse_decisao_tipo(text: str):
    # Verifica contexto de decis√£o judicial, n√£o apenas palavra solta
    text_lower = (text or "").lower()
    
    # Padr√µes que indicam REALMENTE uma senten√ßa/ac√≥rd√£o
    sentenca_patterns = [
        r"senten√ßa\s+(proferida|publicada|transitada)",
        r"julgo\s+(procedente|improcedente)",
        r"dispositivo.*senten√ßa",
        r"senten√ßa.*julg"
    ]
    acordao_patterns = [
        r"ac√≥rd√£o\s+(proferido|publicado)",
        r"acordam\s+os\s+desembargadores",
        r"vistos.*relatados.*e\s+discutidos"
    ]
    
    for pattern in sentenca_patterns:
        if re.search(pattern, text_lower):
            return "Senten√ßa"
    
    for pattern in acordao_patterns:
        if re.search(pattern, text_lower):
            return "Ac√≥rd√£o"
    
    return None

def parse_decisao_resultado(text: str):
    # S√≥ identifica DECIS√ïES efetivas, n√£o pedidos ou condicionais
    text_lower = (text or "").lower()
    
    # Padr√µes que indicam DECIS√ÉO j√° tomada (verbos no pret√©rito/conclusivo)
    # IMPORTANTE: verificar negativo PRIMEIRO (improcedente cont√©m "procedente")
    
    # Padr√µes negativos (indeferido/improcedente) - APENAS com verbos decis√≥rios
    negative_patterns = [
        r"(julgo|julguei)\s+.*improcedente",
        r"(julgo|julguei)\s+.*indeferid[ao]",
        r"(foi|restou|encontra-se)\s+.*improcedente",
        r"(foi|restou|encontra-se)\s+.*indeferid[ao]",
        r"(a√ß√£o|pedido|recurso)\s+(foi|restou|julgad[ao])\s+.*improcedente",
        r"(a√ß√£o|pedido|recurso)\s+(foi|restou|julgad[ao])\s+.*indeferid[ao]"
    ]
    
    for pattern in negative_patterns:
        if re.search(pattern, text_lower):
            return "Indeferido"
    
    # Padr√µes positivos (deferido/procedente) - APENAS com verbos decis√≥rios conclusivos
    positive_patterns = [
        r"(julgo|julguei)\s+.*(procedente|deferid[ao])",
        r"(foi|restou|encontra-se)\s+.*(procedente|deferid[ao])",
        r"(a√ß√£o|pedido|recurso)\s+(foi|restou|julgad[ao])\s+.*(procedente|deferid[ao])"
    ]
    
    for pattern in positive_patterns:
        if re.search(pattern, text_lower):
            return "Deferido"
    
    return None

def parse_fundamentacao_resumida(text: str):
    if not text:
        return None
    parts = [p.strip() for p in text.split(".") if len(p.strip()) > 60]
    return parts[0] if parts else None



================================================================================
FILE: extractors/dictionary.py
================================================================================
# extractors/dictionary.py
import json
import os
import re
from typing import Dict, List, Optional
from difflib import SequenceMatcher

try:
    import docx  # python-docx
except Exception:
    docx = None

DICT_JSON_PATH = os.getenv("DICT_JSON_PATH", "data/actors.json")

def _similar(a: str, b: str) -> float:
    return SequenceMatcher(None, a.upper(), b.upper()).ratio()

def load_dictionary_from_docx(docx_path: str) -> List[Dict]:
    """
    L√™ DOCX com mapeamento CLIENTE x C√âLULA x PARTE INTERESSADA.
    Espera um conte√∫do tabular ou linhas 'Cliente: ... / C√©lula: ... / Parte: ...'
    """
    items = []
    if not docx or not os.path.exists(docx_path):
        return items

    doc = docx.Document(docx_path)
    # 1) Tabelas
    for table in doc.tables:
        headers = [c.text.strip() for c in table.rows[0].cells]
        for row in table.rows[1:]:
            values = [c.text.strip() for c in row.cells]
            rowdict = dict(zip(headers, values))
            cliente = rowdict.get("CLIENTE") or rowdict.get("Cliente") or ""
            celula = rowdict.get("C√âLULA") or rowdict.get("Celula") or rowdict.get("C√©lula") or ""
            parte  = rowdict.get("PARTE INTERESSADA") or rowdict.get("Parte Interessada") or ""
            if any([cliente, celula, parte]):
                items.append({"cliente": cliente, "celula": celula, "parte_interessada": parte})

    # 2) Linhas soltas (fallback)
    buf = "\n".join(p.text for p in doc.paragraphs)
    for line in buf.splitlines():
        m = re.search(r"Cliente\s*:\s*(.+?)\s*/\s*C[√âE]lula\s*:\s*(.+?)\s*/\s*Parte\s*Interessada\s*:\s*(.+)$", line, re.I)
        if m:
            items.append({
                "cliente": m.group(1).strip(),
                "celula":  m.group(2).strip(),
                "parte_interessada": m.group(3).strip(),
            })
    return items

def save_dictionary(items: List[Dict]):
    os.makedirs(os.path.dirname(DICT_JSON_PATH) or ".", exist_ok=True)
    with open(DICT_JSON_PATH, "w", encoding="utf-8") as f:
        json.dump(items, f, ensure_ascii=False, indent=2)

def load_dictionary() -> List[Dict]:
    if not os.path.exists(DICT_JSON_PATH):
        return []
    try:
        with open(DICT_JSON_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return []

def enrich_with_dictionary(data: Dict, dict_items: Optional[List[Dict]] = None) -> Dict:
    """
    Se parte_interessada bater com o dicion√°rio, preenche cliente/c√©lula.
    """
    if dict_items is None:
        dict_items = load_dictionary()

    parte = (data.get("parte_interessada") or "").strip()
    if not parte or not dict_items:
        return data

    best, bestscore = None, 0.0
    for item in dict_items:
        pi = (item.get("parte_interessada") or "").strip()
        if not pi:
            continue
        score = _similar(parte, pi)
        if score > bestscore:
            best, bestscore = item, score

    if best and bestscore >= 0.90:
        data.setdefault("cliente", best.get("cliente", ""))
        data.setdefault("celula", best.get("celula", ""))

    return data



================================================================================
FILE: extractors/postprocess.py
================================================================================
from typing import Dict, Any, List
import re

from .regex_utils import (
    parse_comarca as _parse_comarca,
    extract_estado_sigla,
    parse_numero_orgao_from_cnj,
)
from .dictionary import load_dictionary_from_docx

# tenta nas duas localiza√ß√µes (raiz e /data)
_CELL_DOCX_PATHS = [
    "CLIENTE X C√âLULA.docx",
    "CLIENTE X C√âLULA.DOCX",
    "data/CLIENTE X C√âLULA.docx",
    "data/CLIENTE X C√âLULA.DOCX",
]


def _choose_instancia(vara: str | None, orgao: str | None, text: str) -> str | None:
    if vara and re.search(r'\bvara\s+do\s+trabalho\b', vara, re.I):
        return "1¬™ Inst√¢ncia"
    if orgao and re.search(r'\bTRT', orgao, re.I):
        if re.search(r'\b1[¬∫o]\s*grau\b', text, re.I):
            return "1¬™ Inst√¢ncia"
        return "2¬™ Inst√¢ncia"
    return None

def _numero_orgao_from_vara(vara: str | None, texto: str | None) -> str | None:
    """
    Extrai o ordinal da Vara:
      - casa '1¬™ Vara', '1a Vara', ou at√© '1 Vara'
      - procura primeiro em data['vara'] e depois no texto bruto
      - 'Vara √önica' -> '1'
    """
    for src in [(vara or ""), (texto or "")]:
        # 1¬™ / 1a / 1  + "Vara"
        m = re.search(r'\b([1-9][0-9]?)\s*(?:¬™|a)?\s*Vara\b', src, re.I)
        if m:
            return str(int(m.group(1)))  # normaliza sem zeros √† esquerda

        # Em alguns PDFs vem como "Vara do Trabalho de ..."
        m2 = re.search(r'\b([1-9][0-9]?)\s*(?:¬™|a)?\s*Vara\s+do\s+Trabalho\b', src, re.I)
        if m2:
            return str(int(m2.group(1)))

    # "Vara √önica" conta como 1
    if re.search(r'\bVara\s+√önica\b', (vara or texto or ""), re.I):
        return "1"

    return None

def _prefer_parte_interessada(texto: str, cliente_grupo: str | None) -> str | None:
    up = (texto or "").upper()
    if re.search(r'COMPANHIA\s+BRASILEIRA\s+DE\s+DISTRIBUI', up):
        return "Companhia Brasileira de Distribui√ß√£o"
    if re.search(r'\bSENDAS\s+DISTRIBUIDOR(A|A)\b|\bSENDAS\s+DISTRIBUIDORA', up):
        return "Sendas Distribuidora S/A"

    for p in _CELL_DOCX_PATHS:
        try:
            rows = load_dictionary_from_docx(p)
            for r in rows:
                if r.get("CLIENTE","").strip().upper() == (cliente_grupo or "").upper():
                    pi = r.get("PARTE INTERESSADA") or r.get("Parte Interessada")
                    if pi:
                        return pi.strip()
        except Exception:
            pass
    return None

def _pick_celula(cliente_grupo: str | None, texto: str) -> str | None:
    """
    Retorna a c√©lula correspondente ao cliente baseado no clientes_database.json.
    
    Mapeia clientes para suas c√©lulas no eLaw:
    - Casas Bahia ‚Üí "Trabalhista Casas Bahia"
    - CSN ‚Üí "Trabalhista CSN"
    - Grupo P√£o de A√ß√∫car ‚Üí "Trabalhista GPA"
    - Profarma ‚Üí "Trabalhista Pro Pharma"
    - Prudential ‚Üí "Trabalhista Prudential"
    - Outros ‚Üí "Trabalhista Outros Clientes"
    """
    if not cliente_grupo:
        return None
    
    # Carregar database de clientes
    import json
    import os
    
    json_path = os.path.join(os.path.dirname(__file__), "..", "data", "clientes_database.json")
    try:
        with open(json_path, "r", encoding="utf-8") as f:
            data = json.load(f)
            
        # Buscar cliente no database
        for nome_cliente, info in data.get("clientes", {}).items():
            if nome_cliente.strip().upper() == cliente_grupo.strip().upper():
                celula = info.get("celula")
                if celula:
                    return celula.strip()
    except Exception:
        pass
    
    # Fallback: se n√£o encontrar no JSON, tenta heur√≠stica
    if re.search(r'P(√É|A)O\s+DE\s+A(C|√á)U(C|C)AR|GPA|CBD|SENDAS', cliente_grupo, re.I):
        return "Trabalhista GPA"
    elif re.search(r'CASAS?\s+BAHIA', cliente_grupo, re.I):
        return "Trabalhista Casas Bahia"
    elif re.search(r'\bCSN\b|CBSI', cliente_grupo, re.I):
        return "Trabalhista CSN"
    elif re.search(r'PROFARMA', cliente_grupo, re.I):
        return "Trabalhista Pro Pharma"
    elif re.search(r'PRUDENTIAL', cliente_grupo, re.I):
        return "Trabalhista Prudential"
    
    # Default para clientes n√£o mapeados
    return "Trabalhista Outros Clientes"

def _comarca_por_vara(vara: str, uf_hint: str | None, texto: str) -> str | None:
    m = re.search(r'Vara\s+do\s+Trabalho\s+de\s+([A-Za-z√Ä-√∫\s\'\-]+)', vara or "", re.I)
    if not m:
        return None
    cidade = m.group(1).strip().title()
    uf = uf_hint or extract_estado_sigla(texto) or ""
    return f"{cidade} - {uf}" if uf else cidade

def full_postprocess(base: Dict[str, Any], text: str, celula_options: List[str] | None = None) -> Dict[str, Any]:
    data = dict(base or {})
    texto = text or ""

    # --- COMARCA --------------------------------------------------------------
    if not data.get("comarca"):
        c = _parse_comarca(texto)
        if not c:
            combo = " ".join([data.get("foro",""), data.get("vara","")])
            c = _parse_comarca(combo)
        if not c and data.get("vara"):
            c = _comarca_por_vara(data["vara"], data.get("estado"), texto)
        if c:
            data["comarca"] = c

        # --- CLIENTE (fallback via parte_adversa_nome) --------------------------------
    if not data.get("cliente_grupo") and data.get("parte_adversa_nome"):
        from extractors.brand_map import find_cliente_by_parte_interessada
        cliente_encontrado = find_cliente_by_parte_interessada(data["parte_adversa_nome"])
        if cliente_encontrado:
            data["cliente_grupo"] = cliente_encontrado
            if not data.get("cliente"):
                data["cliente"] = cliente_encontrado
    
    # --- C√âLULA ---------------------------------------------------------------
    if not data.get("celula"):
        cel = _pick_celula(data.get("cliente_grupo"), texto)
        # fallback extra se por algum motivo o heur√≠stico n√£o bateu
        if not cel and data.get("cliente_grupo") and re.search(r'P[√ÉA]O\s+DE\s+A[C√á]√öCAR|GPA|CBD|SENDAS',
                                                               data["cliente_grupo"], re.I):
            cel = "Trabalhista GPA"
        if cel:
            data["celula"] = cel

    # --- INST√ÇNCIA ------------------------------------------------------------
    inst = _choose_instancia(data.get("vara"), data.get("orgao"), texto)
    if inst:
        data["instancia"] = inst

    # --- N√öMERO DO √ìRG√ÉO (ordinal da Vara: 1 para 1¬™, 2 para 2¬™...) ----------
        no = _numero_orgao_from_vara(data.get("vara"), texto)
        if no:
            data["numero_orgao"] = no
        else:
            # Se REALMENTE n√£o conseguir achar o ordinal, N√ÉO force o sufixo do CNJ (ex.: 0481),
            # pois isso √© c√≥digo do √≥rg√£o e n√£o o ordinal da Vara.
            # Deixe em branco para a UI ou rotas tratarem fallback se necess√°rio.
            pass

    # --- PARTE INTERESSADA ----------------------------------------------------
    if not data.get("parte_interessada") or data["parte_interessada"] in {data.get("cliente"), data.get("cliente_grupo")}:
        pi = _prefer_parte_interessada(texto, data.get("cliente_grupo"))
        if pi:
            data["parte_interessada"] = pi

        # --- CPF/CNPJ PARTE ADVERSA (refor√ßo) ------------------------------------
        if data.get("parte_adversa_nome") and not data.get("cpf_cnpj_parte_adversa"):
            try:
                from .regex_utils import extract_cpf_cnpj_near
                doc_id = extract_cpf_cnpj_near(texto, data["parte_adversa_nome"])
                if not doc_id:
                    # √∫ltimo recurso: primeiro CPF que aparecer no documento
                    m_any = re.search(r'\b\d{3}[.\s]?\d{3}[.\s]?\d{3}[-]?\d{2}\b', texto)
                    if m_any:
                        doc_id = re.sub(r'\D', '', m_any.group(0))
                if doc_id:
                    data["cpf_cnpj_parte_adversa"] = doc_id
                    if len(doc_id) == 11:
                        data["parte_adversa_tipo"] = "PESSOA FISICA"
                    elif len(doc_id) == 14:
                        data["parte_adversa_tipo"] = "PESSOA JURIDICA"
            except Exception:
                pass

    # Observa√ß√£o: segredo de justi√ßa
    if not data.get("observacao") and re.search(r"segredo\s+de\s+justi[c√ß]a", (text or ""), re.I):
        data["observacao"] = "Segredo de justi√ßa"

    return data



================================================================================
FILE: extractors/reextract.py
================================================================================
# extractors/reextract.py
"""
M√≥dulo de Re-extra√ß√£o OCR Seletiva para campos cr√≠ticos vazios.

PLANO BATMAN v2 - OCR como fallback CIR√öRGICO:
- S√≥ aciona OCR quando Regex+LLM falharam
- Processa APENAS p√°ginas relevantes (TRCT, contracheques)
- Prioriza: sal√°rio > PIS > CTPS (ordem de import√¢ncia)
- Tempo esperado: 5-15s por campo (vs minutos do OCR completo)
"""

import logging
from typing import Dict, Any, Optional, List
from pathlib import Path

logger = logging.getLogger(__name__)

CRITICAL_LABOR_FIELDS = ['salario', 'pis', 'ctps']


def get_missing_critical_fields(data: Dict[str, Any]) -> List[str]:
    """
    Identifica campos cr√≠ticos que est√£o vazios/None.
    
    Returns:
        Lista de nomes de campos faltantes
    """
    missing = []
    for field in CRITICAL_LABOR_FIELDS:
        val = data.get(field, "")
        if not val or str(val).strip() == "":
            missing.append(field)
    return missing


def reextract_field_with_ocr(
    pdf_path: str,
    field: str,
    existing_data: Optional[Dict[str, Any]] = None
) -> Optional[str]:
    """
    Re-extrai UM campo espec√≠fico via OCR cir√∫rgico.
    
    Estrat√©gia por campo:
    - salario: P√°ginas de TRCT/contracheque (salary_candidates)
    - pis: P√°ginas de CTPS/ficha de registro
    - ctps: P√°ginas de CTPS/ficha de registro
    
    Args:
        pdf_path: Caminho do PDF
        field: Nome do campo a extrair ('salario', 'pis', 'ctps')
        existing_data: Dados j√° extra√≠dos (para evitar re-trabalho)
    
    Returns:
        Valor extra√≠do ou None
    """
    from .ocr_utils import (
        map_pdf_annexes, 
        extract_ocr_from_specific_pages,
        extract_salario_from_contracheque_ocr
    )
    from .regex_utils import extract_salario, extract_pis, extract_ctps
    
    if not pdf_path or not Path(pdf_path).exists():
        logger.warning(f"[REEXTRACT] PDF n√£o encontrado: {pdf_path}")
        return None
    
    logger.info(f"[REEXTRACT] Iniciando OCR seletivo para '{field}': {pdf_path}")
    
    try:
        mapping = map_pdf_annexes(pdf_path)
        scanned_pages = set(mapping.get('scanned', []))
        
        if not scanned_pages:
            logger.debug(f"[REEXTRACT] Nenhuma p√°gina escaneada - {field} provavelmente n√£o est√° em imagem")
            return None
        
        if field == 'salario':
            pages_priority = []
            
            trct = [p for p in mapping.get('trct', []) if p in scanned_pages]
            contracheque = [p for p in mapping.get('contracheque', []) if p in scanned_pages]
            candidates = mapping.get('salary_candidates', [])
            
            pages_priority.extend(trct[:3])
            pages_priority.extend(contracheque[:3])
            pages_priority.extend([p for p in candidates if p not in pages_priority][:4])
            
            if not pages_priority:
                logger.info(f"[REEXTRACT] Nenhuma p√°gina candidata para sal√°rio")
                return None
            
            pages_to_ocr = list(dict.fromkeys(pages_priority))[:8]
            logger.info(f"[REEXTRACT_SALARIO] Processando p√°ginas: {pages_to_ocr}")
            
            texto_ocr = extract_ocr_from_specific_pages(pdf_path, pages_to_ocr, max_pages=8)
            
            if not texto_ocr:
                return None
            
            salario = extract_salario_from_contracheque_ocr(texto_ocr)
            if not salario:
                salario = extract_salario(texto_ocr)
            
            if salario:
                logger.info(f"[REEXTRACT_SALARIO] ‚úÖ Encontrado: {salario}")
            return salario
            
        elif field in ('pis', 'ctps'):
            pages_priority = []
            
            ctps_pages = [p for p in mapping.get('ctps', []) if p in scanned_pages]
            ficha = [p for p in mapping.get('ficha_registro', []) if p in scanned_pages]
            trct = [p for p in mapping.get('trct', []) if p in scanned_pages]
            
            pages_priority.extend(ctps_pages[:3])
            pages_priority.extend(ficha[:2])
            pages_priority.extend(trct[:2])
            
            if not pages_priority:
                all_scanned = list(scanned_pages)
                if len(all_scanned) >= 3:
                    pages_priority = all_scanned[:5]
                else:
                    logger.info(f"[REEXTRACT] Nenhuma p√°gina candidata para {field}")
                    return None
            
            pages_to_ocr = list(dict.fromkeys(pages_priority))[:6]
            logger.info(f"[REEXTRACT_{field.upper()}] Processando p√°ginas: {pages_to_ocr}")
            
            texto_ocr = extract_ocr_from_specific_pages(pdf_path, pages_to_ocr, max_pages=6)
            
            if not texto_ocr:
                return None
            
            if field == 'pis':
                result = extract_pis(texto_ocr)
            else:
                result = extract_ctps(texto_ocr)
            
            if result:
                logger.info(f"[REEXTRACT_{field.upper()}] ‚úÖ Encontrado: {result}")
            return result
        
        else:
            logger.warning(f"[REEXTRACT] Campo n√£o suportado: {field}")
            return None
            
    except Exception as e:
        logger.error(f"[REEXTRACT] Erro ao processar {field}: {e}")
        return None


def reextract_missing_fields(
    process_id: int,
    pdf_path: str,
    existing_data: Optional[Dict[str, Any]] = None,
    fields_to_extract: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    Re-extrai campos cr√≠ticos faltantes de um processo via OCR seletivo.
    
    IMPORTANTE: Esta fun√ß√£o √© para uso MANUAL ou em lote separado.
    N√ÉO √© chamada automaticamente durante a extra√ß√£o inicial (para manter velocidade).
    
    Args:
        process_id: ID do processo no banco
        pdf_path: Caminho do PDF original
        existing_data: Dados j√° extra√≠dos (para identificar o que falta)
        fields_to_extract: Lista espec√≠fica de campos ou None para detectar automaticamente
    
    Returns:
        Dict com campos extra√≠dos via OCR
    """
    existing = existing_data or {}
    
    if fields_to_extract:
        missing = [f for f in fields_to_extract if f in CRITICAL_LABOR_FIELDS]
    else:
        missing = get_missing_critical_fields(existing)
    
    if not missing:
        logger.info(f"[REEXTRACT] Processo {process_id}: todos campos cr√≠ticos preenchidos")
        return {}
    
    logger.info(f"[REEXTRACT] Processo {process_id}: campos faltantes = {missing}")
    
    extracted = {}
    
    priority_order = ['salario', 'pis', 'ctps']
    for field in priority_order:
        if field in missing:
            value = reextract_field_with_ocr(pdf_path, field, existing)
            if value:
                extracted[field] = value
    
    if extracted:
        logger.info(f"[REEXTRACT] Processo {process_id}: recuperados {len(extracted)} campos via OCR")
    else:
        logger.info(f"[REEXTRACT] Processo {process_id}: nenhum campo recuperado via OCR")
    
    return extracted


def find_pdf_path(process, upload_folder: str) -> Optional[str]:
    """
    Encontra o caminho do PDF de um processo.
    
    Estrat√©gia de busca (ordem de prioridade):
    1. pdf_filename do Process se existir
    2. Buscar via BatchItem -> batch_id -> uploads/batch/<batch_id>/
    3. Buscar na pasta uploads/ por padr√£o do filename
    4. Glob patterns como fallback
    
    Returns:
        Caminho absoluto do PDF ou None
    """
    base_path = Path(upload_folder)
    
    if hasattr(process, 'pdf_filename') and process.pdf_filename:
        pdf_path = base_path / process.pdf_filename
        if pdf_path.exists():
            return str(pdf_path)
        
        for subdir in ['', 'batch']:
            subpath = base_path / subdir
            if subpath.exists():
                for batch_dir in subpath.iterdir():
                    if batch_dir.is_dir():
                        candidate = batch_dir / process.pdf_filename
                        if candidate.exists():
                            return str(candidate)
    
    try:
        from models import BatchItem
        batch_item = BatchItem.query.filter_by(process_id=process.id).first()
        if batch_item:
            batch_folder = base_path / 'batch' / str(batch_item.batch_id)
            if batch_folder.exists():
                for pdf_file in batch_folder.glob('*.pdf'):
                    if process.pdf_filename and process.pdf_filename in pdf_file.name:
                        return str(pdf_file)
                    pdfs = list(batch_folder.glob('*.pdf'))
                    if pdfs:
                        for pdf in pdfs:
                            if process.numero_processo and any(
                                part in pdf.name for part in process.numero_processo.replace('.', '-').replace('/', '-').split('-')[:3]
                            ):
                                return str(pdf)
    except Exception as e:
        logger.debug(f"[FIND_PDF] Erro ao buscar via BatchItem: {e}")
    
    patterns = []
    if hasattr(process, 'pdf_filename') and process.pdf_filename:
        patterns.append(f"**/{process.pdf_filename}")
    if process.numero_processo:
        cnj_parts = process.numero_processo.replace('.', '*').replace('-', '*').replace('/', '*')
        patterns.append(f"**/*{cnj_parts[:20]}*.pdf")
    
    for pattern in patterns:
        matches = list(base_path.glob(pattern))
        if matches:
            return str(matches[0])
    
    return None


def batch_reextract_missing(
    session,
    ProcessModel,
    upload_folder: str,
    limit: int = 50,
    fields: Optional[List[str]] = None,
    user_id: Optional[int] = None
) -> Dict[str, Any]:
    """
    Re-extra√ß√£o em lote de processos com campos cr√≠ticos vazios.
    
    FLUXO:
    1. Busca processos com campos vazios (sal√°rio, PIS, CTPS) do usu√°rio
    2. Para cada um, localiza o PDF via BatchItem ou padr√µes
    3. Aplica OCR seletivo nas p√°ginas relevantes
    4. Atualiza o banco de dados
    
    Args:
        session: Sess√£o SQLAlchemy
        ProcessModel: Classe do modelo Process
        upload_folder: Pasta onde os PDFs est√£o armazenados
        limit: M√°ximo de processos a processar
        fields: Campos espec√≠ficos ou None para todos cr√≠ticos
        user_id: ID do usu√°rio para escopo (obrigat√≥rio para seguran√ßa)
    
    Returns:
        Estat√≠sticas do processamento
    """
    from sqlalchemy import or_, and_
    
    target_fields = fields or CRITICAL_LABOR_FIELDS
    
    conditions = []
    for field in target_fields:
        col = getattr(ProcessModel, field, None)
        if col is not None:
            conditions.append(or_(col.is_(None), col == ""))
    
    if not conditions:
        return {"error": "Nenhum campo cr√≠tico encontrado no modelo"}
    
    query = session.query(ProcessModel).filter(
        or_(*conditions)
    )
    
    if user_id:
        query = query.filter(ProcessModel.user_id == user_id)
    
    query = query.order_by(ProcessModel.id.desc()).limit(limit)
    
    processes = query.all()
    
    stats = {
        'total_processados': 0,
        'campos_recuperados': 0,
        'por_campo': {f: {'tentativas': 0, 'sucesso': 0} for f in target_fields},
        'erros': 0,
        'pdfs_nao_encontrados': 0,
        'processos_atualizados': []
    }
    
    for proc in processes:
        try:
            pdf_path = find_pdf_path(proc, upload_folder)
            
            if not pdf_path or not Path(pdf_path).exists():
                stats['pdfs_nao_encontrados'] += 1
                logger.debug(f"[BATCH_REEXTRACT] PDF n√£o encontrado para processo {proc.id}")
                continue
            
            existing_data = {f: getattr(proc, f, "") for f in target_fields}
            missing = get_missing_critical_fields(existing_data)
            
            if not missing:
                continue
            
            stats['total_processados'] += 1
            
            extracted = reextract_missing_fields(
                process_id=proc.id,
                pdf_path=str(pdf_path),
                existing_data=existing_data,
                fields_to_extract=missing
            )
            
            if extracted:
                for field, value in extracted.items():
                    setattr(proc, field, value)
                    stats['campos_recuperados'] += 1
                    stats['por_campo'][field]['sucesso'] += 1
                
                session.commit()
                stats['processos_atualizados'].append(proc.id)
            
            for field in missing:
                stats['por_campo'][field]['tentativas'] += 1
                
        except Exception as e:
            logger.error(f"[BATCH_REEXTRACT] Erro no processo {proc.id}: {e}")
            stats['erros'] += 1
            session.rollback()
    
    logger.info(f"[BATCH_REEXTRACT] Conclu√≠do: {stats['total_processados']} processados, "
                f"{stats['campos_recuperados']} campos recuperados, "
                f"{stats['pdfs_nao_encontrados']} PDFs n√£o encontrados, "
                f"{stats['erros']} erros")
    
    return stats



================================================================================
FILE: utils/normalization.py
================================================================================
# utils/normalization.py
import re
from slugify import slugify

def normalize_text(s: str) -> str:
    if not s:
        return ""
    s = re.sub(r"\s+", " ", s).strip()
    return slugify(s, separator=" ")

def contains_any(text: str, *keywords: str) -> bool:
    t = normalize_text(text or "")
    return any(normalize_text(k) in t for k in keywords)



================================================================================
FILE: utils/cell_inference.py
================================================================================
# utils/cell_inference.py
from __future__ import annotations
from typing import List, Dict, Optional
import re
import os

# Tentamos importar os utilit√°rios do extrator; se n√£o houver, seguimos resilientes
try:
    from extractors.dictionary import load_dictionary_from_docx  # type: ignore
except Exception:
    def load_dictionary_from_docx(path: str) -> List[Dict[str, str]]:
        return []

try:
    from extractors.brand_map import detect_grupo  # type: ignore
except Exception:
    def detect_grupo(_: str) -> Optional[str]:
        return None

# Locais comuns do DOCX "CLIENTE X C√âLULA"
DEFAULT_DOCX_PATHS = [
    "CLIENTE X C√âLULA.docx",
    "CLIENTE X C√âLULA.DOCX",
    "data/CLIENTE X C√âLULA.docx",
    "data/CLIENTE X C√âLULA.DOCX",
]

def _norm(s: Optional[str]) -> str:
    return re.sub(r"\s+", " ", (s or "")).strip().upper()

def canonicalize_cell_label(label: Optional[str]) -> Optional[str]:
    """
    Normaliza r√≥tulos de c√©lula. Para o GPA (P√£o de A√ß√∫car / CBD / Sendas),
    padroniza como 'Trabalhista GPA'.
    """
    if not label:
        return None
    s = _norm(label)
    if re.search(r"\bGPA\b|P[√ÉA]O\s+DE\s+A[C√á]UCAR|CBD|SENDAS", s, re.I):
        return "Trabalhista GPA"
    return label.strip()

def load_alias_rows(paths: Optional[List[str]] = None) -> List[Dict[str, str]]:
    """
    Carrega as linhas do DOCX (CLIENTE / C√âLULA / PARTE INTERESSADA...), se existir.
    Retorna lista de dicts (vazia se arquivo n√£o existir).
    """
    rows: List[Dict[str, str]] = []
    for p in (paths or DEFAULT_DOCX_PATHS):
        try:
            if os.path.isfile(p):
                rows.extend(load_dictionary_from_docx(p))
        except Exception:
            continue
    return rows

def build_alias_index(rows: List[Dict[str, str]]) -> Dict[str, str]:
    """
    Constr√≥i um dicion√°rio {CLIENTE_NORMALIZADO -> C√âLULA_CAN√îNICA}.
    """
    idx: Dict[str, str] = {}
    for r in rows or []:
        client = _norm(r.get("CLIENTE") or r.get("Cliente") or r.get("cliente"))
        cell = r.get("C√âLULA") or r.get("Celula") or r.get("C√©lula") or r.get("celula")
        cell = canonicalize_cell_label(cell) or cell
        if client and cell:
            idx[client] = cell
    return idx

def guess_cell_from_pdf_text(text: str,
                             rows: Optional[List[Dict[str, str]]] = None,
                             default: Optional[str] = None) -> Optional[str]:
    """
    Adivinha a C√âLULA a partir do texto do PDF e do DOCX (se presente).
    1) Detecta grupo (GPA/CBD/Sendas) ‚Üí retorna mapeamento do DOCX se houver;
       caso contr√°rio, 'Trabalhista GPA'.
    2) Sem DOCX, usa heur√≠stica (men√ß√µes a P√£o de A√ß√∫car/GPA/CBD/Sendas).
    """
    up = _norm(text)

    # 1) Detecta grupo
    grp = detect_grupo(text) if callable(detect_grupo) else None

    # 2) Se tiver DOCX, tenta bater CLIENTE -> C√âLULA
    if rows is None:
        rows = load_alias_rows()
    idx = build_alias_index(rows)

    if grp and _norm(grp) in idx:
        return idx[_norm(grp)]

    # 3) Heur√≠stica robusta (sem DOCX)
    if re.search(r"\bGPA\b|P[√ÉA]O\s+DE\s+A[C√á]UCAR|COMPANHIA\s+BRASILEIRA\s+DE\s+DISTRIBU(I|√á)[C√á](A|√É)O|CBD|SENDAS", up, re.I):
        return "Trabalhista GPA"

    # 4) Default opcional
    return canonicalize_cell_label(default)

# ---------- Compatibilidade retroativa (nomes usados em vers√µes antigas) ----------

def decide_celula_from_sources(text: str,
                               cliente_grupo: Optional[str] = None,
                               rows: Optional[List[Dict[str, str]]] = None) -> Optional[str]:
    """
    Preferimos o mapeamento DOCX por 'CLIENTE' quando houver; sen√£o ca√≠mos na heur√≠stica do PDF.
    """
    if rows is None:
        rows = load_alias_rows()
    idx = build_alias_index(rows)

    if cliente_grupo:
        key = _norm(cliente_grupo)
        if key in idx:
            return idx[key]

    return guess_cell_from_pdf_text(text, rows=rows)

__all__ = [
    "load_alias_rows",
    "build_alias_index",
    "guess_cell_from_pdf_text",
    "decide_celula_from_sources",
    "canonicalize_cell_label",
]



================================================================================
FILE: utils/gap_filler.py
================================================================================
# utils/gap_filler.py
from typing import Dict, Any, List, Tuple, Optional
from rapidfuzz import fuzz
from .normalization import normalize_text, contains_any
from .option_catalog import load_catalog

def _pick_from_choices(text: str, choices: List[dict], prefer: Optional[List[str]] = None) -> Optional[str]:
    if not choices:
        return None
    if prefer:
        t = normalize_text(text or "")
        for p in prefer:
            pnorm = normalize_text(p)
            for c in choices:
                if pnorm in c["normalized"]:
                    return c["text"]
    candidates = [(c["text"], fuzz.token_set_ratio(normalize_text(text or ""), c["normalized"])) for c in choices]
    candidates.sort(key=lambda x: x[1], reverse=True)
    best = candidates[0] if candidates else None
    if best and best[1] >= 70:
        return best[0]
    return None

def _infer_instancia(text: str, cnj: Optional[str]) -> Optional[str]:
    if contains_any(text, "juizado especial", "vara", "tribunal", "trt", "tj", "trf", "2 grau", "segundo grau"):
        return "Judicial"
    return None

def gap_fill(data: Dict[str, Any], pdf_text: str) -> Tuple[Dict[str, Any], List[str], Dict[str, Any]]:
    needs, ev = [], {}
    txt = (pdf_text or "")[:30000]

    # Inst√¢ncia
    if not data.get("instancia"):
        val = _infer_instancia(txt, data.get("cnj"))
        if val:
            data["instancia"] = val
            ev["instancia"] = {"source": "rule", "value": val}
        else:
            needs.append("instancia")

    # Sistema Eletr√¥nico
    if not data.get("sistema_eletronico"):
        cat = load_catalog("SistemaEletronicoId")
        val = _pick_from_choices(txt, cat, prefer=["PJE", "Ju√≠zo 100% Digital", "Eproc", "Projudi", "EPROC"])
        if not val:
            val = "PJE"
            ev["sistema_eletronico"] = {"source": "default", "value": val}
        else:
            ev["sistema_eletronico"] = {"source": "catalog+match", "value": val}
        data["sistema_eletronico"] = val

    # √Årea do Direito
    if not data.get("area_direito") and not data.get("area"):
        cat = load_catalog("AreaDireitoId")
        val = _pick_from_choices(txt, cat, prefer=["C√≠vel", "Trabalhista", "Criminal", "Tribut√°rio", "Previdenci√°rio"])
        if val:
            data["area_direito"] = val
            ev["area_direito"] = {"source": "catalog+match", "value": val}
        else:
            data["area_direito"] = "C√≠vel"
            ev["area_direito"] = {"source": "default", "value": "C√≠vel"}

    # Assunto / Objeto / Tipo de A√ß√£o
    for field, catalog_name, fallback in [
        ("assunto", "AreaProcessoId", "INDEFINIDO"),
        ("objeto", "ClasseId", "INDEFINIDO"),
        ("tipo_acao", "TipoAcaoId", "INDEFINIDO"),
    ]:
        if not data.get(field):
            cat = load_catalog(catalog_name)
            val = _pick_from_choices(txt, cat)
            if val:
                data[field] = val
                ev[field] = {"source": "catalog+match", "value": val}
            else:
                data[field] = fallback
                ev[field] = {"source": "default", "value": fallback}
                needs.append(field)

    # √ìrg√£o / Foro (rascunho; o definitivo no RPA depende de UF/Cidade)
    if not data.get("orgao"):
        cat = load_catalog("NaturezaId")
        val = _pick_from_choices(txt, cat)
        if val:
            data["orgao"] = val
            ev["orgao"] = {"source": "catalog+match", "value": val}
        else:
            needs.append("orgao")

    if not data.get("foro"):
        needs.append("foro")

    # C√©lula (prefer√™ncia trabalhista)
    if not data.get("celula"):
        cat = load_catalog("EscritorioId")
        prefer = ["Trabalhista Outros Clientes"] if "trabalh" in normalize_text(data.get("area_direito", "")) else None
        val = _pick_from_choices(" ".join([txt, data.get("cliente", "")]), cat, prefer=prefer)
        if val:
            data["celula"] = val
            ev["celula"] = {"source": "catalog+match", "value": val}
        else:
            data["celula"] = "Em Segredo"
            ev["celula"] = {"source": "default", "value": "Em Segredo"}
            needs.append("celula")

    return data, needs, ev



================================================================================
FILE: utils/jur_extraction.py
================================================================================
# utils/jur_extraction.py
# Corrige a invers√£o Parte Interessada/Adversa e enriquece campos a partir do PDF

import re, json, unicodedata
from typing import Dict, Any

def _norm(s:str)->str:
    s=(s or "").strip().lower()
    s=unicodedata.normalize("NFD", s)
    return "".join(ch for ch in s if unicodedata.category(ch)!="Mn")

def _any_in(text:str, words):
    s=_norm(text)
    return any(_norm(w) in s for w in words)

def _extract_valor_causa(pdf_text:str)->str:
    import re
    m = re.search(r"valor\s+da\s+causa\s*[:\-]?\s*(?:R?\$)?\s*([0-9\.\,]{3,})", pdf_text, re.I)
    if not m: return ""
    return _money_br_to_field(m.group(1))

def _money_br_to_field(s:str)->str:
    s=(s or "").strip()
    if not s: return s
    raw=re.sub(r"[^\d,\.]","",s)
    if re.match(r"^\d{1,3}(\.\d{3})*,\d{2}$", raw):
        return raw
    if "," in raw and "." in raw and raw.rfind(".") > raw.rfind(","):
        number = raw.replace(",", "").replace(".", ",")
    elif "," in raw and "." not in raw:
        integer, cents = raw.split(",")[0], raw.split(",")[1]
        integer = integer[::-1]
        groups = ".".join([integer[i:i+3] for i in range(0, len(integer), 3)])[::-1]
        number = f"{groups},{cents[:2].ljust(2,'0')}"
    elif "." in raw and "," not in raw:
        integer, cents = raw.split(".")[0], raw.split(".")[1]
        integer = integer[::-1]
        groups = ".".join([integer[i:i+3] for i in range(0, len(integer), 3)])[::-1]
        number = f"{groups},{cents[:2].ljust(2,'0')}"
    else:
        if len(raw) <=2:
            number=f"0,{raw.zfill(2)}"
        else:
            integer, cents = raw[:-2], raw[-2:]
            integer=integer[::-1]
            groups=".".join([integer[i:i+3] for i in range(0,len(integer),3)])[::-1]
            number=f"{groups},{cents}"
    return number

def _extract_partes_trabalhista(pdf_text:str)->Dict[str,str]:
    out={}
    for lab in ["RECLAMANTE", "RECLAMADO", "RECLAMADA"]:
        m = re.search(rf"{lab}\s*[:\-]\s*(.+?)(?:\n|$)", pdf_text, re.I)
        if m:
            out[lab.lower()] = m.group(1).strip()
    return {
        "reclamante": out.get("reclamante",""),
        "reclamado": out.get("reclamado","") or out.get("reclamada",""),
    }

def _looks_company(name:str, bag:str)->bool:
    if _any_in(name, ["ltda","s/a","s.a","sa ","eireli","epp","me ","companhia","cooperativa","funda√ß√£o","banco","associa√ß√£o","prefeitura","munic√≠pio","uni√£o","estado","instituto"]):
        return True
    if re.search(r"\b\d{2}\.\d{3}\.\d{3}/\d{4}-\d{2}\b", bag):  # CNPJ
        return True
    return False

def _guess_tipo_pessoa_adversa(adverso_nome:str, bag:str)->str:
    if _looks_company(adverso_nome, bag): return "JURIDICA"
    if re.search(r"\b\d{3}\.\d{3}\.\d{3}-\d{2}\b", bag): return "FISICA"
    if len(_norm(adverso_nome).split())>=2 and not _looks_company(adverso_nome, adverso_nome): return "FISICA"
    return "FISICA"

def smart_enrich_data(data:Dict[str,Any], pdf_text:str)->Dict[str,Any]:
    out=dict(data)
    partes=_extract_partes_trabalhista(pdf_text)

    # Interessada=seu cliente (empresa) ‚Üí preferir RECLAMADO
    if partes.get("reclamado"):
        out.setdefault("parte_interessada", partes["reclamado"])
        out.setdefault("cliente", partes["reclamado"])
        out.setdefault("empresa", partes["reclamado"])
    if partes.get("reclamante"):
        out.setdefault("parte_adversa", partes["reclamante"])
        out.setdefault("adverso_nome", partes["reclamante"])

    # Grupo (GPA etc.)
    bag = json.dumps(out, ensure_ascii=False) + "\n" + pdf_text
    for key,label in {
        "gpa":"Grupo P√£o de A√ß√∫car", "grupo pao de acucar":"Grupo P√£o de A√ß√∫car",
        "pao de acucar":"Grupo P√£o de A√ß√∫car", "companhia brasileira de distribuicao":"Grupo P√£o de A√ß√∫car",
        "sendas distribuidora":"Grupo P√£o de A√ß√∫car",
    }.items():
        if key in _norm(bag):
            out.setdefault("grupo", label); break

    # Tipo pessoa adversa
    if not out.get("tipo_pessoa_adversa"):
        out["tipo_pessoa_adversa"] = _guess_tipo_pessoa_adversa(out.get("parte_adversa","") or out.get("adverso_nome",""), bag)

    # Posi√ß√£o parte interessada
    if not out.get("posicao_parte_interessada"):
        if partes.get("reclamado") and _any_in(out.get("parte_interessada","")+out.get("cliente",""), [partes["reclamado"]]):
            out["posicao_parte_interessada"] = "RECLAMADO"
        elif partes.get("reclamante"):
            out["posicao_parte_interessada"] = "RECLAMANTE"

    # Valor da Causa
    if not out.get("valor_causa"):
        vc=_extract_valor_causa(pdf_text)
        if vc: out["valor_causa"]=vc

    # Tipo de A√ß√£o: prioriza sub_area_direito e assunto
    if not out.get("tipo_acao"):
        cand = (out.get("sub_area_direito") or "").strip() or (out.get("assunto") or "").strip()
        out["tipo_acao"]=cand

    return out



================================================================================
FILE: utils/option_catalog.py
================================================================================
# utils/option_catalog.py
import json
from pathlib import Path
from typing import List, Dict, Any
from .normalization import normalize_text

CATALOG_DIR = Path("static/option_catalog")
CATALOG_DIR.mkdir(parents=True, exist_ok=True)

def load_catalog(name: str) -> List[Dict[str, Any]]:
    f = CATALOG_DIR / f"{name}.json"
    if not f.exists():
        return []
    data = json.loads(f.read_text(encoding="utf-8"))
    for d in data:
        d["normalized"] = normalize_text(d.get("text", ""))
    return data

def save_catalog(name: str, options: List[Dict[str, Any]]) -> None:
    for o in options:
        o["normalized"] = normalize_text(o.get("text", ""))
    f = CATALOG_DIR / f"{name}.json"
    f.write_text(json.dumps(options, ensure_ascii=False, indent=2), encoding="utf-8")



================================================================================
FILE: data/clientes_database.json
================================================================================
{
  "clientes": {
    "Smart RJ": {
      "nome_cliente": "Smart RJ",
      "partes": [
        "Smart RJ Concession√°ria de Ilumina√ß√£o P√∫blica SPE"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "Premio": {
      "nome_cliente": "Premio",
      "partes": [
        "Premio Empreend.Imobiliarios Ltda.",
        "SPE19 Global Premio Recanto Verde Empreendimentos Imobiliarios S.A",
        "SPE 23 Global Premio Bora Itabora√≠ Suites Empreendimentos S/A",
        "Premio Construtora Ltda",
        "Casa Gabizo Empreendimentos Imobili√°rios Ltda",
        "Cons√≥rcio De Constru√ß√£o Nurban",
        "Clube Arete B√∫zios",
        "CA92 Empreendimento Imobili√°rio Ltda"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "MP Incorporadora": {
      "nome_cliente": "MP Incorporadora",
      "partes": [
        "Jardim Imperial II Constru√ß√µes e Incorpora√ß√µes SPE Ltda",
        "Liberty Arraial Do Cabo Construcoes e Incorporacoes Spe Ltda",
        "M&P Construtora e Incorporadora Ltda",
        "Murta Construtora Eireli"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "HAZTEC": {
      "nome_cliente": "HAZTEC",
      "partes": [
        "Central De Tratamento De Residuos Alcantara",
        "Central De Tratamento De Res√≠duos Barra Mansa S/A",
        "Central De Tratamento De Res√≠duos De Nova Igua√ß√∫ S/A - Ctr",
        "Ecopesa Ambiental S.A.",
        "ETR JARDIM GRAMACHO S/A",
        "FOXX URE-JP AMBIENTAL S.A",
        "HAZTEC INVESTIMENTOS E PARTICIPA√á√ïES S/A",
        "METROPOLITANA SERVI√áOS AMBIENTAIS LTDA",
        "ORIZON MEIO AMBIENTE S.A.",
        "Orizon Valorizacao de Residuos S.A",
        "Rosario do Catete Ambiental Sociedade An√¥nima",
        "SPE Macei√≥ Ambiental S/A",
        "UTM Jaboatao dos Guararapes Ltda"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "GRUPO VIA√á√ÉO AGULHAS NEGRAS": {
      "nome_cliente": "GRUPO VIA√á√ÉO AGULHAS NEGRAS",
      "partes": [
        "VIA√á√ÉO PINHEIRAL LTDA",
        "VIA√á√ÉO PARAISO LTDA",
        "VIA√á√ÉO AGULHAS NEGRAS LTDA",
        "AUTO COMERCIAL TUPI LTDA",
        "MANEJO TRANSPORTE TURISMO LTDA - FALIDA"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "GRUPO PEIXOTO CASTRO": {
      "nome_cliente": "GRUPO PEIXOTO CASTRO",
      "partes": [
        "APOLO TUBOS E EQUIPAMENTOS S/A",
        "APOLO PRODUTOS DE ACO S.A (GPC)",
        "GPC PARTICIPA√á√ïES S/A",
        "GPC QU√çMICA S/A"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "GRUPO KPFR": {
      "nome_cliente": "GRUPO KPFR",
      "partes": [
        "CONSTRUGAR CONSTRUTORA LTDA",
        "ENGENHARIA BRAVO LTDA - ME",
        "FERREIRA NASCIMENTO CONSTRU√á√ÉO CIVIL LTDA",
        "FRAN√áA 2005 SERVI√áOS DE APOIO E MANUT. LTDA-ME",
        "HF GRUPO HOTELEIRO LTDA",
        "HOTEL DO FRADE S/A",
        "KP PARTICIPACOES LTDA",
        "KPFR PARTICIPA√á√ïES E EMPREENDIMENTOS S/A",
        "POLO CAPITAL REAL ESTATE GEST√ÉO DE RECURSOS LTDA"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "Grupo EBX": {
      "nome_cliente": "Grupo EBX",
      "partes": [
        "AVX T√ÅXI A√âREO LTDA",
        "EBX BRASIL S.A",
        "EBX HOLDING LTDA",
        "EIKE FUHRKEN BATISTA",
        "IKOS CAPITAL MANAGEMENT S.A",
        "MD.X BARRA MEDICAL CENTER LTDA",
        "MMX SUDESTE MINERA√á√ÉO S.A.",
        "SIX SOLU√á√ïES INTELIGENTES S.A.",
        "XHOW ALIMENTOS LTDA"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "EDITORA J.P.A.": {
      "nome_cliente": "EDITORA J.P.A.",
      "partes": [
        "EDITORA ROCCO LTDA"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "CNS": {
      "nome_cliente": "CNS",
      "partes": [
        "ATTIMO SERVICOS LTDA",
        "Bergmar Servicos Eireli",
        "CNS NACIONAL DE SERVICOS LTDA",
        "MARBERG  SERVI√áOS  EIRELI",
        "Topix Servicos Ltda",
        "VIDYA SERVICOS LTDA"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "CIMENTO TUPI": {
      "nome_cliente": "CIMENTO TUPI",
      "partes": [
        "CIMENTO TUPI S/A. EM RECUPERA√á√ÉO JUDICIAL",
        "SANTO AMERICO EMPREENDIMENTOS E PARTICIPACOES LTDA",
        "TCG TRANSPORTADORA DE CARGAS EM GERAL EIRELI",
        "TUPIMEC INDUSTRIA MECANICA LTDA"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "CESTE": {
      "nome_cliente": "CESTE",
      "partes": [
        "CESTE-CONS.EST.ENERG.USINA HID.EST."
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "CARVALHO HOSKEN": {
      "nome_cliente": "CARVALHO HOSKEN",
      "partes": [
        "CARVALHO HOSKEN S/A ENG.CONSTRUCOES"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "Car Care": {
      "nome_cliente": "Car Care",
      "partes": [
        "Car Care Servicos Automotivos Ltda - ME"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "CAMARGOS GIOSTRI (LILLA HUCK OTRANTO CAMARGO)": {
      "nome_cliente": "CAMARGOS GIOSTRI (LILLA HUCK OTRANTO CAMARGO)",
      "partes": [
        "GE ENERGY DO BRASIL LTDA",
        "BANCO GE CAPITAL S/A"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "BANCO MORADA": {
      "nome_cliente": "BANCO MORADA",
      "partes": [
        "MORADA INVESTIMENTOS S/A"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "Alma Mater Educa√ß√£o LTDA": {
      "nome_cliente": "Alma Mater Educa√ß√£o LTDA",
      "partes": [
        "Alma Mater Educa√ß√£o LTDA"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "ADALMA PARTICIPACAO": {
      "nome_cliente": "ADALMA PARTICIPACAO",
      "partes": [
        "ADALMA PARTICIP.EMPREEND.IMOB.LTDA."
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "SEM GRUPO": {
      "nome_cliente": "SEM GRUPO",
      "partes": [
        "ACADEMIA PURI (BFC ACADEMIAS DE GIN√ÅTICA EIRELI)",
        "BANCO INTER S/A",
        "Bibas Clinica de Servicos Medicos Ltda",
        "BRL TECNOLOGIA LTDA",
        "CAF√â DE PARIS BAR E RESTAURANTE EIRELI EPP",
        "CAPITAL HUMANO TECNOL. E TREIN.LTDA",
        "CIA ESTADUAL DE AGUAS E ESGOTOS ..",
        "DBR ENERGIES (DORIS ENGENHARIA)",
        "TERMO NORTE ENERGIA S/A",
        "PERCAP IPIIBA ADM. E PARTICIPA√á√ïES LTDA"
      ],
      "celula": "Trabalhista Outros Clientes"
    },
    "Profarma": {
      "nome_cliente": "Profarma",
      "partes": [
        "DROGARIA CIPRIANO DE SANTA ROSA LTDA",
        "CONECTFARMA MARKETING E CALL CENTER LTDA",
        "CSB DROGARIAS S/A",
        "D1000 VAREJO FARMA PARTICIPA√á√ïES S.A.",
        "D N PERFUMARIA LTDA",
        "D‚ÄôOCEANIC DE ITAIPU DROGARIA LTDA",
        "DROGARIA CENTRAL DE ITAIPU LTDA",
        "FLORESCER FARMACIA LTDA",
        "DROGARIA F.V. DE ICARAI LTDA",
        "DROGARIA ITAMARATY LTDA",
        "DROGARIA MATER LTDA",
        "DROGARIA MG DE ITABORAI LTDA",
        "DROGARIA NAVARRO DE NITER√ìI LTDA",
        "DROGARIA PRAIANA DE CHARITAS LTDA",
        "DROGARIA PREDILETA LTDA",
        "DROGARIA REAL DE ICARA√ç LTDA",
        "DROGARIA ROB GON√áALENSE LTDA",
        "DROGARIA ROF LTDA",
        "DROGARIA DO ROS√ÅRIO LTDA",
        "DROGARIA ULTRAFARMA DE ICARA√ç LTDA",
        "DROGARIA UNI√ÉO DO ALC√ÇNTARA LTDA",
        "DROGARIA V.R. GON√áALENSE LTDA",
        "FARMA GEN√âRICO DROGARIA E PERFUMARIA LTDA",
        "FARM√ÅCIA S√ÉO SEBASTI√ÉO LTDA",
        "INSTITUTO PROFARMA DE RESPONSABILIDADE SOCIAL",
        "LARGO DO PA√áO DROGARIA LTDA",
        "NOVA DROGARIA TAMOIO LTDA",
        "PROFARMA DISTRIBUIDORA DE PRODUTOS FARMAC√äUTICOS S/A",
        "SUFAR SUPER MERCADO FARMAC√äUTICO LTDA"
      ],
      "celula": "Trabalhista Pro Pharma"
    },
    "PRUDENTIAL": {
      "nome_cliente": "PRUDENTIAL",
      "partes": [
        "PRUDENTIAL DO BRASIL SEGUROS DE VIDA S.A."
      ],
      "celula": "Trabalhista Prudential"
    },
    "Grupo P√£o de a√ß√∫car": {
      "nome_cliente": "Grupo P√£o de a√ß√∫car",
      "partes": [
        "COMPANHIA BRASILEIRA DE DISTRIBUI√á√ÉO",
        "SENDAS DISTRIBUIDORA S/A"
      ],
      "celula": "Trabalhista GPA"
    },
    "CSN": {
      "nome_cliente": "CSN",
      "partes": [
        "CBSI ‚Äì COMPANHIA BRASILEIRA DE SERVI√áOS E INFRAESTRUTURA",
        "COMPANHIA METALURGICA PRADA",
        "CSN ‚Äì COMPANHIA SIDERURGICA NACIONAL",
        "CSN CIMENTOS BRASIL S/A",
        "CSN MINERA√á√ÉO S.A.",
        "SEPETIBA TECON S.A.",
        "FUNDA√á√ÉO CSN"
      ],
      "celula": "Trabalhista CSN"
    },
    "Casas Bahia": {
      "nome_cliente": "Casas Bahia",
      "partes": [
        "GRUPO CASAS BAHIA S.A",
        "CNOVA COM√âRCIO ELETRONICO",
        "GLOBEX ADMINISTRA√á√ÉO E SERVI√áOS LTDA",
        "GLOBEX ADMINISTRADORA DE CONSORCIOS LTDA",
        "ASAP LOG ‚Äì LOGISTICA E SOLU√á√ïES LTDA",
        "INDUSTRIA DE MOVEIS BARTIRA LTDA",
        "LAKE NIASSA EMPREENDIMENTOS E PARTICIPA√á√ïES LTDA",
        "CASAS BAHIA TECNOLOGIA LTDA",
        "CNT SOLU√á√ïES EM NEGOCIOS DIGITAIS E LOGISTICA LTDA",
        "CNT LOG EXPRESS LOGISTICA E TRANSPORTE LTDA",
        "INTEGRA SOLU√á√ïES PARA VAREJO DIGITAL LTDA",
        "ASAP LOG LTDA",
        "BANQI CART√ïES INSTITUI√á√ÉO DE PAGAMENTO LTDA",
        "BANQI SOCIEDADE DE CREDITO FINANCIAMENTO E INVESTIMENTO S.A.",
        "BANQI INSTRIUI√á√ÉO DE PAGAMENTO LTDA",
        "CELER PROCESSAMENTO COMERCIO E SERVI√áO LTDA"
      ],
      "celula": "Trabalhista Casas Bahia"
    }
  },
  "partes_interessadas": [
    {
      "nome": "Smart RJ Concession√°ria de Ilumina√ß√£o P√∫blica SPE",
      "cliente": "Smart RJ",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Premio Empreend.Imobiliarios Ltda.",
      "cliente": "Premio",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "SPE19 Global Premio Recanto Verde Empreendimentos Imobiliarios S.A",
      "cliente": "Premio",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "SPE 23 Global Premio Bora Itabora√≠ Suites Empreendimentos S/A",
      "cliente": "Premio",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Premio Construtora Ltda",
      "cliente": "Premio",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Casa Gabizo Empreendimentos Imobili√°rios Ltda",
      "cliente": "Premio",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Cons√≥rcio De Constru√ß√£o Nurban",
      "cliente": "Premio",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Clube Arete B√∫zios",
      "cliente": "Premio",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CA92 Empreendimento Imobili√°rio Ltda",
      "cliente": "Premio",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Jardim Imperial II Constru√ß√µes e Incorpora√ß√µes SPE Ltda",
      "cliente": "MP Incorporadora",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Liberty Arraial Do Cabo Construcoes e Incorporacoes Spe Ltda",
      "cliente": "MP Incorporadora",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "M&P Construtora e Incorporadora Ltda",
      "cliente": "MP Incorporadora",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Murta Construtora Eireli",
      "cliente": "MP Incorporadora",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Central De Tratamento De Residuos Alcantara",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Central De Tratamento De Res√≠duos Barra Mansa S/A",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Central De Tratamento De Res√≠duos De Nova Igua√ß√∫ S/A - Ctr",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Ecopesa Ambiental S.A.",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "ETR JARDIM GRAMACHO S/A",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "FOXX URE-JP AMBIENTAL S.A",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "HAZTEC INVESTIMENTOS E PARTICIPA√á√ïES S/A",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "METROPOLITANA SERVI√áOS AMBIENTAIS LTDA",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "ORIZON MEIO AMBIENTE S.A.",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Orizon Valorizacao de Residuos S.A",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Rosario do Catete Ambiental Sociedade An√¥nima",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "SPE Macei√≥ Ambiental S/A",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "UTM Jaboatao dos Guararapes Ltda",
      "cliente": "HAZTEC",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "VIA√á√ÉO PINHEIRAL LTDA",
      "cliente": "GRUPO VIA√á√ÉO AGULHAS NEGRAS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "VIA√á√ÉO PARAISO LTDA",
      "cliente": "GRUPO VIA√á√ÉO AGULHAS NEGRAS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "VIA√á√ÉO AGULHAS NEGRAS LTDA",
      "cliente": "GRUPO VIA√á√ÉO AGULHAS NEGRAS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "AUTO COMERCIAL TUPI LTDA",
      "cliente": "GRUPO VIA√á√ÉO AGULHAS NEGRAS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "MANEJO TRANSPORTE TURISMO LTDA - FALIDA",
      "cliente": "GRUPO VIA√á√ÉO AGULHAS NEGRAS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "APOLO TUBOS E EQUIPAMENTOS S/A",
      "cliente": "GRUPO PEIXOTO CASTRO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "APOLO PRODUTOS DE ACO S.A (GPC)",
      "cliente": "GRUPO PEIXOTO CASTRO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "GPC PARTICIPA√á√ïES S/A",
      "cliente": "GRUPO PEIXOTO CASTRO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "GPC QU√çMICA S/A",
      "cliente": "GRUPO PEIXOTO CASTRO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CONSTRUGAR CONSTRUTORA LTDA",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "ENGENHARIA BRAVO LTDA - ME",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "FERREIRA NASCIMENTO CONSTRU√á√ÉO CIVIL LTDA",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "FRAN√áA 2005 SERVI√áOS DE APOIO E MANUT. LTDA-ME",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "HF GRUPO HOTELEIRO LTDA",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "HOTEL DO FRADE S/A",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "KP PARTICIPACOES LTDA",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "KPFR PARTICIPA√á√ïES E EMPREENDIMENTOS S/A",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "POLO CAPITAL REAL ESTATE GEST√ÉO DE RECURSOS LTDA",
      "cliente": "GRUPO KPFR",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "AVX T√ÅXI A√âREO LTDA",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "EBX BRASIL S.A",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "EBX HOLDING LTDA",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "EIKE FUHRKEN BATISTA",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "IKOS CAPITAL MANAGEMENT S.A",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "MD.X BARRA MEDICAL CENTER LTDA",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "MMX SUDESTE MINERA√á√ÉO S.A.",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "SIX SOLU√á√ïES INTELIGENTES S.A.",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "XHOW ALIMENTOS LTDA",
      "cliente": "Grupo EBX",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "EDITORA ROCCO LTDA",
      "cliente": "EDITORA J.P.A.",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "ATTIMO SERVICOS LTDA",
      "cliente": "CNS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Bergmar Servicos Eireli",
      "cliente": "CNS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CNS NACIONAL DE SERVICOS LTDA",
      "cliente": "CNS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "MARBERG  SERVI√áOS  EIRELI",
      "cliente": "CNS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Topix Servicos Ltda",
      "cliente": "CNS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "VIDYA SERVICOS LTDA",
      "cliente": "CNS",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CIMENTO TUPI S/A. EM RECUPERA√á√ÉO JUDICIAL",
      "cliente": "CIMENTO TUPI",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "SANTO AMERICO EMPREENDIMENTOS E PARTICIPACOES LTDA",
      "cliente": "CIMENTO TUPI",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "TCG TRANSPORTADORA DE CARGAS EM GERAL EIRELI",
      "cliente": "CIMENTO TUPI",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "TUPIMEC INDUSTRIA MECANICA LTDA",
      "cliente": "CIMENTO TUPI",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CESTE-CONS.EST.ENERG.USINA HID.EST.",
      "cliente": "CESTE",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CARVALHO HOSKEN S/A ENG.CONSTRUCOES",
      "cliente": "CARVALHO HOSKEN",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Car Care Servicos Automotivos Ltda - ME",
      "cliente": "Car Care",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "GE ENERGY DO BRASIL LTDA",
      "cliente": "CAMARGOS GIOSTRI (LILLA HUCK OTRANTO CAMARGO)",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "BANCO GE CAPITAL S/A",
      "cliente": "CAMARGOS GIOSTRI (LILLA HUCK OTRANTO CAMARGO)",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "MORADA INVESTIMENTOS S/A",
      "cliente": "BANCO MORADA",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Alma Mater Educa√ß√£o LTDA",
      "cliente": "Alma Mater Educa√ß√£o LTDA",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "ADALMA PARTICIP.EMPREEND.IMOB.LTDA.",
      "cliente": "ADALMA PARTICIPACAO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "ACADEMIA PURI (BFC ACADEMIAS DE GIN√ÅTICA EIRELI)",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "BANCO INTER S/A",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "Bibas Clinica de Servicos Medicos Ltda",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "BRL TECNOLOGIA LTDA",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CAF√â DE PARIS BAR E RESTAURANTE EIRELI EPP",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CAPITAL HUMANO TECNOL. E TREIN.LTDA",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "CIA ESTADUAL DE AGUAS E ESGOTOS ..",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "DBR ENERGIES (DORIS ENGENHARIA)",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "TERMO NORTE ENERGIA S/A",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "PERCAP IPIIBA ADM. E PARTICIPA√á√ïES LTDA",
      "cliente": "SEM GRUPO",
      "celula": "Trabalhistas Outros clientes"
    },
    {
      "nome": "DROGARIA CIPRIANO DE SANTA ROSA LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "CONECTFARMA MARKETING E CALL CENTER LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "CSB DROGARIAS S/A",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "D1000 VAREJO FARMA PARTICIPA√á√ïES S.A.",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "D N PERFUMARIA LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "D‚ÄôOCEANIC DE ITAIPU DROGARIA LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA CENTRAL DE ITAIPU LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "FLORESCER FARMACIA LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA F.V. DE ICARAI LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA ITAMARATY LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA MATER LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA MG DE ITABORAI LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA NAVARRO DE NITER√ìI LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA PRAIANA DE CHARITAS LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA PREDILETA LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA REAL DE ICARA√ç LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA ROB GON√áALENSE LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA ROF LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA DO ROS√ÅRIO LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA ULTRAFARMA DE ICARA√ç LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA UNI√ÉO DO ALC√ÇNTARA LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "DROGARIA V.R. GON√áALENSE LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "FARMA GEN√âRICO DROGARIA E PERFUMARIA LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "FARM√ÅCIA S√ÉO SEBASTI√ÉO LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "INSTITUTO PROFARMA DE RESPONSABILIDADE SOCIAL",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "LARGO DO PA√áO DROGARIA LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "NOVA DROGARIA TAMOIO LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "PROFARMA DISTRIBUIDORA DE PRODUTOS FARMAC√äUTICOS S/A",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "SUFAR SUPER MERCADO FARMAC√äUTICO LTDA",
      "cliente": "Profarma",
      "celula": "Trabalhistas Pro Pharma"
    },
    {
      "nome": "PRUDENTIAL DO BRASIL SEGUROS DE VIDA S.A.",
      "cliente": "PRUDENTIAL",
      "celula": "Trabalhistas Prudential"
    },
    {
      "nome": "COMPANHIA BRASILEIRA DE DISTRIBUI√á√ÉO",
      "cliente": "Grupo P√£o de a√ß√∫car",
      "celula": "Trabalhistas GPA"
    },
    {
      "nome": "SENDAS DISTRIBUIDORA S/A",
      "cliente": "Grupo P√£o de a√ß√∫car",
      "celula": "Trabalhistas GPA"
    },
    {
      "nome": "CBSI ‚Äì COMPANHIA BRASILEIRA DE SERVI√áOS E INFRAESTRUTURA",
      "cliente": "CSN",
      "celula": "Trabalhistas CSN"
    },
    {
      "nome": "COMPANHIA METALURGICA PRADA",
      "cliente": "CSN",
      "celula": "Trabalhistas CSN"
    },
    {
      "nome": "CSN ‚Äì COMPANHIA SIDERURGICA NACIONAL",
      "cliente": "CSN",
      "celula": "Trabalhistas CSN"
    },
    {
      "nome": "CSN CIMENTOS BRASIL S/A",
      "cliente": "CSN",
      "celula": "Trabalhistas CSN"
    },
    {
      "nome": "CSN MINERA√á√ÉO S.A.",
      "cliente": "CSN",
      "celula": "Trabalhistas CSN"
    },
    {
      "nome": "SEPETIBA TECON S.A.",
      "cliente": "CSN",
      "celula": "Trabalhistas CSN"
    },
    {
      "nome": "FUNDA√á√ÉO CSN",
      "cliente": "CSN",
      "celula": "Trabalhistas CSN"
    },
    {
      "nome": "GRUPO CASAS BAHIA S.A",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "CNOVA COM√âRCIO ELETRONICO",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "GLOBEX ADMINISTRA√á√ÉO E SERVI√áOS LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "GLOBEX ADMINISTRADORA DE CONSORCIOS LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "ASAP LOG ‚Äì LOGISTICA E SOLU√á√ïES LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "INDUSTRIA DE MOVEIS BARTIRA LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "LAKE NIASSA EMPREENDIMENTOS E PARTICIPA√á√ïES LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "CASAS BAHIA TECNOLOGIA LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "CNT SOLU√á√ïES EM NEGOCIOS DIGITAIS E LOGISTICA LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "CNT LOG EXPRESS LOGISTICA E TRANSPORTE LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "INTEGRA SOLU√á√ïES PARA VAREJO DIGITAL LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "ASAP LOG LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "BANQI CART√ïES INSTITUI√á√ÉO DE PAGAMENTO LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "BANQI SOCIEDADE DE CREDITO FINANCIAMENTO E INVESTIMENTO S.A.",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "BANQI INSTRIUI√á√ÉO DE PAGAMENTO LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    },
    {
      "nome": "CELER PROCESSAMENTO COMERCIO E SERVI√áO LTDA",
      "cliente": "Casas Bahia",
      "celula": "Trabalhistas Casas Bahia"
    }
  ],
  "celulas": {}
}


================================================================================
FILE: data/actors.json
================================================================================



================================================================================
FILE: data/elaw_tipos_pedidos.json
================================================================================
[
  {
    "value": "11484",
    "text": "Inconstitucionalidade do art.790",
    "text_lower": "inconstitucionalidade do art.790"
  },
  {
    "value": "11571",
    "text": "0100328-84.2024.5.01.0343",
    "text_lower": "0100328-84.2024.5.01.0343"
  },
  {
    "value": "149",
    "text": "Abono Assiduidade",
    "text_lower": "abono assiduidade"
  },
  {
    "value": "150",
    "text": "Abono Conven√ß√£o",
    "text_lower": "abono conven√ß√£o"
  },
  {
    "value": "534",
    "text": "ABONO PECUNI√ÅRIO",
    "text_lower": "abono pecuni√°rio"
  },
  {
    "value": "189",
    "text": "A√ß√£o Anulat√≥ria",
    "text_lower": "a√ß√£o anulat√≥ria"
  },
  {
    "value": "128",
    "text": "A√ß√£o Rescis√≥ria",
    "text_lower": "a√ß√£o rescis√≥ria"
  },
  {
    "value": "108",
    "text": "Acidentes Pessoais Passageiro",
    "text_lower": "acidentes pessoais passageiro"
  },
  {
    "value": "11510",
    "text": "Acolhimento do tempo para aposentadoria especial",
    "text_lower": "acolhimento do tempo para aposentadoria especial"
  },
  {
    "value": "366",
    "text": "ACORDO",
    "text_lower": "acordo"
  },
  {
    "value": "635",
    "text": "Acordo coletivo",
    "text_lower": "acordo coletivo"
  },
  {
    "value": "447",
    "text": "ACR√âSCIMO SALARIAL",
    "text_lower": "acr√©scimo salarial"
  },
  {
    "value": "11377",
    "text": "Ac√∫mulo de fun√ß√µes",
    "text_lower": "ac√∫mulo de fun√ß√µes"
  },
  {
    "value": "11378",
    "text": "Adicional de assiduidade",
    "text_lower": "adicional de assiduidade"
  },
  {
    "value": "132",
    "text": "Adicional de Dupla Fun√ß√£o",
    "text_lower": "adicional de dupla fun√ß√£o"
  },
  {
    "value": "153",
    "text": "Adicional de Insalubridade",
    "text_lower": "adicional de insalubridade"
  },
  {
    "value": "11379",
    "text": "adicional de insalubridade diferen√ßa",
    "text_lower": "adicional de insalubridade diferen√ßa"
  },
  {
    "value": "11380",
    "text": "adicional de insalubridade integra√ß√£o",
    "text_lower": "adicional de insalubridade integra√ß√£o"
  },
  {
    "value": "11568",
    "text": "Adicional de inspe√ß√£o e fiscaliza√ß√£o de produtos",
    "text_lower": "adicional de inspe√ß√£o e fiscaliza√ß√£o de produtos"
  },
  {
    "value": "11381",
    "text": "adicional de periculosidade",
    "text_lower": "adicional de periculosidade"
  },
  {
    "value": "133",
    "text": "Adicional de Periculosidade - Tanque de Combust√≠vel",
    "text_lower": "adicional de periculosidade - tanque de combust√≠vel"
  },
  {
    "value": "11382",
    "text": "adicional de periculosidade diferen√ßa",
    "text_lower": "adicional de periculosidade diferen√ßa"
  },
  {
    "value": "11383",
    "text": "adicional de periculosidade integra√ß√£o",
    "text_lower": "adicional de periculosidade integra√ß√£o"
  },
  {
    "value": "291",
    "text": "ADICIONAL DE QUEBRA DE CAIXA",
    "text_lower": "adicional de quebra de caixa"
  },
  {
    "value": "11555",
    "text": "Adicional de risco",
    "text_lower": "adicional de risco"
  },
  {
    "value": "11534",
    "text": "Adicional de transfer√™ncia",
    "text_lower": "adicional de transfer√™ncia"
  },
  {
    "value": "134",
    "text": "Adicional Noturno",
    "text_lower": "adicional noturno"
  },
  {
    "value": "11384",
    "text": "Adicional por tempo de servi√ßo",
    "text_lower": "adicional por tempo de servi√ßo"
  },
  {
    "value": "11385",
    "text": "Adicional por tempo de servi√ßo diferen√ßa",
    "text_lower": "adicional por tempo de servi√ßo diferen√ßa"
  },
  {
    "value": "11386",
    "text": "Adicional por tempo de servi√ßo integra√ß√£o",
    "text_lower": "adicional por tempo de servi√ßo integra√ß√£o"
  },
  {
    "value": "485",
    "text": "ajuda de custo",
    "text_lower": "ajuda de custo"
  },
  {
    "value": "1497",
    "text": "Ajuda de custo diferen√ßa",
    "text_lower": "ajuda de custo diferen√ßa"
  },
  {
    "value": "678",
    "text": "Ajuda de custo integra√ß√£o",
    "text_lower": "ajuda de custo integra√ß√£o"
  },
  {
    "value": "11566",
    "text": "Aluguel de motocicleta",
    "text_lower": "aluguel de motocicleta"
  },
  {
    "value": "57",
    "text": "Antecipa√ß√£o de Tutela",
    "text_lower": "antecipa√ß√£o de tutela"
  },
  {
    "value": "11387",
    "text": "Anula√ß√£o de justa causa",
    "text_lower": "anula√ß√£o de justa causa"
  },
  {
    "value": "11388",
    "text": "Art.467 da CLT",
    "text_lower": "art.467 da clt"
  },
  {
    "value": "135",
    "text": "Ass√©dio Moral",
    "text_lower": "ass√©dio moral"
  },
  {
    "value": "137",
    "text": "Ass√©dio Sexual",
    "text_lower": "ass√©dio sexual"
  },
  {
    "value": "11390",
    "text": "Assist√™ncia m√©dica",
    "text_lower": "assist√™ncia m√©dica"
  },
  {
    "value": "11392",
    "text": "Assist√™ncia m√©dica - manuten√ß√£o de plano",
    "text_lower": "assist√™ncia m√©dica - manuten√ß√£o de plano"
  },
  {
    "value": "11391",
    "text": "Assist√™ncia m√©dica indeniza√ß√£o",
    "text_lower": "assist√™ncia m√©dica indeniza√ß√£o"
  },
  {
    "value": "1175",
    "text": "Auto de infra√ß√£o",
    "text_lower": "auto de infra√ß√£o"
  },
  {
    "value": "100",
    "text": "Aux√≠lio Alimenta√ß√£o",
    "text_lower": "aux√≠lio alimenta√ß√£o"
  },
  {
    "value": "11393",
    "text": "Aux√≠lio alimenta√ß√£o diferen√ßa",
    "text_lower": "aux√≠lio alimenta√ß√£o diferen√ßa"
  },
  {
    "value": "11394",
    "text": "Aux√≠lio alimenta√ß√£o integra√ß√£o",
    "text_lower": "aux√≠lio alimenta√ß√£o integra√ß√£o"
  },
  {
    "value": "82",
    "text": "Aux√≠lio Doen√ßa",
    "text_lower": "aux√≠lio doen√ßa"
  },
  {
    "value": "11395",
    "text": "Aux√≠lio maternidade",
    "text_lower": "aux√≠lio maternidade"
  },
  {
    "value": "1279",
    "text": "Aux√≠lio Moradia",
    "text_lower": "aux√≠lio moradia"
  },
  {
    "value": "11396",
    "text": "Aux√≠lio refei√ß√£o",
    "text_lower": "aux√≠lio refei√ß√£o"
  },
  {
    "value": "11399",
    "text": "Aux√≠lio refei√ß√£o - domingos e feriados",
    "text_lower": "aux√≠lio refei√ß√£o - domingos e feriados"
  },
  {
    "value": "1130",
    "text": "Aviso pr√©vio",
    "text_lower": "aviso pr√©vio"
  },
  {
    "value": "1584",
    "text": "AVISO PR√âVIO DIFEREN√áA",
    "text_lower": "aviso pr√©vio diferen√ßa"
  },
  {
    "value": "11481",
    "text": "aviso pr√©vio indenizado",
    "text_lower": "aviso pr√©vio indenizado"
  },
  {
    "value": "10148",
    "text": "aviso pr√©vio integra√ß√£o",
    "text_lower": "aviso pr√©vio integra√ß√£o"
  },
  {
    "value": "1184",
    "text": "Aviso pr√©vio proporcional",
    "text_lower": "aviso pr√©vio proporcional"
  },
  {
    "value": "858",
    "text": "B√îNUS",
    "text_lower": "b√¥nus"
  },
  {
    "value": "11499",
    "text": "C√°lculo homologado",
    "text_lower": "c√°lculo homologado"
  },
  {
    "value": "11501",
    "text": "C√°lculo reclamada",
    "text_lower": "c√°lculo reclamada"
  },
  {
    "value": "11500",
    "text": "C√°lculo reclamante",
    "text_lower": "c√°lculo reclamante"
  },
  {
    "value": "1212",
    "text": "CAT",
    "text_lower": "cat"
  },
  {
    "value": "4001",
    "text": "Cesta b√°sica",
    "text_lower": "cesta b√°sica"
  },
  {
    "value": "1220",
    "text": "cita√ß√£o dos s√≥cios",
    "text_lower": "cita√ß√£o dos s√≥cios"
  },
  {
    "value": "10184",
    "text": "Comiss√£o",
    "text_lower": "comiss√£o"
  },
  {
    "value": "1870",
    "text": "Comiss√£o diferen√ßa",
    "text_lower": "comiss√£o diferen√ßa"
  },
  {
    "value": "1639",
    "text": "COMISS√ÉO INTEGRA√á√ÉO",
    "text_lower": "comiss√£o integra√ß√£o"
  },
  {
    "value": "1040",
    "text": "Complementa√ß√£o de aposentadoria",
    "text_lower": "complementa√ß√£o de aposentadoria"
  },
  {
    "value": "1970",
    "text": "Comprovante de pagamento",
    "text_lower": "comprovante de pagamento"
  },
  {
    "value": "1972",
    "text": "Concilia√ß√£o pr√©via",
    "text_lower": "concilia√ß√£o pr√©via"
  },
  {
    "value": "11494",
    "text": "consigna√ß√£o em pagamento",
    "text_lower": "consigna√ß√£o em pagamento"
  },
  {
    "value": "11497",
    "text": "Conting√™ncia acord√£o TRT",
    "text_lower": "conting√™ncia acord√£o trt"
  },
  {
    "value": "11495",
    "text": "Conting√™ncia inicial",
    "text_lower": "conting√™ncia inicial"
  },
  {
    "value": "11496",
    "text": "Conting√™ncia senten√ßa",
    "text_lower": "conting√™ncia senten√ßa"
  },
  {
    "value": "4046",
    "text": "Contrato de aprendizagem",
    "text_lower": "contrato de aprendizagem"
  },
  {
    "value": "2570",
    "text": "Contribui√ß√£o sindical",
    "text_lower": "contribui√ß√£o sindical"
  },
  {
    "value": "4049",
    "text": "Contribui√ß√µes assistenciais",
    "text_lower": "contribui√ß√µes assistenciais"
  },
  {
    "value": "2629",
    "text": "Contribui√ß√µes previdenci√°rias",
    "text_lower": "contribui√ß√µes previdenci√°rias"
  },
  {
    "value": "1905",
    "text": "CTPS anota√ß√£o",
    "text_lower": "ctps anota√ß√£o"
  },
  {
    "value": "10221",
    "text": "CTPS baixa",
    "text_lower": "ctps baixa"
  },
  {
    "value": "2008",
    "text": "CTPS retifica√ß√£o",
    "text_lower": "ctps retifica√ß√£o"
  },
  {
    "value": "11513",
    "text": "Dano extrapatrimoniais",
    "text_lower": "dano extrapatrimoniais"
  },
  {
    "value": "11514",
    "text": "Dano patrimonial",
    "text_lower": "dano patrimonial"
  },
  {
    "value": "11527",
    "text": "Danos emergenciais",
    "text_lower": "danos emergenciais"
  },
  {
    "value": "11537",
    "text": "Danos materiais por acidente de trabalho",
    "text_lower": "danos materiais por acidente de trabalho"
  },
  {
    "value": "11525",
    "text": "Danos materiais por doen√ßa ocupacional",
    "text_lower": "danos materiais por doen√ßa ocupacional"
  },
  {
    "value": "11536",
    "text": "Danos morais por acidente de trabalho",
    "text_lower": "danos morais por acidente de trabalho"
  },
  {
    "value": "11526",
    "text": "Danos morais por dispensa discriminat√≥ria",
    "text_lower": "danos morais por dispensa discriminat√≥ria"
  },
  {
    "value": "11524",
    "text": "Danos morais por doen√ßa ocupacional",
    "text_lower": "danos morais por doen√ßa ocupacional"
  },
  {
    "value": "11550",
    "text": "Danos morais por n√£o emiss√£o de CAT",
    "text_lower": "danos morais por n√£o emiss√£o de cat"
  },
  {
    "value": "11538",
    "text": "Danos morais por perda de uma chance",
    "text_lower": "danos morais por perda de uma chance"
  },
  {
    "value": "11556",
    "text": "Danos morais por risco de morte",
    "text_lower": "danos morais por risco de morte"
  },
  {
    "value": "11549",
    "text": "Danos morais por transporte de valores",
    "text_lower": "danos morais por transporte de valores"
  },
  {
    "value": "11376",
    "text": "D√©cimo quarto sal√°rio",
    "text_lower": "d√©cimo quarto sal√°rio"
  },
  {
    "value": "11374",
    "text": "d√©cimo terceiro sal√°rio",
    "text_lower": "d√©cimo terceiro sal√°rio"
  },
  {
    "value": "4642",
    "text": "D√©cimo terceiro sal√°rio diferen√ßa",
    "text_lower": "d√©cimo terceiro sal√°rio diferen√ßa"
  },
  {
    "value": "1951",
    "text": "d√©cimo terceiro sal√°rio integra√ß√£o",
    "text_lower": "d√©cimo terceiro sal√°rio integra√ß√£o"
  },
  {
    "value": "11375",
    "text": "d√©cimo terceiro sal√°rio proporcional",
    "text_lower": "d√©cimo terceiro sal√°rio proporcional"
  },
  {
    "value": "2047",
    "text": "Declara√ß√£o",
    "text_lower": "declara√ß√£o"
  },
  {
    "value": "11480",
    "text": "declara√ß√£o de ilegalidade da escala",
    "text_lower": "declara√ß√£o de ilegalidade da escala"
  },
  {
    "value": "1955",
    "text": "DECLARA√á√ÉO DE NULIDADE",
    "text_lower": "declara√ß√£o de nulidade"
  },
  {
    "value": "1443",
    "text": "Depoimento pessoal",
    "text_lower": "depoimento pessoal"
  },
  {
    "value": "2347",
    "text": "Dep√≥sito FGTS",
    "text_lower": "dep√≥sito fgts"
  },
  {
    "value": "11400",
    "text": "Dep√≥sito FGTS",
    "text_lower": "dep√≥sito fgts"
  },
  {
    "value": "4671",
    "text": "Descanso semanal remunerado",
    "text_lower": "descanso semanal remunerado"
  },
  {
    "value": "11401",
    "text": "Descanso semanal remunerado diferen√ßa",
    "text_lower": "descanso semanal remunerado diferen√ßa"
  },
  {
    "value": "2351",
    "text": "Descanso semanal remunerado integra√ß√£o",
    "text_lower": "descanso semanal remunerado integra√ß√£o"
  },
  {
    "value": "4182",
    "text": "desconsidera√ß√£o da personalidade jur√≠dica",
    "text_lower": "desconsidera√ß√£o da personalidade jur√≠dica"
  },
  {
    "value": "11402",
    "text": "Descontos indevidos",
    "text_lower": "descontos indevidos"
  },
  {
    "value": "2060",
    "text": "Descontos TRCT",
    "text_lower": "descontos trct"
  },
  {
    "value": "4186",
    "text": "despesas com per√≠cia",
    "text_lower": "despesas com per√≠cia"
  },
  {
    "value": "4679",
    "text": "Despesas m√©dicas",
    "text_lower": "despesas m√©dicas"
  },
  {
    "value": "11491",
    "text": "Despesas processuais",
    "text_lower": "despesas processuais"
  },
  {
    "value": "2563",
    "text": "Desvio de fun√ß√£o",
    "text_lower": "desvio de fun√ß√£o"
  },
  {
    "value": "1461",
    "text": "Devolu√ß√£o de descontos indevidos",
    "text_lower": "devolu√ß√£o de descontos indevidos"
  },
  {
    "value": "11553",
    "text": "Devolu√ß√£o de indeniza√ß√£o por danos morais",
    "text_lower": "devolu√ß√£o de indeniza√ß√£o por danos morais"
  },
  {
    "value": "11403",
    "text": "Di√°ria de viagem",
    "text_lower": "di√°ria de viagem"
  },
  {
    "value": "11487",
    "text": "Diferen√ßa adicional noturno",
    "text_lower": "diferen√ßa adicional noturno"
  },
  {
    "value": "11488",
    "text": "diferen√ßa dep√≥sito FGTS",
    "text_lower": "diferen√ßa dep√≥sito fgts"
  },
  {
    "value": "11516",
    "text": "Diferen√ßa di√°ria de viagem",
    "text_lower": "diferen√ßa di√°ria de viagem"
  },
  {
    "value": "11517",
    "text": "Diferen√ßa dos pagamentos feriados",
    "text_lower": "diferen√ßa dos pagamentos feriados"
  },
  {
    "value": "11474",
    "text": "diferen√ßa PLR",
    "text_lower": "diferen√ßa plr"
  },
  {
    "value": "2181",
    "text": "Diferen√ßa salarial",
    "text_lower": "diferen√ßa salarial"
  },
  {
    "value": "2142",
    "text": "diferen√ßa salarial - ac√∫mulo de fun√ß√£o",
    "text_lower": "diferen√ßa salarial - ac√∫mulo de fun√ß√£o"
  },
  {
    "value": "11554",
    "text": "Diferen√ßas salariais por isonomia",
    "text_lower": "diferen√ßas salariais por isonomia"
  },
  {
    "value": "11547",
    "text": "Diferen√ßas salariais por piso normativo",
    "text_lower": "diferen√ßas salariais por piso normativo"
  },
  {
    "value": "11404",
    "text": "Diss√≠dio coletivo",
    "text_lower": "diss√≠dio coletivo"
  },
  {
    "value": "2197",
    "text": "Diss√≠dio diferen√ßa",
    "text_lower": "diss√≠dio diferen√ßa"
  },
  {
    "value": "2827",
    "text": "Domingos e feriados trabalhados",
    "text_lower": "domingos e feriados trabalhados"
  },
  {
    "value": "11472",
    "text": "emiss√£o CAT",
    "text_lower": "emiss√£o cat"
  },
  {
    "value": "2483",
    "text": "ENQUADRAMENTO SINDICAL",
    "text_lower": "enquadramento sindical"
  },
  {
    "value": "11406",
    "text": "Entrega chave de conectividade",
    "text_lower": "entrega chave de conectividade"
  },
  {
    "value": "11405",
    "text": "Entrega CTPS",
    "text_lower": "entrega ctps"
  },
  {
    "value": "10427",
    "text": "Entrega de documentos",
    "text_lower": "entrega de documentos"
  },
  {
    "value": "11407",
    "text": "Equipamento de prote√ß√£o individual - EPI",
    "text_lower": "equipamento de prote√ß√£o individual - epi"
  },
  {
    "value": "6274",
    "text": "EQUIPARA√á√ÉO SALARIAL",
    "text_lower": "equipara√ß√£o salarial"
  },
  {
    "value": "5880",
    "text": "ESTABILIDADE",
    "text_lower": "estabilidade"
  },
  {
    "value": "11522",
    "text": "Estabilidade acident√°ria",
    "text_lower": "estabilidade acident√°ria"
  },
  {
    "value": "2714",
    "text": "ESTABILIDADE CIPA",
    "text_lower": "estabilidade cipa"
  },
  {
    "value": "11505",
    "text": "Estabilidade de emprego",
    "text_lower": "estabilidade de emprego"
  },
  {
    "value": "11564",
    "text": "Estabilidade pr√© aposentadoria",
    "text_lower": "estabilidade pr√© aposentadoria"
  },
  {
    "value": "11518",
    "text": "Execu√ß√£o de t√≠tulo extrajudicial",
    "text_lower": "execu√ß√£o de t√≠tulo extrajudicial"
  },
  {
    "value": "11408",
    "text": "Execu√ß√£o provis√≥ria",
    "text_lower": "execu√ß√£o provis√≥ria"
  },
  {
    "value": "3061",
    "text": "Execu√ß√£o provis√≥ria em autos suplementares",
    "text_lower": "execu√ß√£o provis√≥ria em autos suplementares"
  },
  {
    "value": "10459",
    "text": "Execu√ß√£o s√≥cio",
    "text_lower": "execu√ß√£o s√≥cio"
  },
  {
    "value": "11520",
    "text": "exibi√ß√£o de √°udio e v√≠deo",
    "text_lower": "exibi√ß√£o de √°udio e v√≠deo"
  },
  {
    "value": "11469",
    "text": "exibi√ß√£o de documentos e produ√ß√£o antecpada de provas",
    "text_lower": "exibi√ß√£o de documentos e produ√ß√£o antecpada de provas"
  },
  {
    "value": "11521",
    "text": "expedi√ß√£o de alvar√° judicial",
    "text_lower": "expedi√ß√£o de alvar√° judicial"
  },
  {
    "value": "10462",
    "text": "EXPEDI√á√ÉO DE OF√çCIOS",
    "text_lower": "expedi√ß√£o de of√≠cios"
  },
  {
    "value": "3166",
    "text": "EXPEDI√á√ÉO DE OF√çCIOS E ORG√ÉOS REGULADORES",
    "text_lower": "expedi√ß√£o de of√≠cios e org√£os reguladores"
  },
  {
    "value": "11551",
    "text": "Extin√ß√£o do contrato por acordo entre empregado e empregador",
    "text_lower": "extin√ß√£o do contrato por acordo entre empregado e empregador"
  },
  {
    "value": "11397",
    "text": "Feriado",
    "text_lower": "feriado"
  },
  {
    "value": "11398",
    "text": "Feriado integra√ß√£o",
    "text_lower": "feriado integra√ß√£o"
  },
  {
    "value": "10483",
    "text": "FERIADO TRABALHADO",
    "text_lower": "feriado trabalhado"
  },
  {
    "value": "7219",
    "text": "F√©rias",
    "text_lower": "f√©rias"
  },
  {
    "value": "3375",
    "text": "F√©rias abono",
    "text_lower": "f√©rias abono"
  },
  {
    "value": "2738",
    "text": "F√©rias adicional 1/3",
    "text_lower": "f√©rias adicional 1/3"
  },
  {
    "value": "3190",
    "text": "F√©rias diferen√ßa",
    "text_lower": "f√©rias diferen√ßa"
  },
  {
    "value": "2741",
    "text": "F√©rias em dobro",
    "text_lower": "f√©rias em dobro"
  },
  {
    "value": "3680",
    "text": "F√©rias indenizadas",
    "text_lower": "f√©rias indenizadas"
  },
  {
    "value": "11482",
    "text": "f√©rias integra√ß√£o + 1/3",
    "text_lower": "f√©rias integra√ß√£o + 1/3"
  },
  {
    "value": "7222",
    "text": "F√âRIAS PROPORCIONAIS",
    "text_lower": "f√©rias proporcionais"
  },
  {
    "value": "3683",
    "text": "F√âRIAS VENCIDAS",
    "text_lower": "f√©rias vencidas"
  },
  {
    "value": "3202",
    "text": "FGTS + 40%",
    "text_lower": "fgts + 40%"
  },
  {
    "value": "3693",
    "text": "FGTS diferen√ßa",
    "text_lower": "fgts diferen√ßa"
  },
  {
    "value": "3695",
    "text": "FGTS diferen√ßa de multa",
    "text_lower": "fgts diferen√ßa de multa"
  },
  {
    "value": "3388",
    "text": "FGTS guias para saque",
    "text_lower": "fgts guias para saque"
  },
  {
    "value": "2775",
    "text": "FGTS indeniza√ß√£o",
    "text_lower": "fgts indeniza√ß√£o"
  },
  {
    "value": "7229",
    "text": "FGTS integra√ß√£o + 40%",
    "text_lower": "fgts integra√ß√£o + 40%"
  },
  {
    "value": "11410",
    "text": "Formul√°rio ppp - sb40",
    "text_lower": "formul√°rio ppp - sb40"
  },
  {
    "value": "2305",
    "text": "Gorjetas",
    "text_lower": "gorjetas"
  },
  {
    "value": "10538",
    "text": "Gratifica√ß√£o",
    "text_lower": "gratifica√ß√£o"
  },
  {
    "value": "7277",
    "text": "Gratifica√ß√£o de fun√ß√£o",
    "text_lower": "gratifica√ß√£o de fun√ß√£o"
  },
  {
    "value": "6612",
    "text": "Gratifica√ß√£o de natal",
    "text_lower": "gratifica√ß√£o de natal"
  },
  {
    "value": "3245",
    "text": "Gratifica√ß√£o diferen√ßa",
    "text_lower": "gratifica√ß√£o diferen√ßa"
  },
  {
    "value": "10543",
    "text": "Gratifica√ß√£o integra√ß√£o",
    "text_lower": "gratifica√ß√£o integra√ß√£o"
  },
  {
    "value": "3903",
    "text": "Gratifica√ß√£o por tempo de servi√ßo",
    "text_lower": "gratifica√ß√£o por tempo de servi√ßo"
  },
  {
    "value": "3517",
    "text": "Gratuidade de justi√ßa",
    "text_lower": "gratuidade de justi√ßa"
  },
  {
    "value": "10551",
    "text": "Guias CD",
    "text_lower": "guias cd"
  },
  {
    "value": "11411",
    "text": "Guias CD/SD",
    "text_lower": "guias cd/sd"
  },
  {
    "value": "7288",
    "text": "Guias TRCT",
    "text_lower": "guias trct"
  },
  {
    "value": "121",
    "text": "Homologa√ß√£o de Acordo Extrajudicial",
    "text_lower": "homologa√ß√£o de acordo extrajudicial"
  },
  {
    "value": "3422",
    "text": "Honor√°rios advocat√≠cios",
    "text_lower": "honor√°rios advocat√≠cios"
  },
  {
    "value": "3588",
    "text": "Honor√°rios contratuais",
    "text_lower": "honor√°rios contratuais"
  },
  {
    "value": "10629",
    "text": "Honor√°rios de sucub√™ncias",
    "text_lower": "honor√°rios de sucub√™ncias"
  },
  {
    "value": "10631",
    "text": "Honor√°rios periciais",
    "text_lower": "honor√°rios periciais"
  },
  {
    "value": "3156",
    "text": "Hora extra",
    "text_lower": "hora extra"
  },
  {
    "value": "10633",
    "text": "Hora extra 100%",
    "text_lower": "hora extra 100%"
  },
  {
    "value": "3158",
    "text": "Hora extra 50%",
    "text_lower": "hora extra 50%"
  },
  {
    "value": "5078",
    "text": "Hora extra 8¬™ hora di√°ria",
    "text_lower": "hora extra 8¬™ hora di√°ria"
  },
  {
    "value": "3792",
    "text": "Hora extra adicional",
    "text_lower": "hora extra adicional"
  },
  {
    "value": "7318",
    "text": "Hora extra cargo de confian√ßa",
    "text_lower": "hora extra cargo de confian√ßa"
  },
  {
    "value": "3793",
    "text": "Hora extra di√°ria",
    "text_lower": "hora extra di√°ria"
  },
  {
    "value": "3590",
    "text": "Hora extra diferen√ßa",
    "text_lower": "hora extra diferen√ßa"
  },
  {
    "value": "7879",
    "text": "Hora extra excedente 44¬™ hora semanal",
    "text_lower": "hora extra excedente 44¬™ hora semanal"
  },
  {
    "value": "10636",
    "text": "Hora extra feriado/ domingo",
    "text_lower": "hora extra feriado/ domingo"
  },
  {
    "value": "7320",
    "text": "Hora extra integra√ß√£o",
    "text_lower": "hora extra integra√ß√£o"
  },
  {
    "value": "11412",
    "text": "Hora extra interjonada (intervalo)",
    "text_lower": "hora extra interjonada (intervalo)"
  },
  {
    "value": "11544",
    "text": "Hora extra intervalo de descanso motorista",
    "text_lower": "hora extra intervalo de descanso motorista"
  },
  {
    "value": "11413",
    "text": "hora extra intrajornada (intervalo)",
    "text_lower": "hora extra intrajornada (intervalo)"
  },
  {
    "value": "7323",
    "text": "Hora extra noturna",
    "text_lower": "hora extra noturna"
  },
  {
    "value": "11414",
    "text": "Hora extra noturna prorroga√ß√£o",
    "text_lower": "hora extra noturna prorroga√ß√£o"
  },
  {
    "value": "11415",
    "text": "Hora extra RSR",
    "text_lower": "hora extra rsr"
  },
  {
    "value": "11416",
    "text": "hora in intinere",
    "text_lower": "hora in intinere"
  },
  {
    "value": "11417",
    "text": "Hora in intinere diferen√ßa",
    "text_lower": "hora in intinere diferen√ßa"
  },
  {
    "value": "11418",
    "text": "Hora in intinere integra√ß√£o",
    "text_lower": "hora in intinere integra√ß√£o"
  },
  {
    "value": "3796",
    "text": "Hora noturna",
    "text_lower": "hora noturna"
  },
  {
    "value": "5083",
    "text": "Hora noturna integra√ß√£o",
    "text_lower": "hora noturna integra√ß√£o"
  },
  {
    "value": "3797",
    "text": "Hora sobreaviso",
    "text_lower": "hora sobreaviso"
  },
  {
    "value": "3600",
    "text": "Hora sobreaviso diferen√ßa",
    "text_lower": "hora sobreaviso diferen√ßa"
  },
  {
    "value": "7326",
    "text": "Hora sobreaviso integra√ß√£o",
    "text_lower": "hora sobreaviso integra√ß√£o"
  },
  {
    "value": "4812",
    "text": "Hora suplementar",
    "text_lower": "hora suplementar"
  },
  {
    "value": "11565",
    "text": "Horas de transbordo",
    "text_lower": "horas de transbordo"
  },
  {
    "value": "22",
    "text": "Horas Extras",
    "text_lower": "horas extras"
  },
  {
    "value": "11535",
    "text": "Horas extras tempo de espera motorista",
    "text_lower": "horas extras tempo de espera motorista"
  },
  {
    "value": "11548",
    "text": "Horas in itinere",
    "text_lower": "horas in itinere"
  },
  {
    "value": "11519",
    "text": "impugna√ß√£o de c√°lculos",
    "text_lower": "impugna√ß√£o de c√°lculos"
  },
  {
    "value": "11509",
    "text": "Incapacidade permamente",
    "text_lower": "incapacidade permamente"
  },
  {
    "value": "10673",
    "text": "INDENIZA√á√ÉO",
    "text_lower": "indeniza√ß√£o"
  },
  {
    "value": "7371",
    "text": "indeniza√ß√£o acidente de trabalho",
    "text_lower": "indeniza√ß√£o acidente de trabalho"
  },
  {
    "value": "4292",
    "text": "indeniza√ß√£o adicional",
    "text_lower": "indeniza√ß√£o adicional"
  },
  {
    "value": "11421",
    "text": "indeniza√ß√£o ass√©dio moral",
    "text_lower": "indeniza√ß√£o ass√©dio moral"
  },
  {
    "value": "5124",
    "text": "indeniza√ß√£o compensat√≥ria",
    "text_lower": "indeniza√ß√£o compensat√≥ria"
  },
  {
    "value": "11420",
    "text": "indeniza√ß√£o dano existencial",
    "text_lower": "indeniza√ß√£o dano existencial"
  },
  {
    "value": "3863",
    "text": "indeniza√ß√£o dano material",
    "text_lower": "indeniza√ß√£o dano material"
  },
  {
    "value": "5126",
    "text": "indeniza√ß√£o dano moral",
    "text_lower": "indeniza√ß√£o dano moral"
  },
  {
    "value": "5134",
    "text": "indeniza√ß√£o di√°ria",
    "text_lower": "indeniza√ß√£o di√°ria"
  },
  {
    "value": "4860",
    "text": "indeniza√ß√£o estabilidade provis√≥ria",
    "text_lower": "indeniza√ß√£o estabilidade provis√≥ria"
  },
  {
    "value": "4101",
    "text": "indeniza√ß√£o gestante",
    "text_lower": "indeniza√ß√£o gestante"
  },
  {
    "value": "3870",
    "text": "indeniza√ß√£o perdas e danos",
    "text_lower": "indeniza√ß√£o perdas e danos"
  },
  {
    "value": "11426",
    "text": "indeniza√ß√£o PIS",
    "text_lower": "indeniza√ß√£o pis"
  },
  {
    "value": "11511",
    "text": "Indeniza√ß√£o por danos est√©ticos",
    "text_lower": "indeniza√ß√£o por danos est√©ticos"
  },
  {
    "value": "11512",
    "text": "Indeniza√ß√£o por danos psicol√≥gicos",
    "text_lower": "indeniza√ß√£o por danos psicol√≥gicos"
  },
  {
    "value": "11545",
    "text": "Indeniza√ß√£o por n√£o fornecimento de lanche",
    "text_lower": "indeniza√ß√£o por n√£o fornecimento de lanche"
  },
  {
    "value": "11419",
    "text": "indeniza√ß√£o seguro desemprego",
    "text_lower": "indeniza√ß√£o seguro desemprego"
  },
  {
    "value": "3873",
    "text": "indeniza√ß√£o substitutiva",
    "text_lower": "indeniza√ß√£o substitutiva"
  },
  {
    "value": "11422",
    "text": "indeniza√ß√£o substitutivas",
    "text_lower": "indeniza√ß√£o substitutivas"
  },
  {
    "value": "4870",
    "text": "inqu√©rito civil p√∫blico",
    "text_lower": "inqu√©rito civil p√∫blico"
  },
  {
    "value": "7905",
    "text": "INSS - Diferen√ßa",
    "text_lower": "inss - diferen√ßa"
  },
  {
    "value": "4132",
    "text": "integra√ß√£o √† remunera√ß√£o",
    "text_lower": "integra√ß√£o √† remunera√ß√£o"
  },
  {
    "value": "11423",
    "text": "integra√ß√£o integra√ß√£o ajuda de custo",
    "text_lower": "integra√ß√£o integra√ß√£o ajuda de custo"
  },
  {
    "value": "11424",
    "text": "integra√ß√£o salarial",
    "text_lower": "integra√ß√£o salarial"
  },
  {
    "value": "11425",
    "text": "interrup√ß√£o prescri√ß√£o",
    "text_lower": "interrup√ß√£o prescri√ß√£o"
  },
  {
    "value": "8514",
    "text": "intervalo interjornada",
    "text_lower": "intervalo interjornada"
  },
  {
    "value": "4348",
    "text": "intervalo intrajornada",
    "text_lower": "intervalo intrajornada"
  },
  {
    "value": "11572",
    "text": "Intervalo para recupera√ß√£o t√©rmica",
    "text_lower": "intervalo para recupera√ß√£o t√©rmica"
  },
  {
    "value": "4144",
    "text": "intima√ß√£o pessoal do minist√©rio p√∫blico do trabalho",
    "text_lower": "intima√ß√£o pessoal do minist√©rio p√∫blico do trabalho"
  },
  {
    "value": "11502",
    "text": "Invalidade do acordo de suspens√£o do contrato de trabalho",
    "text_lower": "invalidade do acordo de suspens√£o do contrato de trabalho"
  },
  {
    "value": "7924",
    "text": "invers√£o do √¥nus da prova",
    "text_lower": "invers√£o do √¥nus da prova"
  },
  {
    "value": "10734",
    "text": "IR pagamento pelo empregador",
    "text_lower": "ir pagamento pelo empregador"
  },
  {
    "value": "4351",
    "text": "IRRF",
    "text_lower": "irrf"
  },
  {
    "value": "7937",
    "text": "Juros de mora e corre√ß√£o monet√°ria",
    "text_lower": "juros de mora e corre√ß√£o monet√°ria"
  },
  {
    "value": "4435",
    "text": "libera√ß√£o das guias",
    "text_lower": "libera√ß√£o das guias"
  },
  {
    "value": "4356",
    "text": "Licen√ßa maternidade",
    "text_lower": "licen√ßa maternidade"
  },
  {
    "value": "1679",
    "text": "Licen√ßa paternidade",
    "text_lower": "licen√ßa paternidade"
  },
  {
    "value": "7949",
    "text": "liminar",
    "text_lower": "liminar"
  },
  {
    "value": "10762",
    "text": "LTCAT",
    "text_lower": "ltcat"
  },
  {
    "value": "35",
    "text": "Lucros Cessantes",
    "text_lower": "lucros cessantes"
  },
  {
    "value": "11560",
    "text": "Manuten√ß√£o do ve√≠culo",
    "text_lower": "manuten√ß√£o do ve√≠culo"
  },
  {
    "value": "8422",
    "text": "multa anota√ß√£o CTPS",
    "text_lower": "multa anota√ß√£o ctps"
  },
  {
    "value": "11428",
    "text": "multa art 435 da CLT",
    "text_lower": "multa art 435 da clt"
  },
  {
    "value": "1678",
    "text": "Multa art 467 da CLT",
    "text_lower": "multa art 467 da clt"
  },
  {
    "value": "764",
    "text": "Multa art 477 ¬ß¬ß 6¬∫ e 8¬∫ da clt",
    "text_lower": "multa art 477 ¬ß¬ß 6¬∫ e 8¬∫ da clt"
  },
  {
    "value": "1677",
    "text": "Multa art 477 da CLT ¬ß 8¬∫ da clt",
    "text_lower": "multa art 477 da clt ¬ß 8¬∫ da clt"
  },
  {
    "value": "11427",
    "text": "multa art 479 da CLT",
    "text_lower": "multa art 479 da clt"
  },
  {
    "value": "11389",
    "text": "Multa Art. 477 da CLT",
    "text_lower": "multa art. 477 da clt"
  },
  {
    "value": "11409",
    "text": "Multa conven√ß√£o coletiva",
    "text_lower": "multa conven√ß√£o coletiva"
  },
  {
    "value": "11430",
    "text": "multa convencionais",
    "text_lower": "multa convencionais"
  },
  {
    "value": "8431",
    "text": "multa di√°ria",
    "text_lower": "multa di√°ria"
  },
  {
    "value": "8575",
    "text": "multa diss√≠dio coletivo",
    "text_lower": "multa diss√≠dio coletivo"
  },
  {
    "value": "8433",
    "text": "multa indenizat√≥ria",
    "text_lower": "multa indenizat√≥ria"
  },
  {
    "value": "8434",
    "text": "multa pecuni√°ria",
    "text_lower": "multa pecuni√°ria"
  },
  {
    "value": "11529",
    "text": "Multa por falta de recolhimento FGTS",
    "text_lower": "multa por falta de recolhimento fgts"
  },
  {
    "value": "11546",
    "text": "Multa por n√£o emiss√£o de CAT",
    "text_lower": "multa por n√£o emiss√£o de cat"
  },
  {
    "value": "5448",
    "text": "multa rescis√≥ria",
    "text_lower": "multa rescis√≥ria"
  },
  {
    "value": "10813",
    "text": "multa resilit√≥ria",
    "text_lower": "multa resilit√≥ria"
  },
  {
    "value": "4902",
    "text": "nulidade",
    "text_lower": "nulidade"
  },
  {
    "value": "4926",
    "text": "nulidade banco de horas",
    "text_lower": "nulidade banco de horas"
  },
  {
    "value": "11432",
    "text": "nulidade cart√µes de ponto",
    "text_lower": "nulidade cart√µes de ponto"
  },
  {
    "value": "6424",
    "text": "NULIDADE DA DISPENSA",
    "text_lower": "nulidade da dispensa"
  },
  {
    "value": "11563",
    "text": "Nulidade do acordo para termina√ß√£o contratual",
    "text_lower": "nulidade do acordo para termina√ß√£o contratual"
  },
  {
    "value": "11543",
    "text": "Nulidade do aviso pr√©vio",
    "text_lower": "nulidade do aviso pr√©vio"
  },
  {
    "value": "11542",
    "text": "Nulidade do contrato de aprendizagem",
    "text_lower": "nulidade do contrato de aprendizagem"
  },
  {
    "value": "11561",
    "text": "Nulidade do contrato de est√°gio",
    "text_lower": "nulidade do contrato de est√°gio"
  },
  {
    "value": "11557",
    "text": "Nulidade do contrato de experi√™ncia",
    "text_lower": "nulidade do contrato de experi√™ncia"
  },
  {
    "value": "11541",
    "text": "Nulidade do contrato de presta√ß√£o de servi√ßos",
    "text_lower": "nulidade do contrato de presta√ß√£o de servi√ßos"
  },
  {
    "value": "11552",
    "text": "Nulidade do contrato intermitente",
    "text_lower": "nulidade do contrato intermitente"
  },
  {
    "value": "11431",
    "text": "nulidade justa causa",
    "text_lower": "nulidade justa causa"
  },
  {
    "value": "8483",
    "text": "nulidade pedido de demiss√£o",
    "text_lower": "nulidade pedido de demiss√£o"
  },
  {
    "value": "6321",
    "text": "nulidade recibos de pagamento",
    "text_lower": "nulidade recibos de pagamento"
  },
  {
    "value": "43",
    "text": "Obriga√ß√£o de fazer",
    "text_lower": "obriga√ß√£o de fazer"
  },
  {
    "value": "8917",
    "text": "obriga√ß√£o de n√£o fazer",
    "text_lower": "obriga√ß√£o de n√£o fazer"
  },
  {
    "value": "11439",
    "text": "of√≠cio aos √≥rg√£os competentes",
    "text_lower": "of√≠cio aos √≥rg√£os competentes"
  },
  {
    "value": "6445",
    "text": "of√≠cio da secretaria nacional",
    "text_lower": "of√≠cio da secretaria nacional"
  },
  {
    "value": "4949",
    "text": "of√≠cio DRF",
    "text_lower": "of√≠cio drf"
  },
  {
    "value": "6447",
    "text": "of√≠cio DRT",
    "text_lower": "of√≠cio drt"
  },
  {
    "value": "6335",
    "text": "of√≠cio INSS",
    "text_lower": "of√≠cio inss"
  },
  {
    "value": "4951",
    "text": "of√≠cio minist√©rio do trabalho",
    "text_lower": "of√≠cio minist√©rio do trabalho"
  },
  {
    "value": "8921",
    "text": "of√≠cio MP",
    "text_lower": "of√≠cio mp"
  },
  {
    "value": "5292",
    "text": "of√≠cio MPF",
    "text_lower": "of√≠cio mpf"
  },
  {
    "value": "5019",
    "text": "of√≠cio MPT",
    "text_lower": "of√≠cio mpt"
  },
  {
    "value": "6449",
    "text": "OF√çCIO MTE",
    "text_lower": "of√≠cio mte"
  },
  {
    "value": "6451",
    "text": "of√≠cio PF",
    "text_lower": "of√≠cio pf"
  },
  {
    "value": "5293",
    "text": "of√≠cio previd√™ncia social",
    "text_lower": "of√≠cio previd√™ncia social"
  },
  {
    "value": "6340",
    "text": "OF√çCIO RECEITA FEDERAL",
    "text_lower": "of√≠cio receita federal"
  },
  {
    "value": "8922",
    "text": "of√≠cio RF",
    "text_lower": "of√≠cio rf"
  },
  {
    "value": "5020",
    "text": "of√≠cio secretaria da fazenda",
    "text_lower": "of√≠cio secretaria da fazenda"
  },
  {
    "value": "11435",
    "text": "of√≠cio secretaria da fazenda nacional",
    "text_lower": "of√≠cio secretaria da fazenda nacional"
  },
  {
    "value": "6452",
    "text": "of√≠cio secretaria vara do trabalho",
    "text_lower": "of√≠cio secretaria vara do trabalho"
  },
  {
    "value": "5021",
    "text": "of√≠cio SGT",
    "text_lower": "of√≠cio sgt"
  },
  {
    "value": "10879",
    "text": "of√≠cio SRF",
    "text_lower": "of√≠cio srf"
  },
  {
    "value": "11434",
    "text": "of√≠co CEF",
    "text_lower": "of√≠co cef"
  },
  {
    "value": "11440",
    "text": "ordem de servi√ßo",
    "text_lower": "ordem de servi√ßo"
  },
  {
    "value": "6459",
    "text": "pagamento",
    "text_lower": "pagamento"
  },
  {
    "value": "8932",
    "text": "pagamento da diferen√ßa",
    "text_lower": "pagamento da diferen√ßa"
  },
  {
    "value": "11442",
    "text": "pagamento das diferen√ßas salariais",
    "text_lower": "pagamento das diferen√ßas salariais"
  },
  {
    "value": "11559",
    "text": "Pagamento de caf√© da manh√£",
    "text_lower": "pagamento de caf√© da manh√£"
  },
  {
    "value": "11533",
    "text": "Pagamento de deprecia√ß√£o do ve√≠culo",
    "text_lower": "pagamento de deprecia√ß√£o do ve√≠culo"
  },
  {
    "value": "4956",
    "text": "pagamento de hora extra",
    "text_lower": "pagamento de hora extra"
  },
  {
    "value": "5037",
    "text": "pagamento de indeniza√ß√£o",
    "text_lower": "pagamento de indeniza√ß√£o"
  },
  {
    "value": "11531",
    "text": "Pagamento de IPVA",
    "text_lower": "pagamento de ipva"
  },
  {
    "value": "8502",
    "text": "pagamento de multa",
    "text_lower": "pagamento de multa"
  },
  {
    "value": "11532",
    "text": "Pagamento de seguro total do ve√≠culo",
    "text_lower": "pagamento de seguro total do ve√≠culo"
  },
  {
    "value": "5301",
    "text": "pagamento diferen√ßa",
    "text_lower": "pagamento diferen√ßa"
  },
  {
    "value": "11443",
    "text": "pagamento do acr√©scimo salarial",
    "text_lower": "pagamento do acr√©scimo salarial"
  },
  {
    "value": "11444",
    "text": "pagamento do plus salarial",
    "text_lower": "pagamento do plus salarial"
  },
  {
    "value": "11445",
    "text": "pagamento feriado laborado",
    "text_lower": "pagamento feriado laborado"
  },
  {
    "value": "8935",
    "text": "pagamento FGTS",
    "text_lower": "pagamento fgts"
  },
  {
    "value": "11465",
    "text": "pagamento INSS",
    "text_lower": "pagamento inss"
  },
  {
    "value": "11464",
    "text": "pagamento IRFF",
    "text_lower": "pagamento irff"
  },
  {
    "value": "11446",
    "text": "pagamento premio",
    "text_lower": "pagamento premio"
  },
  {
    "value": "11447",
    "text": "pagamento salarial",
    "text_lower": "pagamento salarial"
  },
  {
    "value": "10901",
    "text": "participa√ß√£o nos lucros diferen√ßa",
    "text_lower": "participa√ß√£o nos lucros diferen√ßa"
  },
  {
    "value": "4978",
    "text": "participa√ß√£o nos lucros e resultados",
    "text_lower": "participa√ß√£o nos lucros e resultados"
  },
  {
    "value": "6365",
    "text": "participa√ß√£o nos lucros integra√ß√£o",
    "text_lower": "participa√ß√£o nos lucros integra√ß√£o"
  },
  {
    "value": "8958",
    "text": "PCMAT",
    "text_lower": "pcmat"
  },
  {
    "value": "11452",
    "text": "PCMSO",
    "text_lower": "pcmso"
  },
  {
    "value": "11448",
    "text": "pedido de liminar",
    "text_lower": "pedido de liminar"
  },
  {
    "value": "11449",
    "text": "pens√£o",
    "text_lower": "pens√£o"
  },
  {
    "value": "87",
    "text": "Pens√£o por Morte",
    "text_lower": "pens√£o por morte"
  },
  {
    "value": "5318",
    "text": "PENS√ÉO VENCIDAS",
    "text_lower": "pens√£o vencidas"
  },
  {
    "value": "6828",
    "text": "pens√£o vincendas",
    "text_lower": "pens√£o vincendas"
  },
  {
    "value": "11450",
    "text": "pens√£o vit√°licia",
    "text_lower": "pens√£o vit√°licia"
  },
  {
    "value": "11451",
    "text": "per√≠cia",
    "text_lower": "per√≠cia"
  },
  {
    "value": "5070",
    "text": "per√≠cia cont√°bil",
    "text_lower": "per√≠cia cont√°bil"
  },
  {
    "value": "10918",
    "text": "per√≠cia m√©dica",
    "text_lower": "per√≠cia m√©dica"
  },
  {
    "value": "11483",
    "text": "Per√≠cia t√©cnica",
    "text_lower": "per√≠cia t√©cnica"
  },
  {
    "value": "11493",
    "text": "PGR (programa de gerenciamento de risco)",
    "text_lower": "pgr (programa de gerenciamento de risco)"
  },
  {
    "value": "7140",
    "text": "plano de saude",
    "text_lower": "plano de saude"
  },
  {
    "value": "5341",
    "text": "plano de sa√∫de aposentado",
    "text_lower": "plano de sa√∫de aposentado"
  },
  {
    "value": "9245",
    "text": "plano de sa√∫de dependente",
    "text_lower": "plano de sa√∫de dependente"
  },
  {
    "value": "11507",
    "text": "Plano de sa√∫de vital√≠cio",
    "text_lower": "plano de sa√∫de vital√≠cio"
  },
  {
    "value": "5347",
    "text": "plano odontol√≥gico",
    "text_lower": "plano odontol√≥gico"
  },
  {
    "value": "5354",
    "text": "PLR proporcional",
    "text_lower": "plr proporcional"
  },
  {
    "value": "8747",
    "text": "PPP",
    "text_lower": "ppp"
  },
  {
    "value": "5486",
    "text": "PPPR",
    "text_lower": "pppr"
  },
  {
    "value": "5558",
    "text": "PPRA",
    "text_lower": "ppra"
  },
  {
    "value": "10970",
    "text": "quinquenio",
    "text_lower": "quinquenio"
  },
  {
    "value": "11530",
    "text": "Quotas de vendas",
    "text_lower": "quotas de vendas"
  },
  {
    "value": "5596",
    "text": "readmiss√£o",
    "text_lower": "readmiss√£o"
  },
  {
    "value": "11453",
    "text": "reajuste salarial",
    "text_lower": "reajuste salarial"
  },
  {
    "value": "11454",
    "text": "reativa√ß√£o e manuten√ß√£o plano de sa√∫de",
    "text_lower": "reativa√ß√£o e manuten√ß√£o plano de sa√∫de"
  },
  {
    "value": "11506",
    "text": "Recibos de pagamentos",
    "text_lower": "recibos de pagamentos"
  },
  {
    "value": "5602",
    "text": "recolhimento de quotas",
    "text_lower": "recolhimento de quotas"
  },
  {
    "value": "5603",
    "text": "recolhimento do FGTS",
    "text_lower": "recolhimento do fgts"
  },
  {
    "value": "10981",
    "text": "recolhimento fiscais",
    "text_lower": "recolhimento fiscais"
  },
  {
    "value": "11455",
    "text": "recolhimento imposto de renda",
    "text_lower": "recolhimento imposto de renda"
  },
  {
    "value": "11456",
    "text": "recolhimento previdenciarios",
    "text_lower": "recolhimento previdenciarios"
  },
  {
    "value": "5513",
    "text": "reconhecimento acidente de trabalho",
    "text_lower": "reconhecimento acidente de trabalho"
  },
  {
    "value": "11539",
    "text": "Reconhecimento de atividade especial",
    "text_lower": "reconhecimento de atividade especial"
  },
  {
    "value": "11558",
    "text": "Reconhecimento de contrato por prazo indeterminado",
    "text_lower": "reconhecimento de contrato por prazo indeterminado"
  },
  {
    "value": "11504",
    "text": "Reconhecimento de doen√ßa ocupacional",
    "text_lower": "reconhecimento de doen√ßa ocupacional"
  },
  {
    "value": "8969",
    "text": "reconhecimento de fun√ß√£o",
    "text_lower": "reconhecimento de fun√ß√£o"
  },
  {
    "value": "11457",
    "text": "reconhecimento do v√≠nculo empregat√≠cio",
    "text_lower": "reconhecimento do v√≠nculo empregat√≠cio"
  },
  {
    "value": "11503",
    "text": "Reconhecimento e aplica√ß√£o divisor 180H",
    "text_lower": "reconhecimento e aplica√ß√£o divisor 180h"
  },
  {
    "value": "11470",
    "text": "Reembolso",
    "text_lower": "reembolso"
  },
  {
    "value": "11458",
    "text": "reembolso de combust√≠vel",
    "text_lower": "reembolso de combust√≠vel"
  },
  {
    "value": "10992",
    "text": "reembolso de despesa",
    "text_lower": "reembolso de despesa"
  },
  {
    "value": "8979",
    "text": "reembolso de despesa m√©dica",
    "text_lower": "reembolso de despesa m√©dica"
  },
  {
    "value": "7193",
    "text": "REFLEXO ADICIONAL DE INSALUBRIDADE",
    "text_lower": "reflexo adicional de insalubridade"
  },
  {
    "value": "6906",
    "text": "reflexo adicional de periculosidade",
    "text_lower": "reflexo adicional de periculosidade"
  },
  {
    "value": "8985",
    "text": "reflexo adIcional de sobreaviso",
    "text_lower": "reflexo adicional de sobreaviso"
  },
  {
    "value": "11459",
    "text": "reflexo adicional noturno",
    "text_lower": "reflexo adicional noturno"
  },
  {
    "value": "8986",
    "text": "reflexo auxilio alimenta√ß√£o",
    "text_lower": "reflexo auxilio alimenta√ß√£o"
  },
  {
    "value": "11006",
    "text": "reflexo das f√©rias",
    "text_lower": "reflexo das f√©rias"
  },
  {
    "value": "6907",
    "text": "reflexo das horas extras",
    "text_lower": "reflexo das horas extras"
  },
  {
    "value": "11441",
    "text": "reflexo das horas in intinere",
    "text_lower": "reflexo das horas in intinere"
  },
  {
    "value": "5619",
    "text": "reflexo das verbas contratuais",
    "text_lower": "reflexo das verbas contratuais"
  },
  {
    "value": "6908",
    "text": "reflexo das verbas rescis√≥rias",
    "text_lower": "reflexo das verbas rescis√≥rias"
  },
  {
    "value": "11438",
    "text": "reflexo de ac√∫mulo de fun√ß√µes",
    "text_lower": "reflexo de ac√∫mulo de fun√ß√µes"
  },
  {
    "value": "11433",
    "text": "reflexo de comiss√µes",
    "text_lower": "reflexo de comiss√µes"
  },
  {
    "value": "5528",
    "text": "reflexo d√©cimo terceiro",
    "text_lower": "reflexo d√©cimo terceiro"
  },
  {
    "value": "11436",
    "text": "reflexo d√©cimo terceiro sal√°rio",
    "text_lower": "reflexo d√©cimo terceiro sal√°rio"
  },
  {
    "value": "6909",
    "text": "reflexo descanso semanal remunerado",
    "text_lower": "reflexo descanso semanal remunerado"
  },
  {
    "value": "11437",
    "text": "reflexo desconto indevido",
    "text_lower": "reflexo desconto indevido"
  },
  {
    "value": "7717",
    "text": "reflexo diferen√ßa salarial",
    "text_lower": "reflexo diferen√ßa salarial"
  },
  {
    "value": "11429",
    "text": "reflexo dos DSR e feriados",
    "text_lower": "reflexo dos dsr e feriados"
  },
  {
    "value": "11461",
    "text": "reflexo equipara√ß√£o salarial",
    "text_lower": "reflexo equipara√ß√£o salarial"
  },
  {
    "value": "11489",
    "text": "Reflexo estabilidade provis√≥ria",
    "text_lower": "reflexo estabilidade provis√≥ria"
  },
  {
    "value": "5794",
    "text": "reflexo FGTS",
    "text_lower": "reflexo fgts"
  },
  {
    "value": "11007",
    "text": "reflexo hora extra intervalo intrajornada",
    "text_lower": "reflexo hora extra intervalo intrajornada"
  },
  {
    "value": "8989",
    "text": "reflexo hora extra RSR",
    "text_lower": "reflexo hora extra rsr"
  },
  {
    "value": "11485",
    "text": "reflexo intervalo interjornada",
    "text_lower": "reflexo intervalo interjornada"
  },
  {
    "value": "11008",
    "text": "reflexo quebra de caixa",
    "text_lower": "reflexo quebra de caixa"
  },
  {
    "value": "11492",
    "text": "Reflexo repouso semanal remunerado",
    "text_lower": "reflexo repouso semanal remunerado"
  },
  {
    "value": "11460",
    "text": "reflexo sal√°rio diferen√ßa",
    "text_lower": "reflexo sal√°rio diferen√ßa"
  },
  {
    "value": "5530",
    "text": "reflexo sal√°rio por fora",
    "text_lower": "reflexo sal√°rio por fora"
  },
  {
    "value": "144",
    "text": "Reintegra√ß√£o",
    "text_lower": "reintegra√ß√£o"
  },
  {
    "value": "5821",
    "text": "remunera√ß√£o mensal",
    "text_lower": "remunera√ß√£o mensal"
  },
  {
    "value": "11508",
    "text": "Repara√ß√£o de danos extrapatrimoniais",
    "text_lower": "repara√ß√£o de danos extrapatrimoniais"
  },
  {
    "value": "9024",
    "text": "repouso semanal remunerado",
    "text_lower": "repouso semanal remunerado"
  },
  {
    "value": "11462",
    "text": "repouso semanal remunerado diferen√ßa",
    "text_lower": "repouso semanal remunerado diferen√ßa"
  },
  {
    "value": "9026",
    "text": "repouso semanal remunerado integra√ß√£o",
    "text_lower": "repouso semanal remunerado integra√ß√£o"
  },
  {
    "value": "9028",
    "text": "requalifica√ß√£o profissional",
    "text_lower": "requalifica√ß√£o profissional"
  },
  {
    "value": "9037",
    "text": "rescis√£o contratual",
    "text_lower": "rescis√£o contratual"
  },
  {
    "value": "6110",
    "text": "rescis√£o da decis√£o",
    "text_lower": "rescis√£o da decis√£o"
  },
  {
    "value": "145",
    "text": "Rescis√£o Indireta",
    "text_lower": "rescis√£o indireta"
  },
  {
    "value": "5953",
    "text": "responsabilidade solid√°ria",
    "text_lower": "responsabilidade solid√°ria"
  },
  {
    "value": "11466",
    "text": "responsabilidade subsidi√°ria",
    "text_lower": "responsabilidade subsidi√°ria"
  },
  {
    "value": "11471",
    "text": "Ressarcimento",
    "text_lower": "ressarcimento"
  },
  {
    "value": "11467",
    "text": "ressarcimento despesa",
    "text_lower": "ressarcimento despesa"
  },
  {
    "value": "11468",
    "text": "restabelecimento plano de sa√∫de",
    "text_lower": "restabelecimento plano de sa√∫de"
  },
  {
    "value": "11569",
    "text": "Restaura√ß√£o de autos",
    "text_lower": "restaura√ß√£o de autos"
  },
  {
    "value": "6146",
    "text": "reten√ß√µes fiscais",
    "text_lower": "reten√ß√µes fiscais"
  },
  {
    "value": "7501",
    "text": "retifica√ß√£o CNIS",
    "text_lower": "retifica√ß√£o cnis"
  },
  {
    "value": "11490",
    "text": "retifica√ß√£o PPP",
    "text_lower": "retifica√ß√£o ppp"
  },
  {
    "value": "7782",
    "text": "Retifica√ß√£o RAIS",
    "text_lower": "retifica√ß√£o rais"
  },
  {
    "value": "5969",
    "text": "Retifica√ß√£o TRCT",
    "text_lower": "retifica√ß√£o trct"
  },
  {
    "value": "9331",
    "text": "Revers√£o da justa causa",
    "text_lower": "revers√£o da justa causa"
  },
  {
    "value": "6154",
    "text": "Revers√£o da rescis√£o contratual",
    "text_lower": "revers√£o da rescis√£o contratual"
  },
  {
    "value": "5985",
    "text": "sal√°rio",
    "text_lower": "sal√°rio"
  },
  {
    "value": "11473",
    "text": "sal√°rio adIcional",
    "text_lower": "sal√°rio adicional"
  },
  {
    "value": "6059",
    "text": "sal√°rio diferen√ßa",
    "text_lower": "sal√°rio diferen√ßa"
  },
  {
    "value": "7536",
    "text": "sal√°rio diferen√ßa ac√∫mulo de fun√ß√£o",
    "text_lower": "sal√°rio diferen√ßa ac√∫mulo de fun√ß√£o"
  },
  {
    "value": "11087",
    "text": "sal√°rio diferen√ßa desvio de fun√ß√£o",
    "text_lower": "sal√°rio diferen√ßa desvio de fun√ß√£o"
  },
  {
    "value": "11475",
    "text": "sal√°rio diferen√ßa equipara√ß√£o salaria integra√ß√£o",
    "text_lower": "sal√°rio diferen√ßa equipara√ß√£o salaria integra√ß√£o"
  },
  {
    "value": "9490",
    "text": "sal√°rio diferen√ßa equipara√ß√£o salarial",
    "text_lower": "sal√°rio diferen√ßa equipara√ß√£o salarial"
  },
  {
    "value": "9361",
    "text": "sal√°rio diferen√ßa integra√ß√£o",
    "text_lower": "sal√°rio diferen√ßa integra√ß√£o"
  },
  {
    "value": "11562",
    "text": "Sal√°rio em dobro ‚Äì lei n¬∫ 9.029",
    "text_lower": "sal√°rio em dobro ‚Äì lei n¬∫ 9.029"
  },
  {
    "value": "7996",
    "text": "sal√°rio fam√≠lia",
    "text_lower": "sal√°rio fam√≠lia"
  },
  {
    "value": "8328",
    "text": "sal√°rio in natura",
    "text_lower": "sal√°rio in natura"
  },
  {
    "value": "8330",
    "text": "sal√°rio in natura integra√ß√£o",
    "text_lower": "sal√°rio in natura integra√ß√£o"
  },
  {
    "value": "86",
    "text": "Sal√°rio Maternidade",
    "text_lower": "sal√°rio maternidade"
  },
  {
    "value": "8331",
    "text": "SAL√ÅRIO POR FORA",
    "text_lower": "sal√°rio por fora"
  },
  {
    "value": "5994",
    "text": "sal√°rio saldo",
    "text_lower": "sal√°rio saldo"
  },
  {
    "value": "8005",
    "text": "sal√°rio substitui√ß√£o",
    "text_lower": "sal√°rio substitui√ß√£o"
  },
  {
    "value": "8334",
    "text": "sal√°rio vencidos",
    "text_lower": "sal√°rio vencidos"
  },
  {
    "value": "8340",
    "text": "sal√°rios vincendos",
    "text_lower": "sal√°rios vincendos"
  },
  {
    "value": "9633",
    "text": "seguro de vida",
    "text_lower": "seguro de vida"
  },
  {
    "value": "94",
    "text": "Seguro Desemprego",
    "text_lower": "seguro desemprego"
  },
  {
    "value": "6006",
    "text": "seguro desemprego diferen√ßa",
    "text_lower": "seguro desemprego diferen√ßa"
  },
  {
    "value": "8016",
    "text": "seguro desemprego guias",
    "text_lower": "seguro desemprego guias"
  },
  {
    "value": "6664",
    "text": "seguro desemprego indeniza√ß√£o",
    "text_lower": "seguro desemprego indeniza√ß√£o"
  },
  {
    "value": "8353",
    "text": "seguro desemprego multa por atraso",
    "text_lower": "seguro desemprego multa por atraso"
  },
  {
    "value": "11567",
    "text": "Taxas de entrega",
    "text_lower": "taxas de entrega"
  },
  {
    "value": "11463",
    "text": "termo de rescis√£o de contrato de trabalho",
    "text_lower": "termo de rescis√£o de contrato de trabalho"
  },
  {
    "value": "11477",
    "text": "tratamento m√©dico",
    "text_lower": "tratamento m√©dico"
  },
  {
    "value": "9141",
    "text": "tributos previdenci√°rios",
    "text_lower": "tributos previdenci√°rios"
  },
  {
    "value": "147",
    "text": "Unicidade Contratual",
    "text_lower": "unicidade contratual"
  },
  {
    "value": "7647",
    "text": "uso indevido de imagem",
    "text_lower": "uso indevido de imagem"
  },
  {
    "value": "11478",
    "text": "vale cultura",
    "text_lower": "vale cultura"
  },
  {
    "value": "9893",
    "text": "vale refei√ß√£o",
    "text_lower": "vale refei√ß√£o"
  },
  {
    "value": "9896",
    "text": "vale refei√ß√£o diferen√ßa",
    "text_lower": "vale refei√ß√£o diferen√ßa"
  },
  {
    "value": "9787",
    "text": "vale refei√ß√£o integra√ß√£o",
    "text_lower": "vale refei√ß√£o integra√ß√£o"
  },
  {
    "value": "7619",
    "text": "vale transporte",
    "text_lower": "vale transporte"
  },
  {
    "value": "11515",
    "text": "Vale transporte diferen√ßa",
    "text_lower": "vale transporte diferen√ßa"
  },
  {
    "value": "11540",
    "text": "Valida√ß√£o de laudo ambiental",
    "text_lower": "valida√ß√£o de laudo ambiental"
  },
  {
    "value": "11486",
    "text": "VALOR TOTAL PEDIDOS",
    "text_lower": "valor total pedidos"
  },
  {
    "value": "9793",
    "text": "verba indenizat√≥ria",
    "text_lower": "verba indenizat√≥ria"
  },
  {
    "value": "9985",
    "text": "verbas",
    "text_lower": "verbas"
  },
  {
    "value": "6996",
    "text": "verbas fundi√°rias",
    "text_lower": "verbas fundi√°rias"
  },
  {
    "value": "11288",
    "text": "verbas incontroversas",
    "text_lower": "verbas incontroversas"
  },
  {
    "value": "8088",
    "text": "verbas previdenci√°rias",
    "text_lower": "verbas previdenci√°rias"
  },
  {
    "value": "36",
    "text": "Verbas Rescis√≥rias",
    "text_lower": "verbas rescis√≥rias"
  },
  {
    "value": "11528",
    "text": "Verbas rescis√≥rias da dispensa imotivada",
    "text_lower": "verbas rescis√≥rias da dispensa imotivada"
  },
  {
    "value": "11303",
    "text": "VERBAS RESCIS√ìRIAS DIFEREN√áA",
    "text_lower": "verbas rescis√≥rias diferen√ßa"
  },
  {
    "value": "11570",
    "text": "Verbas rescis√≥rias por morte",
    "text_lower": "verbas rescis√≥rias por morte"
  },
  {
    "value": "11479",
    "text": "verbas rescis√≥rias rescis√£o indireta",
    "text_lower": "verbas rescis√≥rias rescis√£o indireta"
  },
  {
    "value": "9194",
    "text": "verbas trabalhistas",
    "text_lower": "verbas trabalhistas"
  },
  {
    "value": "148",
    "text": "V√≠nculo Empregat√≠cio",
    "text_lower": "v√≠nculo empregat√≠cio"
  },
  {
    "value": "3236",
    "text": "V√≠nculo empregat√≠cio",
    "text_lower": "v√≠nculo empregat√≠cio"
  },
  {
    "value": "11476",
    "text": "v√≠nculo empregat√≠cio reflexo",
    "text_lower": "v√≠nculo empregat√≠cio reflexo"
  }
]


================================================================================
FILE: data/trt_map.json
================================================================================
{
  "_description": "Mapeamento TRT ‚Üí Estado/UF para extra√ß√£o de PDFs trabalhistas. TRTs multi-estado usam 'ufs' como lista.",
  "_usage": "Use o c√≥digo TRT (01-24) para obter nome do estado, sigla UF, e varia√ß√µes de texto. Para TRTs multi-estado, use 'ufs' para disambiguar.",
  
  "01": {
    "estado": "Rio de Janeiro",
    "uf": "RJ",
    "ufs": ["RJ"],
    "trt_nome": "TRT da 1¬™ Regi√£o",
    "variantes": ["Rio de Janeiro", "RJ", "TRT-1", "TRT1", "TRT da 1¬™ Regi√£o", "1¬™ Regi√£o"]
  },
  "02": {
    "estado": "S√£o Paulo",
    "uf": "SP",
    "ufs": ["SP"],
    "trt_nome": "TRT da 2¬™ Regi√£o",
    "variantes": ["S√£o Paulo", "SP", "TRT-2", "TRT2", "TRT da 2¬™ Regi√£o", "2¬™ Regi√£o", "Grande S√£o Paulo"]
  },
  "03": {
    "estado": "Minas Gerais",
    "uf": "MG",
    "ufs": ["MG"],
    "trt_nome": "TRT da 3¬™ Regi√£o",
    "variantes": ["Minas Gerais", "MG", "TRT-3", "TRT3", "TRT da 3¬™ Regi√£o", "3¬™ Regi√£o"]
  },
  "04": {
    "estado": "Rio Grande do Sul",
    "uf": "RS",
    "ufs": ["RS"],
    "trt_nome": "TRT da 4¬™ Regi√£o",
    "variantes": ["Rio Grande do Sul", "RS", "TRT-4", "TRT4", "TRT da 4¬™ Regi√£o", "4¬™ Regi√£o"]
  },
  "05": {
    "estado": "Bahia",
    "uf": "BA",
    "ufs": ["BA"],
    "trt_nome": "TRT da 5¬™ Regi√£o",
    "variantes": ["Bahia", "BA", "TRT-5", "TRT5", "TRT da 5¬™ Regi√£o", "5¬™ Regi√£o"]
  },
  "06": {
    "estado": "Pernambuco",
    "uf": "PE",
    "ufs": ["PE"],
    "trt_nome": "TRT da 6¬™ Regi√£o",
    "variantes": ["Pernambuco", "PE", "TRT-6", "TRT6", "TRT da 6¬™ Regi√£o", "6¬™ Regi√£o"]
  },
  "07": {
    "estado": "Cear√°",
    "uf": "CE",
    "ufs": ["CE"],
    "trt_nome": "TRT da 7¬™ Regi√£o",
    "variantes": ["Cear√°", "CE", "TRT-7", "TRT7", "TRT da 7¬™ Regi√£o", "7¬™ Regi√£o"]
  },
  "08": {
    "estado": "Par√°",
    "uf": "PA",
    "ufs": ["PA", "AP"],
    "trt_nome": "TRT da 8¬™ Regi√£o",
    "variantes": ["Par√°", "PA", "TRT-8", "TRT8", "TRT da 8¬™ Regi√£o", "8¬™ Regi√£o", "Amap√°", "AP"],
    "estados_alt": {"AP": "Amap√°"}
  },
  "09": {
    "estado": "Paran√°",
    "uf": "PR",
    "ufs": ["PR"],
    "trt_nome": "TRT da 9¬™ Regi√£o",
    "variantes": ["Paran√°", "PR", "TRT-9", "TRT9", "TRT da 9¬™ Regi√£o", "9¬™ Regi√£o"]
  },
  "10": {
    "estado": "Distrito Federal",
    "uf": "DF",
    "ufs": ["DF", "TO"],
    "trt_nome": "TRT da 10¬™ Regi√£o",
    "variantes": ["Distrito Federal", "DF", "Bras√≠lia", "TRT-10", "TRT10", "TRT da 10¬™ Regi√£o", "10¬™ Regi√£o", "Tocantins", "TO"],
    "estados_alt": {"TO": "Tocantins"}
  },
  "11": {
    "estado": "Amazonas",
    "uf": "AM",
    "ufs": ["AM", "RR"],
    "trt_nome": "TRT da 11¬™ Regi√£o",
    "variantes": ["Amazonas", "AM", "TRT-11", "TRT11", "TRT da 11¬™ Regi√£o", "11¬™ Regi√£o", "Roraima", "RR"],
    "estados_alt": {"RR": "Roraima"}
  },
  "12": {
    "estado": "Santa Catarina",
    "uf": "SC",
    "ufs": ["SC"],
    "trt_nome": "TRT da 12¬™ Regi√£o",
    "variantes": ["Santa Catarina", "SC", "TRT-12", "TRT12", "TRT da 12¬™ Regi√£o", "12¬™ Regi√£o"]
  },
  "13": {
    "estado": "Para√≠ba",
    "uf": "PB",
    "ufs": ["PB"],
    "trt_nome": "TRT da 13¬™ Regi√£o",
    "variantes": ["Para√≠ba", "PB", "TRT-13", "TRT13", "TRT da 13¬™ Regi√£o", "13¬™ Regi√£o", "Jo√£o Pessoa"]
  },
  "14": {
    "estado": "Rond√¥nia",
    "uf": "RO",
    "ufs": ["RO", "AC"],
    "trt_nome": "TRT da 14¬™ Regi√£o",
    "variantes": ["Rond√¥nia", "RO", "TRT-14", "TRT14", "TRT da 14¬™ Regi√£o", "14¬™ Regi√£o", "Acre", "AC"],
    "estados_alt": {"AC": "Acre"}
  },
  "15": {
    "estado": "S√£o Paulo",
    "uf": "SP",
    "ufs": ["SP"],
    "trt_nome": "TRT da 15¬™ Regi√£o",
    "variantes": ["S√£o Paulo", "SP", "TRT-15", "TRT15", "TRT da 15¬™ Regi√£o", "15¬™ Regi√£o", "Campinas", "Interior de S√£o Paulo"]
  },
  "16": {
    "estado": "Maranh√£o",
    "uf": "MA",
    "ufs": ["MA"],
    "trt_nome": "TRT da 16¬™ Regi√£o",
    "variantes": ["Maranh√£o", "MA", "TRT-16", "TRT16", "TRT da 16¬™ Regi√£o", "16¬™ Regi√£o"]
  },
  "17": {
    "estado": "Esp√≠rito Santo",
    "uf": "ES",
    "ufs": ["ES"],
    "trt_nome": "TRT da 17¬™ Regi√£o",
    "variantes": ["Esp√≠rito Santo", "ES", "TRT-17", "TRT17", "TRT da 17¬™ Regi√£o", "17¬™ Regi√£o"]
  },
  "18": {
    "estado": "Goi√°s",
    "uf": "GO",
    "ufs": ["GO"],
    "trt_nome": "TRT da 18¬™ Regi√£o",
    "variantes": ["Goi√°s", "GO", "TRT-18", "TRT18", "TRT da 18¬™ Regi√£o", "18¬™ Regi√£o"]
  },
  "19": {
    "estado": "Alagoas",
    "uf": "AL",
    "ufs": ["AL"],
    "trt_nome": "TRT da 19¬™ Regi√£o",
    "variantes": ["Alagoas", "AL", "TRT-19", "TRT19", "TRT da 19¬™ Regi√£o", "19¬™ Regi√£o"]
  },
  "20": {
    "estado": "Sergipe",
    "uf": "SE",
    "ufs": ["SE"],
    "trt_nome": "TRT da 20¬™ Regi√£o",
    "variantes": ["Sergipe", "SE", "TRT-20", "TRT20", "TRT da 20¬™ Regi√£o", "20¬™ Regi√£o"]
  },
  "21": {
    "estado": "Rio Grande do Norte",
    "uf": "RN",
    "ufs": ["RN"],
    "trt_nome": "TRT da 21¬™ Regi√£o",
    "variantes": ["Rio Grande do Norte", "RN", "TRT-21", "TRT21", "TRT da 21¬™ Regi√£o", "21¬™ Regi√£o"]
  },
  "22": {
    "estado": "Piau√≠",
    "uf": "PI",
    "ufs": ["PI"],
    "trt_nome": "TRT da 22¬™ Regi√£o",
    "variantes": ["Piau√≠", "PI", "TRT-22", "TRT22", "TRT da 22¬™ Regi√£o", "22¬™ Regi√£o"]
  },
  "23": {
    "estado": "Mato Grosso",
    "uf": "MT",
    "ufs": ["MT"],
    "trt_nome": "TRT da 23¬™ Regi√£o",
    "variantes": ["Mato Grosso", "MT", "TRT-23", "TRT23", "TRT da 23¬™ Regi√£o", "23¬™ Regi√£o"]
  },
  "24": {
    "estado": "Mato Grosso do Sul",
    "uf": "MS",
    "ufs": ["MS"],
    "trt_nome": "TRT da 24¬™ Regi√£o",
    "variantes": ["Mato Grosso do Sul", "MS", "TRT-24", "TRT24", "TRT da 24¬™ Regi√£o", "24¬™ Regi√£o"]
  }
}



================================================================================
FILE: config/brand_map.json
================================================================================
{
  "grupo p√£o de a√ß√∫car": { "grupo": "Grupo P√£o de A√ß√∫car", "aliases": ["GPA","Grupo Pao de Acucar","P√£o de A√ß√∫car","Pao de Acucar"] },
  "companhia brasileira de distribuicao": { "grupo": "Grupo P√£o de A√ß√∫car", "aliases": ["COMPANHIA BRASILEIRA DE DISTRIBUICAO","CBD"] },
  "sendas distribuidora": { "grupo": "Grupo P√£o de A√ß√∫car", "aliases": ["SENDAS DISTRIBUIDORA S/A","Sendas Distribuidora S/A","SENDAS"] },
  "viavarejo": { "grupo": "Casas Bahia / Via", "aliases": ["Casas Bahia","VIA VAREJO","Via Varejo","GLOBEX","CNOVA","BANQI"] },
  "csn": { "grupo": "CSN", "aliases": ["Companhia Sider√∫rgica Nacional","CBSI","PRADA","CSN Minera√ß√£o","CSN Cimentos"] }
}



================================================================================
FILE: config/client_aliases.json
================================================================================
[
  {
    "cell": "Trabalhista GPA",
    "aliases": [
      "Companhia Brasileira de Distribuicao",
      "GPA",
      "Grupo Pao de Acucar",
      "grupopaodeacucar.com.br",
      "pao de acucar"
    ]
  },
  {
    "cell": "Trabalhista Casas Bahia",
    "aliases": [
      "Via Varejo",
      "Casas Bahia",
      "viavarejo.com.br",
      "via"
    ]
  },
  {
    "cell": "Trabalhista CSN",
    "aliases": [
      "Companhia Siderurgica Nacional",
      "CSN",
      "csn.com.br"
    ]
  },
  {
    "cell": "Trabalhista Pro Pharma",
    "aliases": [
      "Profarma",
      "Pro Pharma",
      "profarma.com.br"
    ]
  },
  {
    "cell": "Trabalhista Prudential",
    "aliases": [
      "Prudential do Brasil",
      "Prudential",
      "prudential.com.br"
    ]
  },
  {
    "cell": "Trabalhista Outros Clientes",
    "aliases": [
      "Outros",
      "Diversos",
      "N/A"
    ]
  },
  {
    "cell": "Em Segredo",
    "aliases": [
      "Sigiloso",
      "Em segredo",
      "Confidencial"
    ]
  }
]



================================================================================
FILE: config/client_cell_map.json
================================================================================
{
  "companhia brasileira de distribuicao": "Trabalhista GPA",
  "grupo p√£o de a√ß√∫car": "Trabalhista GPA",
  "sendas distribuidora": "Trabalhista GPA",
  "casas bahia": "Trabalhista Casas Bahia",
  "viavarejo": "Trabalhista Casas Bahia"
}



================================================================================
FILE: templates/base.html
================================================================================
Ôªø<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Sistema Jur√≠dico Inteligente{% endblock %}</title>
    {% if csrf_token is defined %}
    <meta name="csrf-token" content="{{ csrf_token() }}">
    {% endif %}
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <style>
        :root {
            --primary-color: #1e3c72;
            --secondary-color: #2a5298;
            --accent-color: #7e8ba3;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e8ba3 100%);
            background-attachment: fixed;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .navbar {
            background: rgba(30, 60, 114, 0.95) !important;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
            padding: 12px 0;
            position: relative;
            z-index: 100;
        }

        .navbar-brand {
            font-size: 20px;
            font-weight: 600;
            color: white !important;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .navbar-brand i {
            font-size: 24px;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.9) !important;
            font-weight: 500;
            transition: all 0.3s ease;
            padding: 8px 15px !important;
            border-radius: 8px;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white !important;
        }

        .dropdown-menu {
            background: rgba(30, 60, 114, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .dropdown-item {
            color: rgba(255, 255, 255, 0.9);
            transition: all 0.3s ease;
            padding: 10px 20px;
        }

        .dropdown-item:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }

        main.container {
            position: relative;
            z-index: 1;
            padding-bottom: 100px;
            max-width: 1400px;
        }

        .card {
            background: rgba(255, 255, 255, 0.98);
            border: none;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .card-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border: none;
            padding: 20px;
            font-weight: 600;
        }

        .card-header h1,
        .card-header h2,
        .card-header h3,
        .card-header h4,
        .card-header h5 {
            margin: 0;
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(30, 60, 114, 0.4);
        }

        .btn-secondary {
            background: #7e8ba3;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
        }

        .btn-danger {
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
        }

        .btn-success {
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
        }

        .btn-warning {
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
        }

        .alert {
            border-radius: 12px;
            border: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .form-control,
        .form-select {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px 15px;
            transition: all 0.3s ease;
        }

        .form-control:focus,
        .form-select:focus {
            border-color: #2a5298;
            box-shadow: 0 0 0 0.25rem rgba(42, 82, 152, 0.15);
        }

        .form-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .table {
            background: white;
            border-radius: 12px;
            overflow: hidden;
        }

        .table thead {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
        }

        .table thead th {
            border: none;
            padding: 15px;
            font-weight: 600;
        }

        .table tbody tr {
            transition: background 0.3s ease;
        }

        .table tbody tr:hover {
            background: rgba(42, 82, 152, 0.05);
        }

        .badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 600;
        }

        .powered-by {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.98);
            padding: 12px 20px;
            border-radius: 50px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .powered-by span {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .powered-by img {
            height: 35px;
            width: auto;
        }

        .help-button {
            position: fixed;
            bottom: 20px;
            right: 220px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border: none;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(30, 60, 114, 0.4);
            font-size: 22px;
            font-weight: bold;
            z-index: 1000;
        }

        .help-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(30, 60, 114, 0.6);
        }

        .help-button i {
            font-size: 20px;
        }

        .page-header {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .page-header h1 {
            color: #1e3c72;
            font-weight: 700;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .pagination .page-link {
            color: #2a5298;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin: 0 3px;
        }

        .pagination .page-link:hover {
            background: #2a5298;
            color: white;
        }

        .pagination .active .page-link {
            background: #2a5298;
            border-color: #2a5298;
        }

        .tutorial-step {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(42, 82, 152, 0.05);
            border-radius: 10px;
            border-left: 4px solid #2a5298;
        }

        .tutorial-step h5 {
            color: #1e3c72;
            font-weight: 700;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tutorial-step .step-number {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .tutorial-step p {
            color: #333;
            margin: 0;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .powered-by {
                bottom: 10px;
                right: 10px;
                padding: 8px 15px;
            }

            .powered-by span {
                font-size: 10px;
            }

            .powered-by img {
                height: 28px;
            }

            .help-button {
                bottom: 10px;
                right: 150px;
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }

        .stat-card {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card i {
            font-size: 40px;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .stat-card h3 {
            font-size: 36px;
            font-weight: 700;
            margin: 10px 0;
        }

        .stat-card p {
            margin: 0;
            opacity: 0.9;
            font-size: 14px;
        }

        .navbar-toggler {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .navbar-toggler-icon {
            filter: brightness(0) invert(1);
        }
    </style>
    {% block extra_styles %}{% endblock %}
</head>
<body>
    {% if current_user.is_authenticated %}
    <nav class="navbar navbar-expand-lg navbar-dark">
        <div class="container">
            <a class="navbar-brand" href="{{ url_for('core.dashboard') }}">
                <i class="fas fa-balance-scale"></i>
                Sistema Jur√≠dico Inteligente
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('core.dashboard') }}">
                            <i class="fas fa-home me-1"></i>Dashboard
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('core.process_list') }}">
                            <i class="fas fa-folder-open me-1"></i>Processos
                        </a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">
                            <i class="fas fa-plus-circle me-1"></i>Novo Processo
                        </a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="{{ url_for('core.extract_from_pdf') }}">
                                <i class="fas fa-file-pdf me-2"></i>Criar via PDF (IA)
                            </a></li>
                            <li><a class="dropdown-item" href="{{ url_for('core.process_create') }}">
                                <i class="fas fa-edit me-2"></i>Criar Manualmente
                            </a></li>
                            <li><hr class="dropdown-divider" style="background: rgba(255,255,255,0.2);"></li>
                            <li><a class="dropdown-item" href="{{ url_for('batch.batch_new') }}">
                                <i class="fas fa-cloud-upload-alt me-2"></i>Upload em Lote
                            </a></li>
                            <li><a class="dropdown-item" href="{{ url_for('batch.batch_list') }}">
                                <i class="fas fa-layer-group me-2"></i>Ver Batches
                            </a></li>
                        </ul>
                    </li>
                    {% if current_user.is_admin %}
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">
                            <i class="fas fa-cog me-1"></i>Admin
                        </a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="{{ url_for('core.admin_users') }}">
                                <i class="fas fa-users me-2"></i>Usu√É¬°rios
                            </a></li>
                            <li><a class="dropdown-item" href="{{ url_for('core.admin_create_user') }}">
                                <i class="fas fa-user-plus me-2"></i>Criar Usu√É¬°rio
                            </a></li>
                        </ul>
                    </li>
                    {% endif %}
                </ul>
                <ul class="navbar-nav">
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">
                            <i class="fas fa-user-circle me-1"></i>{{ current_user.username }}
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end">
                            <li><a class="dropdown-item" href="{{ url_for('core.logout') }}">
                                <i class="fas fa-sign-out-alt me-2"></i>Sair
                            </a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    {% endif %}

    <main class="container mt-4">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    <div class="alert alert-{{ 'danger' if category == 'error' else category }} alert-dismissible fade show" role="alert">
                        <i class="fas fa-{{ 'check-circle' if category == 'success' else 'exclamation-triangle' if category == 'warning' else 'info-circle' }} me-2"></i>
                        {{ message }}
                        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}

        {% block content %}{% endblock %}
    </main>

    {% if current_user.is_authenticated %}
    <button class="help-button" data-bs-toggle="modal" data-bs-target="#tutorialModal" title="Tutorial de Uso">
        <i class="fas fa-question"></i>
    </button>
    
    <div class="powered-by">
        <span>Powered by</span>
        <img src="{{ url_for('static', filename='images/inovailab-logo.png') }}" alt="InovAi.Lab">
    </div>

    <!-- Modal de Tutorial -->
    <div class="modal fade" id="tutorialModal" tabindex="-1" aria-labelledby="tutorialModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header" style="background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); color: white;">
                    <h5 class="modal-title" id="tutorialModalLabel">
                        <i class="fas fa-graduation-cap me-2"></i>Tutorial - Como Usar o Sistema
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Fechar"></button>
                </div>
                <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                    <div class="tutorial-step">
                        <h5>
                            <span class="step-number">1</span>
                            Acesse o Dashboard
                        </h5>
                        <p>Ao fazer login, voc√™ ser√° direcionado ao Dashboard onde pode visualizar o resumo de todos os seus processos cadastrados, incluindo estat√≠sticas por √°rea jur√≠dica.</p>
                    </div>

                    <div class="tutorial-step">
                        <h5>
                            <span class="step-number">2</span>
                            Criar Processo via PDF (IA) - Recomendado
                        </h5>
                        <p><strong>Menu:</strong> Novo Processo √¢‚Ä†‚Äô Criar via PDF (IA)</p>
                        <p>Esta √© a forma mais r√°pida e inteligente de cadastrar processos:</p>
                        <ul>
                            <li>Fa√É¬ßa upload de um documento PDF do processo</li>
                            <li>A Intelig√äncia Artificial extrair√° automaticamente: CNJ, partes, tribunal, √°rea jur√≠dica, assunto, objeto e demais informa√ß√µes</li>
                            <li>Revise os dados extra√≠dos na tela de confirma√ß√£o</li>
                            <li>Fa√É¬ßa ajustes se necess√É¬°rio e salve o processo</li>
                        </ul>
                    </div>

                    <div class="tutorial-step">
                        <h5>
                            <span class="step-number">3</span>
                            Criar Processo Manualmente
                        </h5>
                        <p><strong>Menu:</strong> Novo Processo √¢‚Ä†‚Äô Criar Manualmente</p>
                        <p>Para cadastrar processos sem usar a IA:</p>
                        <ul>
                            <li>Preencha todos os campos obrigat√≥rios (*) do formul√°rio</li>
                            <li>Informe: CNJ, partes, tribunal, √°rea jur√≠dica, comarca, vara, inst√¢ncia, assunto e objeto</li>
                            <li>Opcionalmente, anexe um arquivo PDF</li>
                            <li>Clique em "Cadastrar Processo"</li>
                        </ul>
                    </div>

                    <div class="tutorial-step">
                        <h5>
                            <span class="step-number">4</span>
                            Gerenciar Processos
                        </h5>
                        <p><strong>Menu:</strong> Processos</p>
                        <p>Nesta tela voc√É¬™ pode:</p>
                        <ul>
                            <li>Visualizar todos os processos cadastrados</li>
                            <li>Usar filtros por √°rea jur√≠dica (Trabalhista, C√≠vel, Criminal)</li>
                            <li>Pesquisar por CNJ, partes ou assunto</li>
                            <li>Clicar em um processo para ver todos os detalhes</li>
                        </ul>
                    </div>

                    <div class="tutorial-step">
                        <h5>
                            <span class="step-number">5</span>
                            Administra√ß√£o (Apenas Administradores)
                        </h5>
                        <p><strong>Menu:</strong> Admin √¢‚Ä†‚Äô Usu√°rios / Criar Usu√°rio</p>
                        <p>Se voc√™ √É¬© administrador, pode:</p>
                        <ul>
                            <li>Visualizar todos os usu√°rios do sistema</li>
                            <li>Criar novos usu√°rios (normais ou administradores)</li>
                            <li>Ver quantos processos cada usu√É¬°rio possui</li>
                        </ul>
                    </div>

                    <div class="tutorial-step">
                        <h5>
                            <span class="step-number">6</span>
                            Dicas Importantes
                        </h5>
                        <ul>
                            <li><strong>Extra√ß√£oo via IA:</strong> Funciona melhor com PDFs de boa qualidade e leg√≠veis</li>
                            <li><strong>Revis√É¬£o:</strong> Sempre revise os dados extra√≠dos pela IA antes de salvar</li>
                            <li><strong>Campos obrigat√≥rios:</strong> Marcados com asterisco (*) vermelho</li>
                            <li><strong>√Åreas jur√≠dicas:</strong> Sistema suporta Trabalhista, C√≠vel e Criminal com campos espec√≠ficos</li>
                            <li><strong>Seguran√ßa:</strong> Seus dados s√£o protegidos e acess√≠veis apenas por usu√°rios autorizados</li>
                        </ul>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                        <i class="fas fa-times me-1"></i>Fechar
                    </button>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <script>
        // Sistema de Toasts - Fun√ß√£o global para exibir toasts
        function showToast(message, type = 'success') {
            const colors = {
                'success': 'linear-gradient(135deg, #28a745 0%, #20c997 100%)',
                'error': 'linear-gradient(135deg, #dc3545 0%, #bd2130 100%)',
                'warning': 'linear-gradient(135deg, #ffc107 0%, #ff9800 100%)',
                'info': 'linear-gradient(135deg, #17a2b8 0%, #138496 100%)'
            };
            
            const icons = {
                'success': '<i class="fas fa-check-circle me-2"></i>',
                'error': '<i class="fas fa-exclamation-circle me-2"></i>',
                'warning': '<i class="fas fa-exclamation-triangle me-2"></i>',
                'info': '<i class="fas fa-info-circle me-2"></i>'
            };
            
            Toastify({
                text: (icons[type] || icons['info']) + message,
                duration: type === 'error' ? 5000 : 3000,
                close: true,
                gravity: "top",
                position: "right",
                stopOnFocus: true,
                escapeMarkup: false,
                style: {
                    background: colors[type] || colors['info'],
                    borderRadius: "12px",
                    boxShadow: "0 8px 20px rgba(0,0,0,0.25)",
                    fontWeight: "600",
                    fontSize: "15px",
                    padding: "16px 24px"
                }
            }).showToast();
        }
        
        // Converter flash messages em toasts automaticamente (seguro contra XSS)
        document.addEventListener('DOMContentLoaded', function() {
            // Serializar mensagens de forma segura usando tojson
            const flashMessages = {{ get_flashed_messages(with_categories=true)|tojson }};
            
            // Verificar se Toastify est√° dispon√≠vel
            if (typeof Toastify !== 'undefined' && flashMessages && flashMessages.length > 0) {
                // Toastify dispon√≠vel - mostrar toasts
                flashMessages.forEach(function([category, message]) {
                    const safeCategory = category === 'danger' ? 'error' : category;
                    showToast(message, safeCategory);
                });
                
                // Ocultar alerts tradicionais apenas se toasts foram exibidos
                document.querySelectorAll('.alert').forEach(alert => {
                    alert.style.display = 'none';
                });
            }
            // Se Toastify n√£o carregar, alerts tradicionais permanecem vis√≠veis (fallback)
        });
    </script>
    {% block scripts %}{% endblock %}
</body>
</html>



================================================================================
FILE: templates/login.html
================================================================================
Ôªø<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - Sistema Jur√≠dico Inteligente</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e8ba3 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        body::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        .login-container {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: 450px;
            padding: 20px;
        }

        .login-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: slideUp 0.5s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .login-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 40px 30px;
            text-align: center;
            color: white;
        }

        .login-header h1 {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .login-header p {
            font-size: 14px;
            opacity: 0.9;
            margin: 0;
        }

        .login-icon {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
            font-size: 28px;
        }

        .login-body {
            padding: 40px 30px;
        }

        .form-floating {
            margin-bottom: 20px;
        }

        .form-floating input {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            height: 60px;
            transition: all 0.3s ease;
        }

        .form-floating input:focus {
            border-color: #2a5298;
            box-shadow: 0 0 0 0.25rem rgba(42, 82, 152, 0.15);
        }

        .form-floating label {
            padding: 18px 15px;
        }

        .btn-login {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .btn-login:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(30, 60, 114, 0.3);
        }

        .alert {
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .powered-by {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 20px;
            border-radius: 50px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 10;
            animation: fadeIn 0.8s ease-out 0.3s backwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .powered-by span {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .powered-by img {
            height: 35px;
            width: auto;
        }

        .default-credentials {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
        }

        .default-credentials .title {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .default-credentials .creds {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #1e3c72;
            font-weight: 600;
        }

        @media (max-width: 576px) {
            .login-container {
                padding: 10px;
            }

            .login-header h1 {
                font-size: 24px;
            }

            .powered-by {
                bottom: 10px;
                right: 10px;
                padding: 8px 15px;
            }

            .powered-by span {
                font-size: 10px;
            }

            .powered-by img {
                height: 28px;
            }
        }

        .feature-icons {
            display: flex;
            justify-content: space-around;
            margin: 25px 0 15px;
            padding: 20px 0;
            border-top: 1px solid #e0e0e0;
        }

        .feature-icon {
            text-align: center;
            flex: 1;
        }

        .feature-icon i {
            font-size: 24px;
            color: #2a5298;
            margin-bottom: 8px;
        }

        .feature-icon span {
            display: block;
            font-size: 11px;
            color: #666;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="login-container">
        <div class="login-card">
            <div class="login-header">
                <div class="login-icon">
                    <i class="fas fa-balance-scale"></i>
                </div>
                <h1>
                    Sistema Jur√≠dico Inteligente
                </h1>
                <p>Gest√£o de Processos com IA</p>
            </div>

            <div class="login-body">
                {# Mensagens flash com mapeamento completo de categorias #}
                {% with messages = get_flashed_messages(with_categories=true) %}
                    {% if messages %}
                        {% for category, message in messages %}
                            {% set map = {'success':'success','info':'info','warning':'warning','danger':'danger','error':'danger'} %}
                            <div class="alert alert-{{ map.get(category, 'info') }} alert-dismissible fade show" role="alert">
                                {{ message }}
                                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                            </div>
                        {% endfor %}
                    {% endif %}
                {% endwith %}

                <!-- Preserva o 'next' na action e em um hidden input -->
                <form method="POST" action="{{ url_for('core.login', next=request.args.get('next')) }}">
                    {{ form.hidden_tag() }}
                    <input type="hidden" name="next" value="{{ next_url or request.args.get('next','') }}">

                    <div class="form-floating">
                        {{ form.username(class="form-control", placeholder="Usu√É¬°rio", id="floatingUsername", autocomplete="username") }}
                        {{ form.username.label(for="floatingUsername") }}
                        {% for error in form.username.errors %}
                            <div class="text-danger small mt-1">{{ error }}</div>
                        {% endfor %}
                    </div>

                    <div class="form-floating">
                        {{ form.password(class="form-control", placeholder="Senha", id="floatingPassword", autocomplete="current-password") }}
                        {{ form.password.label(for="floatingPassword") }}
                        {% for error in form.password.errors %}
                            <div class="text-danger small mt-1">{{ error }}</div>
                        {% endfor %}
                    </div>

                    <button type="submit" class="btn btn-login">
                        <i class="fas fa-sign-in-alt me-2"></i>Entrar no Sistema
                    </button>
                </form>

                <div class="default-credentials">
                    <div class="title">ACESSO PADR√ÉO</div>
                    <div class="creds">admin / admin123</div>
                </div>

                <div class="feature-icons">
                    <div class="feature-icon">
                        <i class="fas fa-file-pdf"></i>
                        <span>Upload PDF</span>
                    </div>
                    <div class="feature-icon">
                        <i class="fas fa-brain"></i>
                        <span>IA Integrada</span>
                    </div>
                    <div class="feature-icon">
                        <i class="fas fa-chart-line"></i>
                        <span>Analytics</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="powered-by">
        <span>Powered by</span>
        <img src="{{ url_for('static', filename='images/inovailab-logo.png') }}" alt="InovAi.Lab">
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>



================================================================================
FILE: templates/dashboard.html
================================================================================
Ôªø{% extends "base.html" %}

{% block title %}Dashboard - Sistema Jur√≠dico Inteligente{% endblock %}

{% block content %}
<div class="page-header d-flex justify-content-between align-items-center">
    <div>
        <h1>
            <i class="fas fa-chart-line"></i>
            Dashboard
        </h1>
        <p class="text-muted mb-0 mt-2">Bem-vindo ao Sistema de Gest√£o de Processos Jur√≠dicos com IA</p>
    </div>
    <div class="d-flex gap-2">
        <a href="{{ url_for('core.extract_from_pdf') }}" class="btn btn-primary">
            <i class="fas fa-file-pdf me-1"></i>Upload PDF
        </a>
        <a href="{{ url_for('batch.batch_new') }}" class="btn btn-info">
            <i class="fas fa-cloud-upload-alt me-1"></i>Upload em Lote
        </a>
        <a href="{{ url_for('batch.batch_list') }}" class="btn btn-warning">
            <i class="fas fa-layer-group me-1"></i>Ver Batches
        </a>
        <a href="{{ url_for('core.process_create') }}" class="btn btn-success">
            <i class="fas fa-edit me-1"></i>Criar Manual
        </a>
    </div>
</div>

<div class="row g-4 mb-4">
    <div class="col-md-4">
        <div class="stat-card">
            <i class="fas fa-folder-open"></i>
            <h3>{{ total_processes|default(0, true) }}</h3>
            <p>Total de Processos</p>
        </div>
    </div>

    <div class="col-md-4">
        <div class="stat-card" style="background: linear-gradient(135deg, #16a085 0%, #27ae60 100%);">
            <i class="fas fa-user-check"></i>
            <h3>{{ user_processes|default(0, true) }}</h3>
            <p>Meus Processos</p>
        </div>
    </div>

    <div class="col-md-4">
        <div class="stat-card" style="background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);">
            <i class="fas fa-file-pdf"></i>
            <h3>IA</h3>
            <p>Extra√ß√£o Autom√°tica</p>
        </div>
    </div>
</div>

{% if recent_processes %}
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0"><i class="fas fa-clock me-2"></i>Processos Recentes</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-hover mb-0">
                        <thead>
                            <tr>
                                <th><i class="fas fa-hashtag me-1"></i>CNJ</th>
                                <th><i class="fas fa-file me-1"></i>Tipo</th>
                                <th><i class="fas fa-map-marker-alt me-1"></i>Estado</th>
                                <th><i class="fas fa-calendar me-1"></i>Criado em</th>
                                <th><i class="fas fa-info-circle me-1"></i>Status eLaw</th>
                                <th class="text-center"><i class="fas fa-cog me-1"></i>A√ß√µes</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for process in recent_processes %}
                            <tr>
                                <td><strong>{{ process.cnj|default('-', true) }}</strong></td>
                                <td>
                                    <span class="badge bg-{{ 'primary' if process.tipo_processo == 'Eletr√¥nico' else 'secondary' }}">
                                        {{ process.tipo_processo|default('-', true) }}
                                    </span>
                                </td>
                                <td>{{ process.estado|default('-', true) }}</td>
                                <td>
                                    {% if process.created_at %}
                                        {{ process.created_at.strftime('%d/%m/%Y %H:%M') }}
                                    {% else %}-{% endif %}
                                </td>
                                <td class="text-center">
                                    {% if process.elaw_status == 'success' %}
                                        <span class="badge bg-success"><i class="fas fa-check-circle"></i></span>
                                    {% elif process.elaw_status == 'running' %}
                                        <span class="badge bg-info"><i class="fas fa-spinner fa-spin"></i></span>
                                    {% elif process.elaw_status == 'error' %}
                                        <span class="badge bg-danger"><i class="fas fa-times-circle"></i></span>
                                    {% else %}
                                        <span class="badge bg-secondary"><i class="fas fa-clock"></i></span>
                                    {% endif %}
                                </td>
                                <td class="text-center">
                                    <a href="{{ url_for('core.process_view', id=process.id) }}" class="btn btn-sm btn-outline-primary">
                                        <i class="fas fa-eye"></i>
                                    </a>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                <div class="text-center mt-4">
                    <a href="{{ url_for('core.process_list') }}" class="btn btn-outline-secondary">
                        <i class="fas fa-list me-2"></i>Ver todos os processos
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% else %}
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-body text-center" style="padding: 60px 20px;">
                <i class="fas fa-inbox fa-4x mb-3" style="color: #ccc;"></i>
                <h5 class="text-muted">Nenhum processo cadastrado ainda</h5>
                <p class="text-muted">Comece criando seu primeiro processo!</p>
                <div class="mt-4">
                    <a href="{{ url_for('core.extract_from_pdf') }}" class="btn btn-primary me-2">
                        <i class="fas fa-file-pdf me-1"></i>Upload PDF
                    </a>
                    <a href="{{ url_for('batch.batch_new') }}" class="btn btn-info me-2">
                        <i class="fas fa-cloud-upload-alt me-1"></i>Upload em Lote
                    </a>
                    <a href="{{ url_for('batch.batch_list') }}" class="btn btn-warning me-2">
                        <i class="fas fa-layer-group me-1"></i>Ver Batches
                    </a>
                    <a href="{{ url_for('core.process_create') }}" class="btn btn-success">
                        <i class="fas fa-edit me-1"></i>Criar Manual
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}



================================================================================
FILE: templates/error.html
================================================================================
Ôªø<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ error_title|default('Erro') }} - Sistema Jur√≠dico Inteligente</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #1e3c72;
            --secondary-color: #2a5298;
            --accent-color: #7e8ba3;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e8ba3 100%);
            background-attachment: fixed;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .error-container {
            max-width: 600px;
            width: 90%;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            position: relative;
            z-index: 1;
        }

        .error-icon {
            font-size: 80px;
            color: var(--primary-color);
            margin-bottom: 30px;
        }

        .error-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 20px;
        }

        .error-message {
            font-size: 18px;
            color: #555;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .btn-back {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-back:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(30, 60, 114, 0.4);
            color: white;
        }
    </style>
</head>
<body>
    <div class="error-container">
        <div class="error-icon">
            <i class="fas fa-exclamation-triangle"></i>
        </div>
        <h1 class="error-title">{{ error_title|default('Erro no Sistema') }}</h1>
        <p class="error-message">{{ error_message|default('Ocorreu um erro inesperado. Por favor, tente novamente.') }}</p>
        <a href="/dashboard" class="btn-back">
            <i class="fas fa-arrow-left me-2"></i>Voltar ao Dashboard
        </a>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>



================================================================================
FILE: templates/admin/users.html
================================================================================
Ôªø{% extends "base.html" %}

{% block title %}Gerenciar Usu√É¬°rios - Sistema de Processos Jur√É¬≠dicos{% endblock %}

{% block extra_styles %}
<style>
    h2, h3, h4, h5, h6 {
        color: white !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2><i class="fas fa-users me-2"></i>Gerenciar Usu√É¬°rios</h2>
            <a href="{{ url_for('admin_create_user') }}" class="btn btn-primary">
                <i class="fas fa-user-plus me-1"></i>Novo Usu√É¬°rio
            </a>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Usu√É¬°rio</th>
                                <th>Email</th>
                                <th>Tipo</th>
                                <th>Processos</th>
                                <th>Criado em</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for user in users %}
                            <tr>
                                <td>{{ user.id }}</td>
                                <td>
                                    <i class="fas fa-user me-2"></i>{{ user.username }}
                                </td>
                                <td>{{ user.email }}</td>
                                <td>
                                    {% if user.is_admin %}
                                        <span class="badge bg-danger">Admin</span>
                                    {% else %}
                                        <span class="badge bg-secondary">Usu√É¬°rio</span>
                                    {% endif %}
                                </td>
                                <td>
                                    <span class="badge bg-info">{{ user.processes|length }}</span>
                                </td>
                                <td>{{ user.created_at.strftime('%d/%m/%Y') }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                
                {% if not users %}
                <div class="text-center py-4">
                    <i class="fas fa-users fa-3x text-muted mb-3"></i>
                    <p class="text-muted">Nenhum usu√É¬°rio encontrado.</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}



================================================================================
FILE: templates/admin/create_user.html
================================================================================
Ôªø{% extends "base.html" %}

{% block title %}Criar Usu√É¬°rio - Sistema de Processos Jur√É¬≠dicos{% endblock %}

{% block extra_styles %}
<style>
    h2, h3, h4, h5, h6 {
        color: white !important;
    }
    .breadcrumb {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px 15px;
        border-radius: 8px;
    }
    .breadcrumb-item, .breadcrumb-item a {
        color: rgba(255, 255, 255, 0.9) !important;
    }
    .breadcrumb-item.active {
        color: white !important;
    }
    .breadcrumb-item + .breadcrumb-item::before {
        color: rgba(255, 255, 255, 0.6) !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-12">
        <h2><i class="fas fa-user-plus me-2"></i>Criar Novo Usu√É¬°rio</h2>
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="{{ url_for('dashboard') }}">Dashboard</a></li>
                <li class="breadcrumb-item"><a href="{{ url_for('admin_users') }}">Usu√É¬°rios</a></li>
                <li class="breadcrumb-item active">Criar Usu√É¬°rio</li>
            </ol>
        </nav>
    </div>
</div>

<div class="row justify-content-center">
    <div class="col-md-8 col-lg-6">
        <div class="card">
            <div class="card-body">
                <form method="POST">
                    {{ form.hidden_tag() }}
                    
                    <div class="mb-3">
                        {{ form.username.label(class="form-label") }}
                        {{ form.username(class="form-control") }}
                        {% for error in form.username.errors %}
                            <div class="text-danger small">{{ error }}</div>
                        {% endfor %}
                    </div>
                    
                    <div class="mb-3">
                        {{ form.email.label(class="form-label") }}
                        {{ form.email(class="form-control") }}
                        {% for error in form.email.errors %}
                            <div class="text-danger small">{{ error }}</div>
                        {% endfor %}
                    </div>
                    
                    <div class="mb-3">
                        {{ form.password.label(class="form-label") }}
                        {{ form.password(class="form-control") }}
                        <div class="form-text">M√É¬≠nimo de 6 caracteres</div>
                        {% for error in form.password.errors %}
                            <div class="text-danger small">{{ error }}</div>
                        {% endfor %}
                    </div>
                    
                    <div class="mb-3 form-check">
                        {{ form.is_admin(class="form-check-input") }}
                        {{ form.is_admin.label(class="form-check-label") }}
                        <div class="form-text">Administradores podem criar e gerenciar usu√É¬°rios</div>
                    </div>
                    
                    <div class="d-flex gap-2">
                        <button type="submit" class="btn btn-primary">
                            <i class="fas fa-save me-1"></i>Criar Usu√É¬°rio
                        </button>
                        <a href="{{ url_for('admin_users') }}" class="btn btn-secondary">
                            <i class="fas fa-arrow-left me-1"></i>Voltar
                        </a>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
{% endblock %}



================================================================================
FILE: templates/processes/list.html
================================================================================
{% extends "base.html" %}

{% block title %}Lista de Processos - Sistema de Processos Jur√É¬≠dicos{% endblock %}

{% block extra_styles %}
<style>
    h2, h3, h4, h5, h6 {
        color: white !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2><i class="fas fa-folder-open me-2"></i>Lista de Processos</h2>
            <div>
                <a href="{{ url_for('core.extract_from_pdf') }}" class="btn btn-success me-2">
                    <i class="fas fa-robot me-1"></i>Criar com IA
                </a>
                <a href="{{ url_for('core.process_create') }}" class="btn btn-primary">
                    <i class="fas fa-plus me-1"></i>Novo Processo Manual
                </a>
            </div>
        </div>
    </div>
</div>

<!-- Search Form -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-body">
                <form method="GET" class="row g-3">
                    <div class="col-md-10">
                        <input
  type="text"
  class="form-control"
  name="search"
  placeholder="Buscar por CNJ, n√∫mero do processo, assunto ou objeto..."
  value="{{ search or '' }}"
/>

                    </div>
                    <div class="col-md-2">
                        <button type="submit" class="btn btn-outline-primary w-100">
                            <i class="fas fa-search me-1"></i>Buscar
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Process List -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-body">
                {% if processes.items %}
                <!-- Bot√£o Deletar Selecionados -->
                <div class="mb-3 d-none" id="delete-selected-container">
                    <button type="button" class="btn btn-danger" id="delete-selected-btn" onclick="deleteSelected()">
                        <i class="fas fa-trash me-2"></i>
                        Deletar Selecionados (<span id="selected-count">0</span>)
                    </button>
                </div>
                
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead>
                            <tr>
                                <th style="width: 40px;">
                                    <input type="checkbox" id="select-all" class="form-check-input" onchange="toggleAll(this)">
                                </th>
                                <th>CNJ</th>
                                <th>Tipo</th>
                                <th>Estado/Comarca</th>
                                <th>√ìrg√£o</th>
                                <th>Status eLaw</th>
                                <th>Data</th>
                                <th>PDF</th>
                                <th>A√ß√µes</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for process in processes.items %}
                            <tr>
                                <td>
                                    <input type="checkbox" class="form-check-input process-checkbox" value="{{ process.id }}" onchange="updateSelectedCount()">
                                </td>
                                <td>
                                    <strong>{{ process.cnj|default('-', true) }}</strong>
                                    {% if process.numero_processo %}
                                        <br><small class="text-muted">{{ process.numero_processo }}</small>
                                    {% endif %}
                                </td>
                                <td>{{ process.tipo_processo|default('-', true) }}</td>
                                <td>
                                    {{ process.estado|default('-', true) }}
                                    <br><small class="text-muted">{{ process.comarca|default('-', true) }}</small>
                                </td>
                                <td>{{ process.orgao|default('-', true) }}</td>
                                <td class="text-center">
                                    {% if process.elaw_status == 'success' %}
                                        <span class="badge bg-success"><i class="fas fa-check-circle me-1"></i>Preenchido</span>
                                    {% elif process.elaw_status == 'running' %}
                                        <span class="badge bg-info"><i class="fas fa-spinner fa-spin me-1"></i>Preenchendo</span>
                                    {% elif process.elaw_status == 'error' %}
                                        <span class="badge bg-danger"><i class="fas fa-times-circle me-1"></i>Erro</span>
                                    {% else %}
                                        <span class="badge bg-secondary"><i class="fas fa-clock me-1"></i>Pendente</span>
                                    {% endif %}
                                </td>
                                <td>
                                    {% if process.created_at %}
                                        {{ process.created_at|brazil_datetime('%d/%m/%Y %H:%M') }}
                                    {% else %}-{% endif %}
                                </td>
                                <td class="text-center">
                                    {% if process.pdf_filename %}
                                        <a href="{{ url_for('core.uploaded_file', filename=process.pdf_filename) }}" 
                                           class="btn btn-sm btn-outline-danger" target="_blank">
                                            <i class="fas fa-file-pdf"></i>
                                        </a>
                                    {% else %}
                                        <span class="text-muted">-</span>
                                    {% endif %}
                                </td>
                                <td>
                                    {% set missing_fields = process.get_missing_critical_fields() %}
                                    {% set has_missing = missing_fields|length > 0 %}
                                    <a href="{{ url_for('core.process_view', id=process.id) }}"
                                       class="btn btn-sm {% if has_missing %}btn-danger{% else %}btn-outline-primary{% endif %}"
                                       data-bs-toggle="tooltip"
                                       title="{% if has_missing %}Campos faltando: {{ missing_fields|join(', ') }}{% else %}Ver detalhes{% endif %}">
                                        <i class="fas fa-eye"></i>
                                    </a>
                                    <form method="POST" 
                                          action="{{ url_for('core.process_delete', id=process.id) }}" 
                                          style="display: inline;"
                                          onsubmit="return confirm('Tem certeza que deseja deletar este processo? Esta a√ß√£o n√£o pode ser desfeita.');">
                                        <button type="submit" 
                                                class="btn btn-sm btn-outline-danger"
                                                title="Deletar processo">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </form>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                
                <!-- Pagination -->
                {% if processes.pages > 1 %}
                <nav aria-label="Page navigation" class="mt-4">
                    <ul class="pagination justify-content-center">
                        {% if processes.has_prev %}
                            <li class="page-item">
                                <a class="page-link" href="{{ url_for('core.process_list', page=processes.prev_num, search=search) }}">
                                    <i class="fas fa-chevron-left"></i>
                                </a>
                            </li>
                        {% endif %}
                        
                        {% for page_num in processes.iter_pages() %}
                            {% if page_num %}
                                {% if page_num != processes.page %}
                                    <li class="page-item">
                                        <a class="page-link" href="{{ url_for('core.process_list', page=page_num, search=search) }}">
                                            {{ page_num }}
                                        </a>
                                    </li>
                                {% else %}
                                    <li class="page-item active">
                                        <span class="page-link">{{ page_num }}</span>
                                    </li>
                                {% endif %}
                            {% else %}
                                <li class="page-item disabled">
                                    <span class="page-link">√¢‚Ç¨¬¶</span>
                                </li>
                            {% endif %}
                        {% endfor %}
                        
                        {% if processes.has_next %}
                            <li class="page-item">
                                <a class="page-link" href="{{ url_for('core.process_list', page=processes.next_num, search=search) }}">
                                    <i class="fas fa-chevron-right"></i>
                                </a>
                            </li>
                        {% endif %}
                    </ul>
                </nav>
                {% endif %}
                
                {% else %}
                <div class="text-center py-5">
                    <i class="fas fa-folder-open fa-3x text-muted mb-3"></i>
                    {% if search %}
                        <p class="text-muted">Nenhum processo encontrado para a busca "{{ search }}".</p>
                        <a href="{{ url_for('core.process_list') }}" class="btn btn-outline-secondary">
                            <i class="fas fa-times me-1"></i>Limpar Busca
                        </a>
                    {% else %}
                        <p class="text-muted">Nenhum processo cadastrado ainda.</p>
                        <div>
                            <a href="{{ url_for('core.extract_from_pdf') }}" class="btn btn-success me-2">
                                <i class="fas fa-robot me-1"></i>Criar com IA
                            </a>
                            <a href="{{ url_for('core.process_create') }}" class="btn btn-primary">
                                <i class="fas fa-plus me-1"></i>Cadastrar Manualmente
                            </a>
                        </div>
                    {% endif %}
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Gerenciamento de sele√ß√£o m√∫ltipla
function toggleAll(selectAllCheckbox) {
    const checkboxes = document.querySelectorAll('.process-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox.checked;
    });
    updateSelectedCount();
}

function updateSelectedCount() {
    const checkboxes = document.querySelectorAll('.process-checkbox:checked');
    const count = checkboxes.length;
    const container = document.getElementById('delete-selected-container');
    const countSpan = document.getElementById('selected-count');
    
    countSpan.textContent = count;
    
    // Mostrar/esconder bot√£o de deletar
    if (count > 0) {
        container.classList.remove('d-none');
    } else {
        container.classList.add('d-none');
        document.getElementById('select-all').checked = false;
    }
}

function deleteSelected() {
    const checkboxes = document.querySelectorAll('.process-checkbox:checked');
    const selectedIds = Array.from(checkboxes).map(cb => cb.value);
    
    if (selectedIds.length === 0) {
        showToast('Nenhum processo selecionado.', 'warning');
        return;
    }
    
    const confirmation = confirm(`Tem certeza que deseja deletar ${selectedIds.length} processo(s) selecionado(s)? Esta a√ß√£o n√£o pode ser desfeita.`);
    
    if (!confirmation) {
        return;
    }
    
    // Desabilitar bot√£o durante o processamento
    const btn = document.getElementById('delete-selected-btn');
    const originalHTML = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Deletando...';
    
    // Preparar headers com CSRF token (se existir)
    const headers = {
        'Content-Type': 'application/json'
    };
    
    // Tentar obter token CSRF de meta tag ou cookie
    const csrfMeta = document.querySelector('meta[name="csrf-token"]');
    if (csrfMeta) {
        headers['X-CSRFToken'] = csrfMeta.getAttribute('content');
    }
    
    // Enviar requisi√ß√£o para o backend
    fetch('/processos/deletar-multiplos', {
        method: 'POST',
        headers: headers,
        body: JSON.stringify({ process_ids: selectedIds })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast(data.message, 'success');
            // Recarregar a p√°gina ap√≥s 1 segundo
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        } else {
            showToast(data.error || 'Erro ao deletar processos.', 'error');
            btn.disabled = false;
            btn.innerHTML = originalHTML;
        }
    })
    .catch(error => {
        console.error('Erro ao deletar processos:', error);
        showToast('Erro de conex√£o. Tente novamente.', 'error');
        btn.disabled = false;
        btn.innerHTML = originalHTML;
    });
}
</script>
{% endblock %}




================================================================================
FILE: templates/processes/view.html
================================================================================
{% extends "base.html" %}
{% block title %}Processo {{ process.cnj }} - Sistema Jur√≠dico Inteligente{% endblock %}

{% block content %}
<div class="page-header d-flex justify-content-between align-items-center">
  <div>
    <h1><i class="fas fa-file-alt"></i> Processo {{ process.cnj }}</h1>
    <p class="text-muted mb-0 mt-2">Detalhes e informa√ß√µes do processo <small class="text-info">(clique em um campo para editar)</small></p>
  </div>
  <div class="d-flex gap-2">
    {% if batch_id %}
    <a class="btn btn-secondary" href="{{ url_for('batch.batch_detail', id=batch_id) }}"><i class="fas fa-arrow-left me-1"></i>Voltar ao Batch</a>
    {% else %}
    <a class="btn btn-secondary" href="{{ url_for('core.process_list') }}"><i class="fas fa-arrow-left me-1"></i>Voltar</a>
    {% endif %}
    {% if process.pdf_filename %}
    <a class="btn btn-outline-danger" href="{{ url_for('core.uploaded_file', filename=process.pdf_filename) }}" target="_blank">
      <i class="fas fa-file-pdf me-1"></i>PDF
    </a>
    {% endif %}
    {% if process.elaw_screenshot_before_path %}
    <a class="btn btn-outline-success" href="{{ url_for('core.serve_rpa_screenshot', filename=process.elaw_screenshot_before_path) }}" target="_blank">
      <i class="fas fa-camera me-1"></i>Screenshot ANTES
    </a>
    {% endif %}
    {% if process.elaw_screenshot_after_path %}
    <a class="btn btn-outline-primary" href="{{ url_for('core.serve_rpa_screenshot', filename=process.elaw_screenshot_after_path) }}" target="_blank">
      <i class="fas fa-camera-retro me-1"></i>Screenshot DEPOIS
    </a>
    {% endif %}
    {% if process.elaw_screenshot_reclamadas_path %}
    <a class="btn btn-outline-warning" href="{{ url_for('core.serve_rpa_screenshot', filename=process.elaw_screenshot_reclamadas_path) }}" target="_blank">
      <i class="fas fa-users me-1"></i>Screenshot RECLAMADAS
    </a>
    {% endif %}
    {% if process.elaw_screenshot_path and not process.elaw_screenshot_before_path %}
    <a class="btn btn-outline-primary" href="{{ url_for('core.process_screenshot', id=process.id) }}" target="_blank">
      <i class="fas fa-camera me-1"></i>Screenshot eLaw
    </a>
    {% endif %}
    {% if batch_id %}
    <a class="btn btn-warning" href="{{ url_for('core.process_edit', id=process.id, batch_id=batch_id) }}">
      <i class="fas fa-edit me-1"></i>Editar Tudo
    </a>
    {% else %}
    <a class="btn btn-warning" href="{{ url_for('core.process_edit', id=process.id) }}">
      <i class="fas fa-edit me-1"></i>Editar Tudo
    </a>
    {% endif %}
    {% if process.elaw_status == 'pending' %}
    {% if batch_id %}
    <form method="POST" action="{{ url_for('core.process_fill_elaw', id=process.id, batch_id=batch_id) }}" style="display: inline;">
      <button type="submit" class="btn btn-success">
        <i class="fas fa-paper-plane me-1"></i>Preencher no eLaw
      </button>
    </form>
    {% else %}
    <form method="POST" action="{{ url_for('core.process_fill_elaw', id=process.id) }}" style="display: inline;">
      <button type="submit" class="btn btn-success">
        <i class="fas fa-paper-plane me-1"></i>Preencher no eLaw
      </button>
    </form>
    {% endif %}
    {% elif process.elaw_status == 'error' %}
    {% if batch_id %}
    <form method="POST" action="{{ url_for('core.process_fill_elaw', id=process.id, batch_id=batch_id) }}" style="display: inline;">
      <button type="submit" class="btn btn-warning">
        <i class="fas fa-redo me-1"></i>Tentar Novamente
      </button>
    </form>
    {% else %}
    <form method="POST" action="{{ url_for('core.process_fill_elaw', id=process.id) }}" style="display: inline;">
      <button type="submit" class="btn btn-warning">
        <i class="fas fa-redo me-1"></i>Tentar Novamente
      </button>
    </form>
    {% endif %}
    {% elif process.elaw_status == 'running' %}
    <a class="btn btn-info disabled" href="#">
      <i class="fas fa-spinner fa-spin me-1"></i>Preenchendo...
    </a>
    {% elif process.elaw_status == 'success' %}
    <button class="btn btn-success disabled">
      <i class="fas fa-check-circle me-1"></i>Preenchido
    </button>
    {% endif %}
  </div>
</div>

{% set missing_fields = process.get_missing_critical_fields() %}
{% set has_missing = missing_fields|length > 0 %}
{% set total_critical = process.CRITICAL_FIELDS|length %}
{% set filled_count = total_critical - missing_fields|length %}
<div id="fields-status-alert" class="alert {% if has_missing %}alert-warning{% else %}alert-success{% endif %} mt-3 d-flex align-items-center justify-content-between">
  <div>
    {% if has_missing %}
    <i class="fas fa-exclamation-triangle me-2"></i>
    <strong>Campos RPA faltando ({{ missing_fields|length }}):</strong> <span id="missing-fields-list">{{ missing_fields[:5]|join(', ') }}{% if missing_fields|length > 5 %}...{% endif %}</span>
    <small class="ms-2 text-muted">(clique nos campos para editar)</small>
    {% else %}
    <i class="fas fa-check-circle me-2"></i>
    <strong>Todos os campos cr√≠ticos preenchidos!</strong>
    <small class="ms-2 text-muted">Pronto para RPA</small>
    {% endif %}
  </div>
  <span id="fields-status-badge" class="badge {% if has_missing %}bg-warning text-dark{% else %}bg-success{% endif %}">
    {{ filled_count }}/{{ total_critical }}
  </span>
</div>

{% if process.elaw_status == 'error' and process.elaw_error_message %}
<div class="alert alert-danger alert-dismissible fade show mt-3" role="alert">
  <h5 class="alert-heading"><i class="fas fa-exclamation-triangle me-2"></i>Erro no Preenchimento Autom√°tico</h5>
  <p class="mb-0">{{ process.elaw_error_message }}</p>
  <hr>
  <p class="mb-0 small">Voc√™ pode tentar novamente clicando no bot√£o "Tentar Novamente" acima.</p>
  <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
</div>
{% endif %}

<style>
.editable-field {
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
}
.editable-field:hover {
  background-color: rgba(13, 110, 253, 0.1) !important;
}
.editable-field:hover::after {
  content: '\f303';
  font-family: 'Font Awesome 6 Free', 'Font Awesome 5 Free';
  font-weight: 900;
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: #0d6efd;
  font-size: 0.8rem;
}
.editable-field.editing {
  background-color: #fff !important;
  box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25);
}
.editable-field .field-value {
  min-height: 24px;
}
.editable-field .edit-input {
  display: none;
  width: 100%;
}
.editable-field.editing .field-value {
  display: none;
}
.editable-field.editing .edit-input {
  display: block;
}
.editable-field .edit-actions {
  display: none;
  margin-top: 8px;
}
.editable-field.editing .edit-actions {
  display: flex;
  gap: 5px;
}
.save-indicator {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 9999;
  display: none;
}
</style>

<div class="save-indicator">
  <div class="alert alert-success py-2 px-3 mb-0" id="save-success" style="display:none;">
    <i class="fas fa-check-circle me-1"></i> Salvo com sucesso!
  </div>
  <div class="alert alert-danger py-2 px-3 mb-0" id="save-error" style="display:none;">
    <i class="fas fa-times-circle me-1"></i> Erro ao salvar
  </div>
</div>

<div class="row g-4 mt-2">
  <!-- Dados Principais -->
  <div class="col-12">
    <div class="card border-primary">
      <div class="card-header bg-primary text-white">
        <h5 class="mb-0"><i class="fas fa-info-circle me-2"></i>Dados Principais</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="cnj">
              <strong class="text-muted d-block mb-1"><i class="fas fa-gavel me-1"></i>CNJ</strong>
              <span class="field-value fs-5">{{ process.cnj or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.cnj or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="tipo_processo">
              <strong class="text-muted d-block mb-1"><i class="fas fa-folder me-1"></i>Tipo</strong>
              <span class="field-value fs-5">{{ process.tipo_processo or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.tipo_processo or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="numero_processo">
              <strong class="text-muted d-block mb-1"><i class="fas fa-hashtag me-1"></i>N¬∫ Processo</strong>
              <span class="field-value fs-5">{{ process.numero_processo or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.numero_processo or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="estado">
              <strong class="text-muted d-block mb-1"><i class="fas fa-map-marker-alt me-1"></i>Estado</strong>
              <span class="field-value fs-5">{{ process.estado or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.estado or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="comarca">
              <strong class="text-muted d-block mb-1"><i class="fas fa-building me-1"></i>Comarca</strong>
              <span class="field-value fs-5">{{ process.comarca or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.comarca or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="origem">
              <strong class="text-muted d-block mb-1"><i class="fas fa-sitemap me-1"></i>Origem</strong>
              <span class="field-value fs-5">{{ process.origem or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.origem or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="orgao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-landmark me-1"></i>√ìrg√£o</strong>
              <span class="field-value fs-5">{{ process.orgao or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.orgao or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="celula">
              <strong class="text-muted d-block mb-1"><i class="fas fa-layer-group me-1"></i>C√©lula</strong>
              <span class="field-value fs-5">{{ process.celula or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.celula or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="foro">
              <strong class="text-muted d-block mb-1"><i class="fas fa-balance-scale me-1"></i>Foro</strong>
              <span class="field-value fs-5">{{ process.foro or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.foro or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="instancia">
              <strong class="text-muted d-block mb-1"><i class="fas fa-level-up-alt me-1"></i>Inst√¢ncia</strong>
              <span class="field-value fs-5">{{ process.instancia or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.instancia or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="vara">
              <strong class="text-muted d-block mb-1"><i class="fas fa-university me-1"></i>Vara</strong>
              <span class="field-value fs-5">{{ process.vara or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.vara or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="assunto">
              <strong class="text-muted d-block mb-1"><i class="fas fa-tag me-1"></i>Assunto</strong>
              <span class="field-value fs-5">{{ process.assunto or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.assunto or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="objeto">
              <strong class="text-muted d-block mb-1"><i class="fas fa-bullseye me-1"></i>Objeto</strong>
              <span class="field-value fs-5">{{ process.objeto or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.objeto or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Partes e Representa√ß√£o -->
  <div class="col-12">
    <div class="card border-primary">
      <div class="card-header bg-primary text-white">
        <h5 class="mb-0"><i class="fas fa-user-tie me-2"></i>Partes e Representa√ß√£o</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="cliente">
              <strong class="text-muted d-block mb-1"><i class="fas fa-user-shield me-1"></i>Cliente</strong>
              <span class="field-value fs-5">{{ process.cliente or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.cliente or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="parte">
              <strong class="text-muted d-block mb-1"><i class="fas fa-user-tag me-1"></i>Parte (posi√ß√£o)</strong>
              <span class="field-value fs-5">{{ process.parte or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.parte or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="advogado_autor">
              <strong class="text-muted d-block mb-1"><i class="fas fa-user-graduate me-1"></i>Advogado do Autor/Cliente</strong>
              <span class="field-value fs-5">{{ process.advogado_autor or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.advogado_autor or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="advogado_reu">
              <strong class="text-muted d-block mb-1"><i class="fas fa-user-tie me-1"></i>Advogado do R√©u/Parte</strong>
              <span class="field-value fs-5">{{ process.advogado_reu or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.advogado_reu or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="posicao_parte_interessada">
              <strong class="text-muted d-block mb-1"><i class="fas fa-users-cog me-1"></i>Posi√ß√£o Parte Interessada</strong>
              <span class="field-value fs-5">{{ process.posicao_parte_interessada or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.posicao_parte_interessada or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="parte_interessada">
              <strong class="text-muted d-block mb-1"><i class="fas fa-user-friends me-1"></i>Parte Interessada</strong>
              <span class="field-value fs-5">{{ process.parte_interessada or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.parte_interessada or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="parte_adversa_tipo">
              <strong class="text-muted d-block mb-1"><i class="fas fa-user-slash me-1"></i>Parte Adversa (tipo)</strong>
              <span class="field-value fs-5">{{ process.parte_adversa_tipo or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.parte_adversa_tipo or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-9">
            <div class="p-3 bg-light rounded editable-field" data-field="parte_adversa_nome">
              <strong class="text-muted d-block mb-1"><i class="fas fa-user-alt-slash me-1"></i>Nome Parte Adversa</strong>
              <span class="field-value fs-5">{{ process.parte_adversa_nome or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.parte_adversa_nome or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="escritorio_parte_adversa">
              <strong class="text-muted d-block mb-1"><i class="fas fa-building me-1"></i>Escrit√≥rio Parte Adversa</strong>
              <span class="field-value fs-5">{{ process.escritorio_parte_adversa or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.escritorio_parte_adversa or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-2">
            <div class="p-3 bg-light rounded editable-field" data-field="uf_oab_advogado_adverso">
              <strong class="text-muted d-block mb-1"><i class="fas fa-id-badge me-1"></i>UF OAB</strong>
              <span class="field-value fs-5">{{ process.uf_oab_advogado_adverso or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.uf_oab_advogado_adverso or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="cpf_cnpj_parte_adversa">
              <strong class="text-muted d-block mb-1"><i class="fas fa-id-card me-1"></i>CPF/CNPJ Parte Adversa</strong>
              <span class="field-value fs-5">{{ process.cpf_cnpj_parte_adversa or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.cpf_cnpj_parte_adversa or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="telefone_parte_adversa">
              <strong class="text-muted d-block mb-1"><i class="fas fa-phone me-1"></i>Telefone Parte Adversa</strong>
              <span class="field-value fs-5">{{ process.telefone_parte_adversa or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.telefone_parte_adversa or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="email_parte_adversa">
              <strong class="text-muted d-block mb-1"><i class="fas fa-envelope me-1"></i>Email Parte Adversa</strong>
              <span class="field-value fs-5">{{ process.email_parte_adversa or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.email_parte_adversa or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="endereco_parte_adversa">
              <strong class="text-muted d-block mb-1"><i class="fas fa-map-marked-alt me-1"></i>Endere√ßo Parte Adversa</strong>
              <span class="field-value fs-5">{{ process.endereco_parte_adversa or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.endereco_parte_adversa or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Dados Trabalhistas (RPA) -->
  <div class="col-12">
    <div class="card border-success">
      <div class="card-header bg-success text-white">
        <h5 class="mb-0"><i class="fas fa-briefcase me-2"></i>Dados Trabalhistas <small class="ms-2 opacity-75">(campos RPA - priorit√°rios)</small></h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="data_admissao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-calendar-plus me-1"></i>Data de Admiss√£o</strong>
              <span class="field-value fs-5 {% if not process.data_admissao %}text-danger{% endif %}">{{ process.data_admissao or 'N√£o informado' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.data_admissao or '' }}" placeholder="DD/MM/AAAA">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="data_demissao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-calendar-minus me-1"></i>Data de Demiss√£o</strong>
              <span class="field-value fs-5 {% if not process.data_demissao %}text-danger{% endif %}">{{ process.data_demissao or 'N√£o informado' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.data_demissao or '' }}" placeholder="DD/MM/AAAA">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="salario">
              <strong class="text-muted d-block mb-1"><i class="fas fa-dollar-sign me-1"></i>Sal√°rio</strong>
              <span class="field-value fs-5 {% if not process.salario %}text-danger{% endif %}">{{ process.salario or 'N√£o informado' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.salario or '' }}" placeholder="R$ 0.000,00">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="motivo_demissao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-sign-out-alt me-1"></i>Motivo da Demiss√£o</strong>
              <span class="field-value fs-5">{{ process.motivo_demissao or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.motivo_demissao or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="cargo_funcao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-id-badge me-1"></i>Cargo/Fun√ß√£o</strong>
              <span class="field-value fs-5 {% if not process.cargo_funcao %}text-danger{% endif %}">{{ process.cargo_funcao or 'N√£o informado' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.cargo_funcao or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="pis">
              <strong class="text-muted d-block mb-1"><i class="fas fa-id-card me-1"></i>PIS</strong>
              <span class="field-value fs-5 {% if not process.pis %}text-danger{% endif %}">{{ process.pis or 'N√£o informado' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.pis or '' }}" placeholder="XXX.XXXXX.XX-X">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="ctps">
              <strong class="text-muted d-block mb-1"><i class="fas fa-address-card me-1"></i>CTPS</strong>
              <span class="field-value fs-5 {% if not process.ctps %}text-danger{% endif %}">{{ process.ctps or 'N√£o informado' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.ctps or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="empregador">
              <strong class="text-muted d-block mb-1"><i class="fas fa-building me-1"></i>Empregador</strong>
              <span class="field-value fs-5">{{ process.empregador or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.empregador or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-12">
            <div class="p-3 bg-light rounded editable-field" data-field="local_trabalho">
              <strong class="text-muted d-block mb-1"><i class="fas fa-map-marker-alt me-1"></i>Local de Trabalho</strong>
              <span class="field-value fs-5">{{ process.local_trabalho or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.local_trabalho or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Prazos / Audi√™ncia / Decis√£o -->
  <div class="col-12">
    <div class="card border-primary">
      <div class="card-header bg-primary text-white">
        <h5 class="mb-0"><i class="fas fa-gavel me-2"></i>Prazos, Audi√™ncias e Decis√µes</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="prazo">
              <strong class="text-muted d-block mb-1"><i class="fas fa-clock me-1"></i>Prazo</strong>
              <span class="field-value fs-5">{{ process.prazo or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.prazo or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="audiencia_inicial">
              <strong class="text-muted d-block mb-1"><i class="fas fa-calendar-check me-1"></i>Audi√™ncia Inicial</strong>
              <span class="field-value fs-5">
                {{ process.audiencia_inicial or '-' }}
                {% if process.subtipo_audiencia %}
                  <br><small class="text-muted"><i class="fas fa-tag"></i> {{ process.subtipo_audiencia }}</small>
                {% endif %}
                {% if process.envolvido_audiencia %}
                  <br><small class="text-muted"><i class="fas fa-users"></i> {{ process.envolvido_audiencia }}</small>
                {% endif %}
              </span>
              <input type="text" class="form-control edit-input" value="{{ process.audiencia_inicial or '' }}" placeholder="DD/MM/AAAA HH:MM">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="tipo_notificacao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-bell me-1"></i>Tipo de Notifica√ß√£o</strong>
              <span class="field-value fs-5">{{ process.tipo_notificacao or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.tipo_notificacao or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          {% if process.link_audiencia %}
          <div class="col-md-12">
            <div class="p-3 bg-info bg-opacity-10 rounded">
              <strong class="text-muted d-block mb-1"><i class="fas fa-video me-1"></i>Link da Audi√™ncia (Telepresencial)</strong>
              <a href="{{ process.link_audiencia }}" target="_blank" rel="noopener" class="text-primary fs-5">
                <i class="fas fa-external-link-alt me-1"></i>{{ process.link_audiencia }}
              </a>
            </div>
          </div>
          {% endif %}
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="subtipo_audiencia">
              <strong class="text-muted d-block mb-1"><i class="fas fa-tag me-1"></i>Subtipo de Audi√™ncia</strong>
              <span class="field-value fs-5">{{ process.subtipo_audiencia or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.subtipo_audiencia or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="envolvido_audiencia">
              <strong class="text-muted d-block mb-1"><i class="fas fa-users me-1"></i>Envolvido na Audi√™ncia</strong>
              <span class="field-value fs-5">{{ process.envolvido_audiencia or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.envolvido_audiencia or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-12">
            <div class="p-3 bg-light rounded editable-field" data-field="link_audiencia">
              <strong class="text-muted d-block mb-1"><i class="fas fa-link me-1"></i>Link Audi√™ncia Telepresencial</strong>
              <span class="field-value fs-5">{{ process.link_audiencia or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.link_audiencia or '' }}" placeholder="https://...">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-12">
            <div class="p-3 bg-light rounded editable-field" data-field="resultado_audiencia">
              <strong class="text-muted d-block mb-1"><i class="fas fa-clipboard-check me-1"></i>Resultado da Audi√™ncia</strong>
              <span class="field-value fs-5">{{ process.resultado_audiencia or '-' }}</span>
              <textarea class="form-control edit-input" rows="2">{{ process.resultado_audiencia or '' }}</textarea>
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-12">
            <div class="p-3 bg-light rounded editable-field" data-field="prazos_derivados_audiencia">
              <strong class="text-muted d-block mb-1"><i class="fas fa-hourglass-half me-1"></i>Prazos Derivados da Audi√™ncia</strong>
              <span class="field-value fs-5">{{ process.prazos_derivados_audiencia or '-' }}</span>
              <textarea class="form-control edit-input" rows="2">{{ process.prazos_derivados_audiencia or '' }}</textarea>
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="decisao_tipo">
              <strong class="text-muted d-block mb-1"><i class="fas fa-balance-scale me-1"></i>Tipo de Decis√£o</strong>
              <span class="field-value fs-5">{{ process.decisao_tipo or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.decisao_tipo or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="p-3 bg-light rounded editable-field" data-field="decisao_resultado">
              <strong class="text-muted d-block mb-1"><i class="fas fa-check-double me-1"></i>Resultado da Decis√£o</strong>
              <span class="field-value fs-5">{{ process.decisao_resultado or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.decisao_resultado or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-12">
            <div class="p-3 bg-light rounded editable-field" data-field="decisao_fundamentacao_resumida">
              <strong class="text-muted d-block mb-1"><i class="fas fa-file-alt me-1"></i>Fundamenta√ß√£o Resumida</strong>
              <span class="field-value fs-5">{{ process.decisao_fundamentacao_resumida or '-' }}</span>
              <textarea class="form-control edit-input" rows="3">{{ process.decisao_fundamentacao_resumida or '' }}</textarea>
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Estrat√©gia e √çndices -->
  <div class="col-12">
    <div class="card border-primary">
      <div class="card-header bg-primary text-white">
        <h5 class="mb-0"><i class="fas fa-flag me-2"></i>Estrat√©gia e √çndices</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="estrategia">
              <strong class="text-muted d-block mb-1"><i class="fas fa-chess me-1"></i>Estrat√©gia</strong>
              <span class="field-value fs-5">{{ process.estrategia or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.estrategia or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="indice_atualizacao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-chart-line me-1"></i>√çndice de Atualiza√ß√£o</strong>
              <span class="field-value fs-5">{{ process.indice_atualizacao or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.indice_atualizacao or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="id_interno_hilo">
              <strong class="text-muted d-block mb-1"><i class="fas fa-fingerprint me-1"></i>ID Interno Hilo</strong>
              <span class="field-value fs-5">{{ process.id_interno_hilo or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.id_interno_hilo or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Outras Informa√ß√µes -->
  <div class="col-12">
    <div class="card border-primary">
      <div class="card-header bg-primary text-white">
        <h5 class="mb-0"><i class="fas fa-info-circle me-2"></i>Outras Informa√ß√µes</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="data_distribuicao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-calendar me-1"></i>Data de Distribui√ß√£o</strong>
              <span class="field-value fs-5">{{ process.data_distribuicao or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.data_distribuicao or '' }}" placeholder="DD/MM/AAAA">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="data_citacao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-calendar-day me-1"></i>Data de Cita√ß√£o</strong>
              <span class="field-value fs-5">{{ process.data_citacao or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.data_citacao or '' }}" placeholder="DD/MM/AAAA">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-2">
            <div class="p-3 bg-light rounded editable-field" data-field="risco">
              <strong class="text-muted d-block mb-1"><i class="fas fa-exclamation-triangle me-1"></i>Risco</strong>
              <span class="field-value fs-5">{{ process.risco or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.risco or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded editable-field" data-field="valor_causa">
              <strong class="text-muted d-block mb-1"><i class="fas fa-money-bill-wave me-1"></i>Valor da Causa</strong>
              <span class="field-value fs-5">{{ process.valor_causa or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.valor_causa or '' }}" placeholder="R$ 0.000,00">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="p-3 bg-light rounded editable-field" data-field="rito">
              <strong class="text-muted d-block mb-1"><i class="fas fa-route me-1"></i>Rito</strong>
              <span class="field-value fs-5">{{ process.rito or '-' }}</span>
              <input type="text" class="form-control edit-input" value="{{ process.rito or '' }}">
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-5">
            <div class="p-3 bg-light rounded editable-field" data-field="observacao">
              <strong class="text-muted d-block mb-1"><i class="fas fa-sticky-note me-1"></i>Observa√ß√£o</strong>
              <span class="field-value fs-5">{{ process.observacao or '-' }}</span>
              <textarea class="form-control edit-input" rows="2">{{ process.observacao or '' }}</textarea>
              <div class="edit-actions">
                <button class="btn btn-sm btn-success save-btn"><i class="fas fa-check"></i></button>
                <button class="btn btn-sm btn-secondary cancel-btn"><i class="fas fa-times"></i></button>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded">
              <strong class="text-muted d-block mb-1"><i class="fas fa-calendar-check me-1"></i>Cadastrar 1¬™ Audi√™ncia</strong>
              <span class="fs-5">
                {% if process.cadastrar_primeira_audiencia %}
                  <span class="badge bg-success"><i class="fas fa-check me-1"></i>Sim</span>
                {% else %}
                  <span class="badge bg-secondary"><i class="fas fa-times me-1"></i>N√£o</span>
                {% endif %}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Metadados -->
  <div class="col-12">
    <div class="card border-secondary">
      <div class="card-header bg-secondary text-white">
        <h5 class="mb-0"><i class="fas fa-database me-2"></i>Metadados</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <div class="p-3 bg-light rounded">
              <strong class="text-muted d-block mb-1"><i class="fas fa-hashtag me-1"></i>ID</strong>
              <span class="fs-5">#{{ process.id }}</span>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded">
              <strong class="text-muted d-block mb-1"><i class="fas fa-plus-circle me-1"></i>Criado em</strong>
              <span class="fs-5">{% if process.created_at %}{{ process.created_at|brazil_datetime('%d/%m/%Y %H:%M') }}{% else %}-{% endif %}</span>
            </div>
          </div>
          <div class="col-md-4">
            <div class="p-3 bg-light rounded">
              <strong class="text-muted d-block mb-1"><i class="fas fa-sync-alt me-1"></i>Atualizado em</strong>
              <span class="fs-5">{% if process.updated_at %}{{ process.updated_at|brazil_datetime('%d/%m/%Y %H:%M') }}{% else %}-{% endif %}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
const processId = {{ process.id }};

document.addEventListener('DOMContentLoaded', function() {
    const editableFields = document.querySelectorAll('.editable-field');
    
    editableFields.forEach(field => {
        const fieldValue = field.querySelector('.field-value');
        const editInput = field.querySelector('.edit-input');
        const saveBtn = field.querySelector('.save-btn');
        const cancelBtn = field.querySelector('.cancel-btn');
        
        if (!fieldValue || !editInput) return;
        
        // Clicar no campo para editar
        fieldValue.addEventListener('click', function(e) {
            e.stopPropagation();
            // Fechar outros campos em edi√ß√£o
            document.querySelectorAll('.editable-field.editing').forEach(f => {
                if (f !== field) {
                    f.classList.remove('editing');
                }
            });
            field.classList.add('editing');
            editInput.focus();
            if (editInput.tagName === 'INPUT') {
                editInput.select();
            }
        });
        
        // Salvar ao clicar no bot√£o
        if (saveBtn) {
            saveBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                saveField(field);
            });
        }
        
        // Cancelar
        if (cancelBtn) {
            cancelBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                field.classList.remove('editing');
                // Restaurar valor original
                const originalValue = fieldValue.textContent.trim();
                editInput.value = originalValue === '-' || originalValue === 'N√£o informado' ? '' : originalValue;
            });
        }
        
        // Salvar com Enter, cancelar com Escape
        editInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && editInput.tagName !== 'TEXTAREA') {
                e.preventDefault();
                saveField(field);
            } else if (e.key === 'Escape') {
                field.classList.remove('editing');
                const originalValue = fieldValue.textContent.trim();
                editInput.value = originalValue === '-' || originalValue === 'N√£o informado' ? '' : originalValue;
            }
        });
    });
    
    // Fechar ao clicar fora
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.editable-field')) {
            document.querySelectorAll('.editable-field.editing').forEach(f => {
                f.classList.remove('editing');
            });
        }
    });
});

const criticalFields = [
    'numero_processo', 'area_direito',
    'estado', 'comarca', 'numero_orgao', 'orgao', 'celula', 'foro', 'instancia',
    'assunto',
    'cliente', 'posicao_parte_interessada', 'parte_interessada', 'parte_adversa_tipo', 'parte_adversa_nome',
    'data_distribuicao', 'data_admissao', 'data_demissao',
    'salario', 'cargo_funcao', 'empregador', 'local_trabalho', 'motivo_demissao', 'pis', 'ctps',
    'valor_causa'
];
const criticalFieldLabels = {
    'numero_processo': 'N√∫mero CNJ',
    'area_direito': '√Årea do Direito',
    'estado': 'Estado',
    'comarca': 'Comarca',
    'numero_orgao': 'N¬∫ √ìrg√£o',
    'orgao': '√ìrg√£o',
    'celula': 'C√©lula',
    'foro': 'Foro',
    'instancia': 'Inst√¢ncia',
    'assunto': 'Assunto',
    'cliente': 'Cliente',
    'posicao_parte_interessada': 'Posi√ß√£o',
    'parte_interessada': 'Parte Interessada',
    'parte_adversa_tipo': 'Tipo Parte Adversa',
    'parte_adversa_nome': 'Nome Parte Adversa',
    'data_distribuicao': 'Data Distribui√ß√£o',
    'data_admissao': 'Data Admiss√£o',
    'data_demissao': 'Data Demiss√£o',
    'salario': 'Sal√°rio',
    'cargo_funcao': 'Cargo',
    'empregador': 'Empregador',
    'local_trabalho': 'Local Trabalho',
    'motivo_demissao': 'Motivo Demiss√£o',
    'pis': 'PIS',
    'ctps': 'CTPS',
    'valor_causa': 'Valor da Causa'
};
const TOTAL_CRITICAL = criticalFields.length;

function updateFieldsStatusIndicator() {
    const statusAlert = document.getElementById('fields-status-alert');
    const missingFieldsList = document.getElementById('missing-fields-list');
    const statusBadge = document.getElementById('fields-status-badge');
    
    if (!statusAlert) return;
    
    const missingFields = [];
    
    criticalFields.forEach(fieldName => {
        const field = document.querySelector(`.editable-field[data-field="${fieldName}"]`);
        if (field) {
            const fieldValue = field.querySelector('.field-value');
            const text = fieldValue ? fieldValue.textContent.trim() : '';
            if (!text || text === '-' || text === 'N√£o informado') {
                missingFields.push(criticalFieldLabels[fieldName]);
            }
        }
    });
    
    const filledCount = TOTAL_CRITICAL - missingFields.length;
    
    if (missingFields.length === 0) {
        statusAlert.className = 'alert alert-success mt-3 d-flex align-items-center justify-content-between';
        statusAlert.innerHTML = `
            <div>
                <i class="fas fa-check-circle me-2"></i>
                <strong>Todos os campos cr√≠ticos preenchidos!</strong>
                <small class="ms-2 text-muted">Pronto para RPA</small>
            </div>
            <span id="fields-status-badge" class="badge bg-success">${TOTAL_CRITICAL}/${TOTAL_CRITICAL}</span>
        `;
    } else {
        statusAlert.className = 'alert alert-warning mt-3 d-flex align-items-center justify-content-between';
        statusAlert.innerHTML = `
            <div>
                <i class="fas fa-exclamation-triangle me-2"></i>
                <strong>Campos RPA faltando (${missingFields.length}):</strong> <span id="missing-fields-list">${missingFields.slice(0, 5).join(', ')}${missingFields.length > 5 ? '...' : ''}</span>
                <small class="ms-2 text-muted">(clique nos campos para editar)</small>
            </div>
            <span id="fields-status-badge" class="badge bg-warning text-dark">${filledCount}/${TOTAL_CRITICAL}</span>
        `;
    }
}

async function saveField(field) {
    const fieldName = field.dataset.field;
    const editInput = field.querySelector('.edit-input');
    const fieldValue = field.querySelector('.field-value');
    const newValue = editInput.value.trim();
    
    const saveIndicator = document.querySelector('.save-indicator');
    const successAlert = document.getElementById('save-success');
    const errorAlert = document.getElementById('save-error');
    
    try {
        const response = await fetch(`/processos/${processId}/update-field`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                field: fieldName,
                value: newValue
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            const displayValue = newValue || '-';
            
            if (newValue) {
                fieldValue.classList.remove('text-danger');
                fieldValue.textContent = displayValue;
            } else {
                if (criticalFields.includes(fieldName)) {
                    fieldValue.classList.add('text-danger');
                    fieldValue.textContent = 'N√£o informado';
                } else {
                    fieldValue.textContent = '-';
                }
            }
            
            field.classList.remove('editing');
            
            // Atualizar indicador de status dos campos cr√≠ticos
            if (criticalFields.includes(fieldName)) {
                updateFieldsStatusIndicator();
            }
            
            saveIndicator.style.display = 'block';
            successAlert.style.display = 'block';
            errorAlert.style.display = 'none';
            setTimeout(() => {
                saveIndicator.style.display = 'none';
                successAlert.style.display = 'none';
            }, 2000);
        } else {
            throw new Error(result.error || 'Erro ao salvar');
        }
    } catch (error) {
        console.error('Erro:', error);
        saveIndicator.style.display = 'block';
        errorAlert.style.display = 'block';
        successAlert.style.display = 'none';
        setTimeout(() => {
            saveIndicator.style.display = 'none';
            errorAlert.style.display = 'none';
        }, 3000);
    }
}
</script>
{% endblock %}



================================================================================
FILE: templates/processes/create.html
================================================================================
Ôªø{% extends "base.html" %}
{% block title %}Cadastrar Processo - Sistema Jur√≠dico Inteligente{% endblock %}

{% block content %}
<div class="page-header">
  <h1><i class="fas fa-edit"></i> Cadastrar Processo</h1>
  <p class="text-muted mb-0 mt-2">Preencha os dados do processo. Campos com * s√£o obrigat√≥rios.</p>
</div>

<form method="POST" enctype="multipart/form-data" class="row g-3">
  {{ form.hidden_tag() if form is defined }}

  <!-- Requeridos -->
  <div class="col-md-4">
    <label class="form-label">CNJ *</label>
    <input type="text" class="form-control" name="cnj" required>
  </div>
  <div class="col-md-4">
    <label class="form-label">Tipo de Processo *</label>
    <input type="text" class="form-control" name="tipo_processo" required>
  </div>
  <div class="col-md-4">
    <label class="form-label">Estado *</label>
    <input type="text" class="form-control" name="estado" required>
  </div>

  <div class="col-md-4">
    <label class="form-label">Comarca *</label>
    <input type="text" class="form-control" name="comarca" required>
  </div>
  <div class="col-md-4">
    <label class="form-label">Origem *</label>
    <input type="text" class="form-control" name="origem" required>
  </div>
  <div class="col-md-4">
    <label class="form-label">√ìrg√£o *</label>
    <input type="text" class="form-control" name="orgao" required>
  </div>

  <div class="col-md-4">
    <label class="form-label">C√©lula *</label>
    <input type="text" class="form-control" name="celula" required>
  </div>
  <div class="col-md-4">
    <label class="form-label">Foro *</label>
    <input type="text" class="form-control" name="foro" required>
  </div>
  <div class="col-md-4">
    <label class="form-label">Inst√¢ncia *</label>
    <input type="text" class="form-control" name="instancia" required>
  </div>

  <div class="col-md-6">
    <label class="form-label">Assunto *</label>
    <textarea class="form-control" name="assunto" rows="2" required></textarea>
  </div>
  <div class="col-md-6">
    <label class="form-label">Objeto *</label>
    <textarea class="form-control" name="objeto" rows="2" required></textarea>
  </div>

  <!-- Opcionais originais -->
  <div class="col-md-4">
    <label class="form-label">N√∫mero do Processo</label>
    <input type="text" class="form-control" name="numero_processo">
  </div>
  <div class="col-md-4">
    <label class="form-label">N√∫mero do Processo Antigo</label>
    <input type="text" class="form-control" name="numero_processo_antigo">
  </div>
  <div class="col-md-4">
    <label class="form-label">Sistema Eletr√¥nico</label>
    <input type="text" class="form-control" name="sistema_eletronico">
  </div>

  <div class="col-md-4">
    <label class="form-label">√Årea do Direito</label>
    <input type="text" class="form-control" name="area_direito">
  </div>
  <div class="col-md-4">
    <label class="form-label">Sub√°rea do Direito</label>
    <input type="text" class="form-control" name="sub_area_direito">
  </div>
  <div class="col-md-4">
    <label class="form-label">N√∫mero do √ìrg√£o</label>
    <input type="text" class="form-control" name="numero_orgao">
  </div>

  <div class="col-md-4">
    <label class="form-label">NPC</label>
    <input type="text" class="form-control" name="npc">
  </div>
  <div class="col-md-8">
    <label class="form-label">Subobjeto</label>
    <textarea class="form-control" name="sub_objeto" rows="2"></textarea>
  </div>

  <!-- Novos campos -->
  <div class="col-12">
    <div class="card">
      <div class="card-header"><h5 class="mb-0"><i class="fas fa-user-tie me-2"></i>Partes e Representa√ß√£o</h5></div>
      <div class="card-body row g-3">
        <div class="col-md-6">
          <label class="form-label">Cliente</label>
          <input type="text" class="form-control" name="cliente">
        </div>
        <div class="col-md-6">
          <label class="form-label">Parte (posi√ß√£o no processo)</label>
          <input type="text" class="form-control" name="parte" placeholder="AUTOR / R√âU / TERCEIRO...">
        </div>
        <div class="col-md-6">
          <label class="form-label">Advogado do Autor/Cliente</label>
          <input type="text" class="form-control" name="advogado_autor">
        </div>
        <div class="col-md-6">
          <label class="form-label">Advogado do R√©u/Parte</label>
          <input type="text" class="form-control" name="advogado_reu">
        </div>

        <div class="col-md-4">
          <label class="form-label">Posi√ß√£o Parte Interessada</label>
          <input type="text" class="form-control" name="posicao_parte_interessada" placeholder="AUTOR / REU">
        </div>
        <div class="col-md-8">
          <label class="form-label">Parte Interessada</label>
          <input type="text" class="form-control" name="parte_interessada">
        </div>

        <div class="col-md-4">
          <label class="form-label">Parte Adversa (tipo)</label>
          <input type="text" class="form-control" name="parte_adversa_tipo" placeholder="FISICA / JURIDICA">
        </div>
        <div class="col-md-8">
          <label class="form-label">Nome Parte Adversa</label>
          <input type="text" class="form-control" name="parte_adversa_nome">
        </div>

        <div class="col-md-6">
          <label class="form-label">Escrit√≥rio Parte Adversa</label>
          <input type="text" class="form-control" name="escritorio_parte_adversa">
        </div>
        <div class="col-md-2">
          <label class="form-label">UF OAB Adv. Adverso</label>
          <input type="text" class="form-control" name="uf_oab_advogado_adverso" maxlength="2">
        </div>
        <div class="col-md-4">
          <label class="form-label">CPF/CNPJ Parte Adversa</label>
          <input type="text" class="form-control" name="cpf_cnpj_parte_adversa">
        </div>

        <div class="col-md-4">
          <label class="form-label">Telefone Parte Adversa</label>
          <input type="text" class="form-control" name="telefone_parte_adversa">
        </div>
        <div class="col-md-4">
          <label class="form-label">Email Parte Adversa</label>
          <input type="email" class="form-control" name="email_parte_adversa">
        </div>
        <div class="col-md-4">
          <label class="form-label">Endere√ßo Parte Adversa</label>
          <input type="text" class="form-control" name="endereco_parte_adversa">
        </div>
      </div>
    </div>
  </div>

  <div class="col-12">
    <div class="card">
      <div class="card-header"><h5 class="mb-0"><i class="fas fa-gavel me-2"></i>Prazos, Audi√™ncia e Decis√µes</h5></div>
      <div class="card-body row g-3">
        <div class="col-md-4">
          <label class="form-label">Prazo</label>
          <input type="text" class="form-control" name="prazo" placeholder="ex.: 15 dias; at√© 10/10/2025">
        </div>
        <div class="col-md-4">
          <label class="form-label">Audi√™ncia Inicial (Data/Hora)</label>
          <input type="datetime-local" class="form-control" name="audiencia_inicial">
        </div>
        <div class="col-md-4">
          <label class="form-label">Tipo de Notifica√ß√£o</label>
          <input type="text" class="form-control" name="tipo_notificacao">
        </div>

        <div class="col-md-12">
          <label class="form-label">Resultado da Audi√™ncia</label>
          <textarea class="form-control" name="resultado_audiencia" rows="2"></textarea>
        </div>
        <div class="col-md-12">
          <label class="form-label">Prazos Derivados da Audi√™ncia</label>
          <textarea class="form-control" name="prazos_derivados_audiencia" rows="2"></textarea>
        </div>

        <div class="col-md-4">
          <label class="form-label">Tipo de Decis√£o</label>
          <input type="text" class="form-control" name="decisao_tipo" placeholder="Senten√ßa / Ac√É¬≥rd√É¬£o">
        </div>
        <div class="col-md-4">
          <label class="form-label">Resultado da Decis√£o</label>
          <input type="text" class="form-control" name="decisao_resultado" placeholder="Deferido / Indeferido">
        </div>
        <div class="col-md-12">
          <label class="form-label">Fundamenta√ß√£o Resumida</label>
          <textarea class="form-control" name="decisao_fundamentacao_resumida" rows="2"></textarea>
        </div>
      </div>
    </div>
  </div>

  <div class="col-12">
    <div class="card">
      <div class="card-header"><h5 class="mb-0"><i class="fas fa-flag me-2"></i>Estrat√©gia e √çndices</h5></div>
      <div class="card-body row g-3">
        <div class="col-md-4">
          <label class="form-label">Estrat√©gia</label>
          <input type="text" class="form-control" name="estrategia">
        </div>
        <div class="col-md-4">
          <label class="form-label">√çndice de Atualiza√ß√£o</label>
          <input type="text" class="form-control" name="indice_atualizacao">
        </div>
        <div class="col-md-4">
          <label class="form-label">ID Interno Hilo</label>
          <input type="text" class="form-control" name="id_interno_hilo">
        </div>
      </div>
    </div>
  </div>

  <div class="col-12">
    <div class="card">
      <div class="card-header"><h5 class="mb-0"><i class="fas fa-info-circle me-2"></i>Outras Informa√ß√µes</h5></div>
      <div class="card-body row g-3">
        <div class="col-md-4">
          <label class="form-label">Data de Distribui√ß√£o (dd/mm/aaaa)</label>
          <input type="text" class="form-control" name="data_distribuicao">
        </div>
        <div class="col-md-4">
          <label class="form-label">Data de Cita√ß√£o (dd/mm/aaaa)</label>
          <input type="text" class="form-control" name="data_citacao">
        </div>
        <div class="col-md-4">
          <label class="form-label">Risco</label>
          <input type="text" class="form-control" name="risco" placeholder="Baixo / M√É¬©dio / Alto">
        </div>

        <div class="col-md-3">
          <label class="form-label">Valor da Causa</label>
          <input type="text" class="form-control" name="valor_causa">
        </div>
        <div class="col-md-3">
          <label class="form-label">Rito</label>
          <input type="text" class="form-control" name="rito">
        </div>
        <div class="col-md-6">
          <label class="form-label">Observa√ß√£o</label>
          <input type="text" class="form-control" name="observacao">
        </div>

        <div class="col-md-6">
          <label class="form-label d-block">Cadastrar Primeira Audi√™ncia?</label>
          <input class="form-check-input" type="checkbox" name="cadastrar_primeira_audiencia" value="y" id="chkAud">
          <label class="form-check-label ms-2" for="chkAud">Sim</label>
        </div>
        <div class="col-md-6">
          <label class="form-label">Data/Hora Cadastro Manual</label>
          <input type="datetime-local" class="form-control" name="data_hora_cadastro_manual">
        </div>
      </div>
    </div>
  </div>

  <!-- PDF -->
  <div class="col-md-12">
    <label class="form-label">Anexar PDF (opcional)</label>
    <input type="file" class="form-control" name="pdf">
  </div>

  <div class="col-12 d-flex gap-2 mt-3">
    <a href="{{ url_for('core.process_list') }}" class="btn btn-secondary"><i class="fas fa-arrow-left me-1"></i>Cancelar</a>
    <button type="submit" class="btn btn-primary"><i class="fas fa-save me-1"></i>Cadastrar Processo</button>
  </div>
</form>
{% endblock %}



================================================================================
FILE: templates/processes/edit.html
================================================================================
Ôªø{% extends "base.html" %}
{% block title %}Editar Processo - Sistema Jur√≠dico Inteligente{% endblock %}

{% block content %}
<div class="page-header d-flex justify-content-between align-items-center">
    <div>
        <h1><i class="fas fa-edit"></i> Editar Processo #{{ process_id }}</h1>
        <p class="text-muted mb-0 mt-2">Edite os dados do processo</p>
    </div>
    <div>
        {% if batch_id %}
        <a href="{{ url_for('core.process_view', id=process_id, batch_id=batch_id) }}" class="btn btn-secondary">
            <i class="fas fa-arrow-left me-1"></i>Voltar
        </a>
        {% else %}
        <a href="{{ url_for('core.process_view', id=process_id) }}" class="btn btn-secondary">
            <i class="fas fa-arrow-left me-1"></i>Voltar
        </a>
        {% endif %}
    </div>
</div>

<div class="row g-4">
  <!-- Coluna principal -->
  <div class="col-lg-9">

    <!-- Identifica√ß√£o do Processo -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-id-card me-2"></i>Identifica√ß√£o do Processo</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <!-- CNJ (Sim/N√£o) -->
          <div class="col-md-3">
            <label class="form-label d-block">CNJ <span class="text-danger">*</span></label>
            <div class="form-check">
              <input class="form-check-input" type="radio" id="cnj_sim" name="cnj" value="Sim" form="confirmForm"
                {% if data.cnj == 'Sim' %}checked{% endif %}>
              <label class="form-check-label" for="cnj_sim">Sim</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="radio" id="cnj_nao" name="cnj" value="N√£o" form="confirmForm"
                {% if data.cnj == 'N√£o' %}checked{% endif %}>
              <label class="form-check-label" for="cnj_nao">N√£o</label>
            </div>
          </div>

          <!-- Tipo de Processo -->
          <div class="col-md-3">
            <label class="form-label d-block">Tipo do Processo <span class="text-danger">*</span></label>
            <div class="form-check">
              <input class="form-check-input" type="radio" id="tp_ele" name="tipo_processo" value="Eletr√¥nico" form="confirmForm"
                {% if data.tipo_processo == 'Eletr√¥nico' %}checked{% endif %}>
              <label class="form-check-label" for="tp_ele">Eletr√¥nico</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="radio" id="tp_fis" name="tipo_processo" value="F√≠sico" form="confirmForm"
                {% if data.tipo_processo == 'F√≠sico' %}checked{% endif %}>
              <label class="form-check-label" for="tp_fis">F√≠sico</label>
            </div>
          </div>

          <!-- N√∫mero do Processo -->
          <div class="col-md-6">
            <label class="form-label">N√∫mero do Processo</label>
            <input type="text" class="form-control" name="numero_processo" form="confirmForm" value="{{ data.numero_processo or '' }}">
          </div>

          <!-- N√∫mero do Processo Antigo -->
          <div class="col-md-6">
            <label class="form-label">N√∫mero do Processo Antigo</label>
            <input type="text" class="form-control" name="numero_processo_antigo" form="confirmForm" value="{{ data.numero_processo_antigo or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Sistema e √Årea Jur√≠dica -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-sitemap me-2"></i>Sistema e √Årea Jur√≠dica</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Sistema Eletr√¥nico</label>
            <input class="form-control" name="sistema_eletronico" form="confirmForm" value="{{ data.sistema_eletronico or '' }}">
            <small class="text-muted">E-PROC, PJE, PROJUDI, TRT, etc.</small>
          </div>
          <div class="col-md-6">
            <label class="form-label">√Årea do Direito</label>
            <input class="form-control" name="area_direito" form="confirmForm" value="{{ data.area_direito or '' }}">
            <small class="text-muted">C√≠vel, Criminal, Trabalhista, etc.</small>
          </div>
          <div class="col-12">
            <label class="form-label">Sub √Årea do Direito</label>
            <input class="form-control" name="sub_area_direito" form="confirmForm" value="{{ data.sub_area_direito or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Localiza√ß√£o -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-location-dot me-2"></i>Localiza√ß√£o</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Estado <span class="text-danger">*</span></label>
            <input class="form-control" name="estado" form="confirmForm" value="{{ data.estado or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Comarca <span class="text-danger">*</span></label>
            <input class="form-control" name="comarca" form="confirmForm" value="{{ data.comarca or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">N√∫mero do √ìrg√£o</label>
            <input class="form-control" name="numero_orgao" form="confirmForm" value="{{ data.numero_orgao or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- √ìrg√£o Judicial -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-gavel me-2"></i>√ìrg√£o Judicial</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Origem <span class="text-danger">*</span></label>
            <input class="form-control" name="origem" form="confirmForm" value="{{ data.origem or '' }}">
            <small class="text-muted">TRT, TST, STF, JF, etc.</small>
          </div>
          <div class="col-md-6">
            <label class="form-label">√ìrg√£o <span class="text-danger">*</span></label>
            <input class="form-control" name="orgao" form="confirmForm" value="{{ data.orgao or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Vara</label>
            <input class="form-control" name="vara" form="confirmForm" value="{{ data.vara or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">C√©lula</label>
            <input class="form-control" name="celula" form="confirmForm" value="{{ data.celula or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Foro <span class="text-danger">*</span></label>
            <input class="form-control" name="foro" form="confirmForm" value="{{ data.foro or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Inst√¢ncia <span class="text-danger">*</span></label>
            <input class="form-control" name="instancia" form="confirmForm" value="{{ data.instancia or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Detalhes do Processo -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-info-circle me-2"></i>Detalhes do Processo</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-12">
            <label class="form-label">Assunto <span class="text-danger">*</span></label>
            <textarea class="form-control" rows="2" name="assunto" form="confirmForm">{{ data.assunto or '' }}</textarea>
          </div>
          <div class="col-md-4">
            <label class="form-label">NPC</label>
            <input class="form-control" name="npc" form="confirmForm" value="{{ data.npc or '' }}">
          </div>
          <div class="col-12">
            <label class="form-label">Objeto <span class="text-danger">*</span></label>
            <textarea class="form-control" rows="2" name="objeto" form="confirmForm">{{ data.objeto or '' }}</textarea>
          </div>
          <div class="col-12">
            <label class="form-label">Sub-Objeto</label>
            <textarea class="form-control" rows="2" name="sub_objeto" form="confirmForm">{{ data.sub_objeto or '' }}</textarea>
          </div>
        </div>
      </div>
    </div>

    <!-- Partes e Representa√ß√£o -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-people-group me-2"></i>Partes e Representa√ß√£o</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
  <label class="form-label">Cliente</label>
  <input class="form-control" name="cliente" form="confirmForm"
         value="{{ data.cliente or data.cliente_grupo or '' }}">
</div>
          <div class="col-md-6">
            <label class="form-label">Parte (posi√ß√£o)</label>
            <input class="form-control" name="parte" form="confirmForm" value="{{ data.parte or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Advogado do Autor/Cliente</label>
            <input class="form-control" name="advogado_autor" form="confirmForm" value="{{ data.advogado_autor or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Advogado do R√©u/Parte</label>
            <input class="form-control" name="advogado_reu" form="confirmForm" value="{{ data.advogado_reu or '' }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Posi√ß√£o Parte Interessada</label>
            <input class="form-control" name="posicao_parte_interessada" form="confirmForm" value="{{ data.posicao_parte_interessada or '' }}">
          </div>
          <div class="col-md-8">
            <label class="form-label">Parte Interessada</label>
            <input class="form-control" name="parte_interessada" form="confirmForm" value="{{ data.parte_interessada or '' }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Parte Adversa (tipo)</label>
            <input class="form-control" name="parte_adversa_tipo" form="confirmForm" value="{{ data.parte_adversa_tipo or '' }}">
          </div>
          <div class="col-md-8">
            <label class="form-label">Nome Parte Adversa</label>
            <input class="form-control" name="parte_adversa_nome" form="confirmForm" value="{{ data.parte_adversa_nome or '' }}">
          </div>

          <div class="col-md-3">
            <label class="form-label">UF OAB Adv. Adverso</label>
            <input class="form-control" name="uf_oab_advogado_adverso" form="confirmForm" value="{{ data.uf_oab_advogado_adverso or '' }}">
          </div>
          <div class="col-md-3">
            <label class="form-label">CPF/CNPJ Parte Adversa</label>
            <input class="form-control" name="cpf_cnpj_parte_adversa" form="confirmForm" value="{{ data.cpf_cnpj_parte_adversa or '' }}">
          </div>
          <div class="col-md-3">
            <label class="form-label">Telefone Parte Adversa</label>
            <input class="form-control" name="telefone_parte_adversa" form="confirmForm" value="{{ data.telefone_parte_adversa or '' }}">
          </div>
          <div class="col-md-3">
            <label class="form-label">Email Parte Adversa</label>
            <input class="form-control" name="email_parte_adversa" form="confirmForm" value="{{ data.email_parte_adversa or '' }}">
          </div>

          <div class="col-12">
            <label class="form-label">Endere√ßo Parte Adversa</label>
            <input class="form-control" name="endereco_parte_adversa" form="confirmForm" value="{{ data.endereco_parte_adversa or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Dados Trabalhistas (RPA) -->
    <div class="card">
      <div class="card-header bg-primary text-white">
        <h5 class="mb-0"><i class="fas fa-briefcase me-2"></i>Dados Trabalhistas <small class="ms-2 opacity-75">(campos preenchidos pelo RPA)</small></h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Data de Admiss√£o</label>
            <input class="form-control" name="data_admissao" form="confirmForm" value="{{ data.data_admissao or '' }}" placeholder="dd/mm/aaaa">
          </div>
          <div class="col-md-6">
            <label class="form-label">Data de Demiss√£o</label>
            <input class="form-control" name="data_demissao" form="confirmForm" value="{{ data.data_demissao or '' }}" placeholder="dd/mm/aaaa">
          </div>
          <div class="col-md-6">
            <label class="form-label">Sal√°rio</label>
            <input class="form-control" name="salario" form="confirmForm" value="{{ data.salario or '' }}" placeholder="R$ 0,00">
          </div>
          <div class="col-md-6">
            <label class="form-label">Motivo da Demiss√£o</label>
            <input class="form-control" name="motivo_demissao" form="confirmForm" value="{{ data.motivo_demissao or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Cargo/Fun√ß√£o</label>
            <input class="form-control" name="cargo_funcao" form="confirmForm" value="{{ data.cargo_funcao or data.cargo or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">PIS</label>
            <input class="form-control" name="pis" form="confirmForm" value="{{ data.pis or '' }}" placeholder="000.00000.00-0">
          </div>
          <div class="col-md-6">
            <label class="form-label">CTPS</label>
            <input class="form-control" name="ctps" form="confirmForm" value="{{ data.ctps or '' }}" placeholder="N√∫mero s√©rie/UF">
          </div>
          <div class="col-md-6">
            <label class="form-label">Empregador</label>
            <input class="form-control" name="empregador" form="confirmForm" value="{{ data.empregador or '' }}">
          </div>
          <div class="col-12">
            <label class="form-label">Local de Trabalho</label>
            <input class="form-control" name="local_trabalho" form="confirmForm" value="{{ data.local_trabalho or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Prazos / Decis√µes -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-calendar-check me-2"></i>Prazos e Decis√µes</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <label class="form-label">Data de Distribui√ß√£o (dd/mm/aaaa)</label>
            <input class="form-control" name="data_distribuicao" form="confirmForm" value="{{ data.data_distribuicao or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">Audi√™ncia Inicial (dd/mm/aaaa hh:mm)</label>
            <input class="form-control" name="audiencia_inicial" form="confirmForm" value="{{ data.audiencia_inicial or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">Tipo de Notifica√ß√£o</label>
            <input class="form-control" name="tipo_notificacao" form="confirmForm" value="{{ data.tipo_notificacao or '' }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Subtipo da Audi√™ncia</label>
            <input class="form-control" name="subtipo_audiencia" form="confirmForm" value="{{ data.subtipo_audiencia or '' }}" placeholder="UNA, Telepresencial...">
          </div>
          <div class="col-md-4">
            <label class="form-label">Envolvido na Audi√™ncia</label>
            <input class="form-control" name="envolvido_audiencia" form="confirmForm" value="{{ data.envolvido_audiencia or '' }}" placeholder="Advogado, Preposto...">
          </div>
          <div class="col-md-4">
            <label class="form-label">Link da Audi√™ncia</label>
            <input class="form-control" name="link_audiencia" form="confirmForm" value="{{ data.link_audiencia or '' }}" placeholder="URL telepresencial">
          </div>

          <div class="col-md-6">
            <label class="form-label">Resultado da Decis√£o</label>
            <input class="form-control" name="resultado_decisao" form="confirmForm" value="{{ data.resultado_decisao or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Fundamenta√ß√£o Resumida</label>
            <input class="form-control" name="fundamentacao_resumida" form="confirmForm" value="{{ data.fundamentacao_resumida or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Estrat√É¬©gia e Outras -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-chess-knight me-2"></i>Estrat√©gia e Outras Informa√ß√µes</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <label class="form-label">Estrat√©gia</label>
            <input class="form-control" name="estrategia" form="confirmForm" value="{{ data.estrategia or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">√çndice de Atualiza√ß√£o</label>
            <input class="form-control" name="indice_atualizacao" form="confirmForm" value="{{ data.indice_atualizacao or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">ID Interno Hilo</label>
            <input class="form-control" name="id_interno_hilo" form="confirmForm" value="{{ data.id_interno_hilo or '' }}">
          </div>
          <div class="col-md-8">
            <label class="form-label">Observa√ß√£o</label>
            <input class="form-control" name="observacao" form="confirmForm" value="{{ data.observacao or '' }}">
          </div>
          <div class="col-md-4 d-flex align-items-end">
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="chkPrimeiraAud" name="cadastrar_primeira_audiencia" form="confirmForm"
                     {% if data.cadastrar_primeira_audiencia %}checked{% endif %}>
              <label class="form-check-label" for="chkPrimeiraAud">Cadastrar Primeira Audi√™ncia?</label>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- Coluna lateral -->
  <div class="col-lg-3">
    <div class="card">
      <div class="card-header">
        <h6 class="mb-0"><i class="fas fa-circle-info me-2"></i>Status da Extra√ß√£o</h6>
      </div>
      <div class="card-body">
        <div class="d-flex align-items-start">
          <i class="fas fa-check-circle text-success me-2 mt-1"></i>
          <div>
            <strong>Extra√ß√£o Conclu√≠da</strong>
            <p class="mb-0 small text-muted">IA processou o PDF com sucesso</p>
          </div>
        </div>
        <div class="alert alert-warning mt-3 mb-0">
          <i class="fas fa-triangle-exclamation me-2"></i>
          <small>Importante: Sempre revise os dados extra√≠dos antes de salvar.</small>
        </div>
      </div>
    </div>

    <div class="card mt-3">
      <div class="card-header">
        <h6 class="mb-0"><i class="fas fa-bolt me-2"></i>A√ß√µes</h6>
      </div>
      <div class="card-body d-grid gap-2">
        <button type="submit" form="confirmForm" class="btn btn-success">
          <i class="fas fa-save me-2"></i>Salvar Altera√ß√µes
        </button>
        <a class="btn btn-outline-secondary" href="{{ url_for('core.extract_from_pdf') }}">
          <i class="fas fa-arrow-left me-2"></i>Cancelar
        </a>
        <a class="btn btn-outline-secondary" href="{{ url_for('core.process_list') }}">
          <i class="fas fa-list me-2"></i>Lista de Processos
        </a>
      </div>
    </div>
  </div>
</div>

<!-- Form vazio: os inputs usam form="confirmForm" -->
{% if batch_id %}
<form id="confirmForm" method="POST" action="{{ url_for('core.process_edit', id=process_id, batch_id=batch_id) }}"></form>
{% else %}
<form id="confirmForm" method="POST" action="{{ url_for('core.process_edit', id=process_id) }}"></form>
{% endif %}
{% endblock %}



================================================================================
FILE: templates/processes/analysis.html
================================================================================
Ôªø{% extends "base.html" %}

{% block title %}An√°lise IA - Processo {{ process.cnj|default('-', true) }} - Sistema de Processos Jur√≠dicos{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <div>
                <h2><i class="fas fa-robot me-2"></i>An√É¬°lise de IA</h2>
                <nav aria-label="breadcrumb">
                    <ol class="breadcrumb">
                        <li class="breadcrumb-item"><a href="{{ url_for('dashboard') }}">Dashboard</a></li>
                        <li class="breadcrumb-item"><a href="{{ url_for('core.process_list') }}">Processos</a></li>
                        <li class="breadcrumb-item"><a href="{{ url_for('core.process_view', id=process.id) }}">{{ process.cnj|default('-', true) }}</a></li>
                        <li class="breadcrumb-item active">An√É¬°lise IA</li>
                    </ol>
                </nav>
            </div>
            <a href="{{ url_for('core.process_view', id=process.id) }}" class="btn btn-secondary">
                <i class="fas fa-arrow-left me-1"></i>Voltar
            </a>
        </div>
    </div>
</div>

{% if analysis %}
<div class="row">
    <div class="col-md-8">
        <!-- Resumo do Documento -->
        <div class="card mb-4">
            <div class="card-header">
                <h5><i class="fas fa-file-text me-2"></i>Resumo do Documento</h5>
            </div>
            <div class="card-body">
                {% if analysis.document_summary %}
                    <p>{{ analysis.document_summary }}</p>
                {% else %}
                    <p class="text-muted">Resumo n√£o dispon√≠vel</p>
                {% endif %}
            </div>
        </div>

        <!-- Pontos Principais -->
        {% if analysis.key_points %}
        <div class="card mb-4">
            <div class="card-header">
                <h5><i class="fas fa-star me-2"></i>Pontos Principais</h5>
            </div>
            <div class="card-body">
                <ul class="list-unstyled">
                    {% for point in analysis.key_points|from_json %}
                        <li class="mb-2">
                            <i class="fas fa-check-circle text-success me-2"></i>{{ point }}
                        </li>
                    {% endfor %}
                </ul>
            </div>
        </div>
        {% endif %}

        <!-- Quest√µes Legais -->
        {% if analysis.legal_issues %}
        <div class="card mb-4">
            <div class="card-header">
                <h5><i class="fas fa-balance-scale me-2"></i>Quest√µes Legais Identificadas</h5>
            </div>
            <div class="card-body">
                <ul class="list-unstyled">
                    {% for issue in analysis.legal_issues|from_json %}
                        <li class="mb-2">
                            <i class="fas fa-exclamation-triangle text-warning me-2"></i>{{ issue }}
                        </li>
                    {% endfor %}
                </ul>
            </div>
        </div>
        {% endif %}

        <!-- Recomenda√ß√µes -->
        {% if analysis.recommendations %}
        <div class="card mb-4">
            <div class="card-header">
                <h5><i class="fas fa-lightbulb me-2"></i>Recomenda√ß√µes</h5>
            </div>
            <div class="card-body">
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>
                    {{ analysis.recommendations }}
                </div>
            </div>
        </div>
        {% endif %}

        <!-- Chunks do Documento -->
        {% if chunks %}
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-puzzle-piece me-2"></i>Trechos Analisados ({{ chunks|length }})</h5>
            </div>
            <div class="card-body">
                <div class="accordion" id="chunksAccordion">
                    {% for chunk in chunks %}
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                    data-bs-target="#chunk{{ chunk.id }}" aria-expanded="false">
                                <div class="d-flex align-items-center">
                                    <span class="badge bg-primary me-2">{{ (chunk.chunk_index + 1)|default('-', true) }}</span>
                                    <span class="text-truncate">{{ chunk.summary or "Trecho " ~ (chunk.chunk_index + 1)|string }}</span>
                                    <small class="text-muted ms-auto">{{ chunk.token_count|default(0, true) }} tokens</small>
                                </div>
                            </button>
                        </h2>
                        <div id="chunk{{ chunk.id }}" class="accordion-collapse collapse" data-bs-parent="#chunksAccordion">
                            <div class="accordion-body">
                                {% if chunk.summary %}
                                    <div class="mb-3">
                                        <strong>Resumo:</strong>
                                        <p class="mt-1">{{ chunk.summary }}</p>
                                    </div>
                                {% endif %}

                                <div class="mb-3">
                                    <strong>Conte√∫do:</strong>
                                    <div class="border rounded p-2 bg-light mt-1" style="max-height: 200px; overflow-y: auto;">
                                        <small>{{ chunk.content|default('-', true) }}</small>
                                    </div>
                                </div>

                                {% if chunk.key_entities %}
                                <div class="mb-3">
                                    <strong>Entidades:</strong>
                                    <div class="mt-1">
                                        {% for entity in chunk.key_entities|from_json %}
                                            <span class="badge bg-secondary me-1">{{ entity }}</span>
                                        {% endfor %}
                                    </div>
                                </div>
                                {% endif %}

                                {% if chunk.legal_concepts %}
                                <div class="mb-3">
                                    <strong>Conceitos Jur√≠dicos:</strong>
                                    <div class="mt-1">
                                        {% for concept in chunk.legal_concepts|from_json %}
                                            <span class="badge bg-info me-1">{{ concept }}</span>
                                        {% endfor %}
                                    </div>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
        {% endif %}
    </div>

    <!-- Sidebar -->
    <div class="col-md-4">
        <!-- Estat√≠sticas -->
        <div class="card mb-4">
            <div class="card-header">
                <h6><i class="fas fa-chart-bar me-2"></i>Estat√≠sticas</h6>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-12 mb-2">
                        <strong>Total de Chunks:</strong> {{ analysis.total_chunks|default(0, true) }}
                    </div>
                    <div class="col-12 mb-2">
                        <strong>Total de Tokens:</strong> {{ analysis.total_tokens|default(0, true) }}
                    </div>
                    <div class="col-12 mb-2">
                        <strong>Tempo de Processamento:</strong> {{ "%.1f"|format(analysis.processing_time or 0) }}s
                    </div>
                    {% if analysis.confidence_score is not none %}
                    <div class="col-12 mb-2">
                        <strong>Confian√ßa:</strong>
                        <div class="progress mt-1">
                            <div class="progress-bar" role="progressbar"
                                 style="width: {{ (analysis.confidence_score * 100)|round }}%"
                                 aria-valuenow="{{ (analysis.confidence_score * 100)|round }}"
                                 aria-valuemin="0" aria-valuemax="100">
                                {{ "%.1f"|format(analysis.confidence_score * 100) }}%
                            </div>
                        </div>
                    </div>
                    {% endif %}
                </div>

                <div class="mt-3">
                    <small class="text-muted">
                        <i class="fas fa-clock me-1"></i>Processado em:
                        {% if analysis.created_at %}
                            {{ analysis.created_at.strftime('%d/%m/%Y √É¬†s %H:%M') }}
                        {% else %}-{% endif %}
                    </small>
                </div>
            </div>
        </div>

        <!-- A√ß√µes -->
        <div class="card">
            <div class="card-header">
                <h6><i class="fas fa-tools me-2"></i>A√ß√µes</h6>
            </div>
            <div class="card-body">
                <a href="{{ url_for('rag_search') }}?q={{ process.cnj|default('', true) }}" class="btn btn-primary w-100 mb-2">
                    <i class="fas fa-search me-1"></i>Buscar Conte√∫do Similar
                </a>
                {% if process.pdf_filename %}
                <a href="{{ url_for('uploaded_file', filename=process.pdf_filename) }}"
                   class="btn btn-outline-danger w-100" target="_blank">
                    <i class="fas fa-download me-1"></i>Baixar PDF Original
                </a>
                {% endif %}
            </div>
        </div>
    </div>
</div>

{% else %}
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-body text-center py-5">
                <i class="fas fa-robot fa-3x text-muted mb-3"></i>
                <h4>An√°lise n√£o encontrada</h4>
                <p class="text-muted">Este processo ainda n√£o foi analisado pela IA ou o processamento ainda est√É¬° em andamento.</p>
                <a href="{{ url_for('core.process_view', id=process.id) }}" class="btn btn-primary">
                    <i class="fas fa-arrow-left me-1"></i>Voltar ao Processo
                </a>
            </div>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}

{% block scripts %}
<script>
// JS espec√≠fico da p√°gina de an√°lise (se necess√°rio)
</script>
{% endblock %}



================================================================================
FILE: templates/processes/extract_from_pdf.html
================================================================================
Ôªø{% extends "base.html" %}

{% block title %}Criar Processo via PDF - Sistema de Processos Jur√≠dicos{% endblock %}

{% block extra_styles %}
<style>
    h2, h3, h4, h5, h6 {
        color: white !important;
    }
    .breadcrumb {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px 15px;
        border-radius: 8px;
    }
    .breadcrumb-item, .breadcrumb-item a {
        color: rgba(255, 255, 255, 0.9) !important;
    }
    .breadcrumb-item.active {
        color: white !important;
    }
    .breadcrumb-item + .breadcrumb-item::before {
        color: rgba(255, 255, 255, 0.6) !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-12">
        <h2><i class="fas fa-file-upload me-2"></i>Criar Processo via PDF</h2>
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="{{ url_for('core.dashboard') }}">Dashboard</a></li>
                <li class="breadcrumb-item"><a href="{{ url_for('core.process_list') }}">Processos</a></li>
                <li class="breadcrumb-item active">Criar via PDF</li>
            </ol>
        </nav>
    </div>
</div>

<div class="row justify-content-center">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-robot me-2"></i>Extra√ß√£o Autom√°tica de Dados</h5>
            </div>
            <div class="card-body">
                <div class="row mb-4">
                    <div class="col-md-4">
                        <div class="text-center">
                            <i class="fas fa-upload fa-3x text-primary mb-2"></i>
                            <h6>1. Upload</h6>
                            <small class="text-muted">Envie seu PDF</small>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="text-center">
                            <i class="fas fa-brain fa-3x text-info mb-2"></i>
                            <h6>2. Processamento IA</h6>
                            <small class="text-muted">IA extrai dados automaticamente</small>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="text-center">
                            <i class="fas fa-check fa-3x text-success mb-2"></i>
                            <h6>3. Confirma√ß√£o</h6>
                            <small class="text-muted">Revise e salve o processo</small>
                        </div>
                    </div>
                </div>
                
                <hr class="my-4">
                
                <form method="POST" enctype="multipart/form-data" id="uploadForm">
                    
                    <div class="mb-4">
                        <label for="pdf_file" class="form-label">
                            <i class="fas fa-file-pdf me-2 text-danger"></i>Selecione o arquivo PDF
                        </label>
                        <input type="file" 
                               class="form-control form-control-lg" 
                               id="pdf_file" 
                               name="pdf_file" 
                               accept=".pdf"
                               required>
                        <div class="form-text">
                            <i class="fas fa-info-circle me-1"></i>
                            Arquivos PDF de at√© 16MB. A IA extrair√° automaticamente informa√ß√µes como CNJ, comarca, √ìrg√£o, etc.
                        </div>
                    </div>
                    
                    <div class="alert alert-info">
                        <i class="fas fa-lightbulb me-2"></i>
                        <strong>Como funciona:</strong>
                        <ul class="mb-0 mt-2">
                            <li>Nossa IA l√™ todo o conte√∫do do PDF</li>
                            <li>Identifica automaticamente campos como CNJ, comarca, √ìrg√£o, etc.</li>
                            <li>Extrai o assunto principal e objeto do processo</li>
                            <li>Voc√™ poder√° revisar e editar antes de salvar</li>
                        </ul>
                    </div>
                    
                    <div class="d-grid gap-2">
                        <button type="submit" class="btn btn-primary btn-lg" id="submitBtn">
                            <i class="fas fa-upload me-2"></i>Enviar PDF e Extrair Dados
                        </button>
                        <a href="{{ url_for('core.process_create') }}" class="btn btn-outline-secondary">
                            <i class="fas fa-edit me-2"></i>Ou criar processo manualmente
                        </a>
                    </div>
                </form>
            </div>
        </div>
        
        <div class="card mt-4">
            <div class="card-header">
                <h6><i class="fas fa-question-circle me-2"></i>Perguntas Frequentes</h6>
            </div>
            <div class="card-body">
                <div class="accordion" id="faqAccordion">
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq1">
                                Que tipos de PDF funcionam melhor?
                            </button>
                        </h2>
                        <div id="faq1" class="accordion-collapse collapse" data-bs-parent="#faqAccordion">
                            <div class="accordion-body">
                                <small>
                                    PDFs com texto pesquis√°vel funcionam melhor. Documentos escaneados tamb√©m funcionam, mas podem ter menor precis√£o na extra√ß√£o.
                                    Ideais: peti√ß√µes, senten√ßas, decis√µes judiciais, contratos com dados estruturados.
                                </small>
                            </div>
                        </div>
                    </div>
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq2">
                                Quanto tempo leva o processamento?
                            </button>
                        </h2>
                        <div id="faq2" class="accordion-collapse collapse" data-bs-parent="#faqAccordion">
                            <div class="accordion-body">
                                <small>
                                    Normalmente de 10 a 30 segundos, dependendo do tamanho do PDF. 
                                    Arquivos maiores podem levar at√© 1 minuto.
                                </small>
                            </div>
                        </div>
                    </div>
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#faq3">
                                Posso editar os dados extra√≠dos?
                            </button>
                        </h2>
                        <div id="faq3" class="accordion-collapse collapse" data-bs-parent="#faqAccordion">
                            <div class="accordion-body">
                                <small>
                                    Sim! Ap√≥s a extra√ß√£o, voc√™ ver√° todos os dados encontrados e poder√° edit√°-los antes de salvar o processo.
                                    A IA √© muito boa, mas sempre recomendamos revisar os dados.
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.getElementById('uploadForm').addEventListener('submit', function() {
    const submitBtn = document.getElementById('submitBtn');
    const fileInput = document.getElementById('pdf_file');
    
    if (fileInput.files.length > 0) {
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Processando PDF...';
        submitBtn.disabled = true;
        
        // Show processing message
        const alert = document.createElement('div');
        alert.className = 'alert alert-warning mt-3';
        alert.innerHTML = '<i class="fas fa-cog fa-spin me-2"></i>Processando PDF com IA... Por favor, aguarde.';
        document.querySelector('.card-body').appendChild(alert);
    }
});

// File validation
document.getElementById('pdf_file').addEventListener('change', function() {
    const file = this.files[0];
    if (file) {
        const fileSize = file.size / 1024 / 1024; // MB
        const fileName = file.name.toLowerCase();
        
        if (!fileName.endsWith('.pdf')) {
            alert('Por favor, selecione apenas arquivos PDF.');
            this.value = '';
            return;
        }
        
        if (fileSize > 16) {
            alert('O arquivo √© muito grande. M√°ximo permitido: 16MB.');
            this.value = '';
            return;
        }
        
        // Update UI to show selected file
        const submitBtn = document.getElementById('submitBtn');
        submitBtn.innerHTML = '<i class="fas fa-upload me-2"></i>Processar ' + file.name;
    }
});
</script>
{% endblock %}



================================================================================
FILE: templates/processes/confirm_extracted.html
================================================================================
Ôªø{% extends "base.html" %}
{% block title %}Confirmar Dados - Extra√ß√£o por IA{% endblock %}

{% block content %}
<div class="alert alert-success d-flex align-items-center">
  <i class="fas fa-robot me-2"></i>
  <div><strong>Dados extra√≠dos com sucesso!</strong> Revise as informa√ß√µes abaixo e fa√ßa ajustes se necess√°rio antes de salvar o processo.</div>
</div>

<form id="confirmForm" method="POST" action="{{ url_for('core.confirm_extracted') }}">
<div class="row g-4">
  <!-- Coluna principal -->
  <div class="col-lg-9">

    <!-- Identifica√ß√£o do Processo -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-id-card me-2"></i>Identifica√ß√£o do Processo</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <!-- CNJ (Sim/N√£o) -->
          <div class="col-md-3">
            <label class="form-label d-block">CNJ <span class="text-danger">*</span></label>
            <div class="form-check">
              <input class="form-check-input" type="radio" id="cnj_sim" name="cnj" value="Sim"
                {% if data.cnj == 'Sim' %}checked{% endif %}>
              <label class="form-check-label" for="cnj_sim">Sim</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="radio" id="cnj_nao" name="cnj" value="N√£o"
                {% if data.cnj == 'N√£o' %}checked{% endif %}>
              <label class="form-check-label" for="cnj_nao">N√£o</label>
            </div>
          </div>

          <!-- Tipo de Processo -->
          <div class="col-md-3">
            <label class="form-label d-block">Tipo do Processo <span class="text-danger">*</span></label>
            <div class="form-check">
              <input class="form-check-input" type="radio" id="tp_ele" name="tipo_processo" value="Eletr√¥nico"
                {% if data.tipo_processo == 'Eletr√¥nico' %}checked{% endif %}>
              <label class="form-check-label" for="tp_ele">Eletr√¥nico</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="radio" id="tp_fis" name="tipo_processo" value="F√≠sico"
                {% if data.tipo_processo == 'F√≠sico' %}checked{% endif %}>
              <label class="form-check-label" for="tp_fis">F√≠sico</label>
            </div>
          </div>

          <!-- N√∫mero do Processo -->
          <div class="col-md-6">
            <label class="form-label">N√∫mero do Processo</label>
            <input type="text" class="form-control" name="numero_processo" value="{{ data.numero_processo or '' }}">
          </div>

          <!-- N√∫mero do Processo Antigo -->
          <div class="col-md-6">
            <label class="form-label">N√∫mero do Processo Antigo</label>
            <input type="text" class="form-control" name="numero_processo_antigo" value="{{ data.numero_processo_antigo or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Sistema e √Årea Jur√≠dica -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-sitemap me-2"></i>Sistema e √Årea Jur√≠dica</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Sistema Eletr√¥nico</label>
            <input class="form-control" name="sistema_eletronico" value="{{ data.sistema_eletronico or '' }}">
            <small class="text-muted">E-PROC, PJE, PROJUDI, TRT, etc.</small>
          </div>
          <div class="col-md-6">
            <label class="form-label">√Årea do Direito</label>
            <input class="form-control" name="area_direito" value="{{ data.area_direito or '' }}">
            <small class="text-muted">C√≠vel, Criminal, Trabalhista, etc.</small>
          </div>
          <div class="col-12">
            <label class="form-label">Sub √Årea do Direito</label>
            <input class="form-control" name="sub_area_direito" value="{{ data.sub_area_direito or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Localiza√ß√£o -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-location-dot me-2"></i>Localiza√ß√£o</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Estado <span class="text-danger">*</span></label>
            <input class="form-control" name="estado" value="{{ data.estado or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Comarca <span class="text-danger">*</span></label>
            <input class="form-control" name="comarca" value="{{ data.comarca or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">N√∫mero do √ìrg√£o</label>
            <input class="form-control" name="numero_orgao" value="{{ data.numero_orgao or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- √ìrg√£o Judicial -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-gavel me-2"></i>√ìrg√£o Judicial</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label class="form-label">Origem <span class="text-danger">*</span></label>
            <input class="form-control" name="origem" value="{{ data.origem or '' }}">
            <small class="text-muted">TRT, TST, STF, JF, etc.</small>
          </div>
          <div class="col-md-6">
            <label class="form-label">√ìrg√£o <span class="text-danger">*</span></label>
            <input class="form-control" name="orgao" value="{{ data.orgao or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Vara</label>
            <input class="form-control" name="vara" value="{{ data.vara or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">C√©lula</label>
            <input class="form-control" name="celula" value="{{ data.celula or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Foro <span class="text-danger">*</span></label>
            <input class="form-control" name="foro" value="{{ data.foro or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Inst√¢ncia <span class="text-danger">*</span></label>
            <input class="form-control" name="instancia" value="{{ data.instancia or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Detalhes do Processo -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-info-circle me-2"></i>Detalhes do Processo</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-12">
            <label class="form-label">Assunto <span class="text-danger">*</span></label>
            <textarea class="form-control" rows="2" name="assunto">{{ data.assunto or '' }}</textarea>
          </div>
          <div class="col-md-4">
            <label class="form-label">NPC</label>
            <input class="form-control" name="npc" value="{{ data.npc or '' }}">
          </div>
          <div class="col-12">
            <label class="form-label">Objeto <span class="text-danger">*</span></label>
            <textarea class="form-control" rows="2" name="objeto">{{ data.objeto or '' }}</textarea>
          </div>
          <div class="col-12">
            <label class="form-label">Sub-Objeto</label>
            <textarea class="form-control" rows="2" name="sub_objeto">{{ data.sub_objeto or '' }}</textarea>
          </div>
        </div>
      </div>
    </div>

    <!-- Partes e Representa√ß√£o -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-people-group me-2"></i>Partes e Representa√ß√£o</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
  <label class="form-label">Cliente</label>
  <input class="form-control" name="cliente"
         value="{{ data.cliente or data.cliente_grupo or '' }}">
</div>
          <div class="col-md-6">
            <label class="form-label">Parte (posi√ß√£o)</label>
            <input class="form-control" name="parte" value="{{ data.parte or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Advogado do Autor/Cliente</label>
            <input class="form-control" name="advogado_autor" value="{{ data.advogado_autor or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Advogado do R√©u/Parte</label>
            <input class="form-control" name="advogado_reu" value="{{ data.advogado_reu or '' }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Posi√ß√£o Parte Interessada</label>
            <input class="form-control" name="posicao_parte_interessada" value="{{ data.posicao_parte_interessada or '' }}">
          </div>
          <div class="col-md-8">
            <label class="form-label">Parte Interessada</label>
            <input class="form-control" name="parte_interessada" value="{{ data.parte_interessada or '' }}">
          </div>

          <div class="col-md-4">
            <label class="form-label">Parte Adversa (tipo)</label>
            <input class="form-control" name="parte_adversa_tipo" value="{{ data.parte_adversa_tipo or '' }}">
          </div>
          <div class="col-md-8">
            <label class="form-label">Nome Parte Adversa</label>
            <input class="form-control" name="parte_adversa_nome" value="{{ data.parte_adversa_nome or '' }}">
          </div>

          <div class="col-md-3">
            <label class="form-label">UF OAB Adv. Adverso</label>
            <input class="form-control" name="uf_oab_advogado_adverso" value="{{ data.uf_oab_advogado_adverso or '' }}">
          </div>
          <div class="col-md-3">
            <label class="form-label">CPF/CNPJ Parte Adversa</label>
            <input class="form-control" name="cpf_cnpj_parte_adversa" value="{{ data.cpf_cnpj_parte_adversa or '' }}">
          </div>
          <div class="col-md-3">
            <label class="form-label">Telefone Parte Adversa</label>
            <input class="form-control" name="telefone_parte_adversa" value="{{ data.telefone_parte_adversa or '' }}">
          </div>
          <div class="col-md-3">
            <label class="form-label">Email Parte Adversa</label>
            <input class="form-control" name="email_parte_adversa" value="{{ data.email_parte_adversa or '' }}">
          </div>

          <div class="col-12">
            <label class="form-label">Endere√ßo Parte Adversa</label>
            <input class="form-control" name="endereco_parte_adversa" value="{{ data.endereco_parte_adversa or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Prazos / Decis√µes -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-calendar-check me-2"></i>Prazos e Decis√µes</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <label class="form-label">Data de Distribui√ß√£o (dd/mm/aaaa)</label>
            <input class="form-control" name="data_distribuicao" value="{{ data.data_distribuicao or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">Audi√™ncia Inicial (dd/mm/aaaa hh:mm)</label>
            <input class="form-control" name="audiencia_inicial" value="{{ data.audiencia_inicial or '' }}">
          </div>
          <div class="col-md-3">
            <label class="form-label">SubTipo Audi√™ncia</label>
            <input class="form-control" name="subtipo_audiencia" value="{{ data.subtipo_audiencia or '' }}" placeholder="Ex: Una">
          </div>
          <div class="col-md-3">
            <label class="form-label">Envolvidos</label>
            <input class="form-control" name="envolvido_audiencia" value="{{ data.envolvido_audiencia or '' }}" placeholder="Ex: Advogado e Preposto">
          </div>
          <div class="col-md-6">
            <label class="form-label">Link da Audi√™ncia (Zoom/Meet/Teams)</label>
            <div class="input-group">
              <input class="form-control" name="link_audiencia" value="{{ data.link_audiencia or '' }}" placeholder="https://...">
              {% if data.link_audiencia %}
                <a href="{{ data.link_audiencia }}" target="_blank" class="btn btn-outline-primary" title="Abrir link em nova aba">
                  <i class="fas fa-external-link-alt"></i>
                </a>
              {% endif %}
            </div>
          </div>
          <div class="col-md-4">
            <label class="form-label">Tipo de Notifica√ß√£o</label>
            <input class="form-control" name="tipo_notificacao" value="{{ data.tipo_notificacao or '' }}">
          </div>

          <div class="col-md-6">
            <label class="form-label">Resultado da Decis√£o</label>
            <input class="form-control" name="resultado_decisao" value="{{ data.resultado_decisao or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Fundamenta√ß√£o Resumida</label>
            <input class="form-control" name="fundamentacao_resumida" value="{{ data.fundamentacao_resumida or '' }}">
          </div>
        </div>
      </div>
    </div>

    <!-- Estrat√É¬©gia e Outras -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-chess-knight me-2"></i>Estrat√©gia e Outras Informa√ß√µes</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <label class="form-label">Valor da Causa</label>
            <input class="form-control" name="valor_causa" value="{{ data.valor_causa or '' }}" placeholder="Ex: 462.289,03">
            <small class="text-muted">Formato: 1.000,00</small>
          </div>
          <div class="col-md-4">
            <label class="form-label">Estrat√©gia</label>
            <input class="form-control" name="estrategia" value="{{ data.estrategia or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">√çndice de Atualiza√ß√£o</label>
            <input class="form-control" name="indice_atualizacao" value="{{ data.indice_atualizacao or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">ID Interno Hilo</label>
            <input class="form-control" name="id_interno_hilo" value="{{ data.id_interno_hilo or '' }}">
          </div>
          <div class="col-md-8">
            <label class="form-label">Observa√ß√£o</label>
            <input class="form-control" name="observacao" value="{{ data.observacao or '' }}">
          </div>
          <div class="col-md-4 d-flex align-items-end">
            <div class="form-check">
              <input class="form-check-input" type="checkbox" id="chkPrimeiraAud" name="cadastrar_primeira_audiencia"
                     {% if data.cadastrar_primeira_audiencia %}checked{% endif %}>
              <label class="form-check-label" for="chkPrimeiraAud">Cadastrar Primeira Audi√™ncia?</label>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Dados Trabalhistas -->
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="fas fa-briefcase me-2"></i>Dados Trabalhistas</h5>
      </div>
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <label class="form-label">Data de Admiss√£o</label>
            <input class="form-control" name="data_admissao" value="{{ data.data_admissao or '' }}" placeholder="dd/mm/aaaa">
          </div>
          <div class="col-md-4">
            <label class="form-label">Data de Demiss√£o</label>
            <input class="form-control" name="data_demissao" value="{{ data.data_demissao or '' }}" placeholder="dd/mm/aaaa">
          </div>
          <div class="col-md-4">
            <label class="form-label">Sal√°rio</label>
            <input class="form-control" name="salario" value="{{ data.salario or '' }}" placeholder="R$ 5.000,00">
          </div>
          <div class="col-md-6">
            <label class="form-label">Cargo/Fun√ß√£o</label>
            <input class="form-control" name="cargo_funcao" value="{{ data.cargo_funcao or '' }}">
          </div>
          <div class="col-md-6">
            <label class="form-label">Empregador</label>
            <input class="form-control" name="empregador" value="{{ data.empregador or '' }}" placeholder="Nome da empresa empregadora">
          </div>
          <div class="col-md-12">
            <label class="form-label">Local de Trabalho</label>
            <input class="form-control" name="local_trabalho" value="{{ data.local_trabalho or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">PIS</label>
            <input class="form-control" name="pis" value="{{ data.pis or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">CTPS</label>
            <input class="form-control" name="ctps" value="{{ data.ctps or '' }}">
          </div>
          <div class="col-md-4">
            <label class="form-label">Motivo de Demiss√£o</label>
            <input class="form-control" name="motivo_demissao" value="{{ data.motivo_demissao or '' }}">
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- Coluna lateral -->
  <div class="col-lg-3">
    <div class="card">
      <div class="card-header">
        <h6 class="mb-0"><i class="fas fa-circle-info me-2"></i>Status da Extra√ß√£o</h6>
      </div>
      <div class="card-body">
        <div class="d-flex align-items-start">
          <i class="fas fa-check-circle text-success me-2 mt-1"></i>
          <div>
            <strong>Extra√ß√£o Conclu√≠da</strong>
            <p class="mb-0 small text-muted">IA processou o PDF com sucesso</p>
          </div>
        </div>
        <div class="alert alert-warning mt-3 mb-0">
          <i class="fas fa-triangle-exclamation me-2"></i>
          <small>Importante: Sempre revise os dados extra√≠dos antes de salvar.</small>
        </div>
      </div>
    </div>

    <div class="card mt-3">
      <div class="card-header">
        <h6 class="mb-0"><i class="fas fa-bolt me-2"></i>A√ß√µes</h6>
      </div>
      <div class="card-body d-grid gap-2">
        <button type="submit" class="btn btn-success">
          <i class="fas fa-save me-2"></i>Salvar Processo
        </button>
        <a class="btn btn-outline-secondary" href="{{ url_for('core.extract_from_pdf') }}">
          <i class="fas fa-arrow-left me-2"></i>Voltar ao Upload
        </a>
        <a class="btn btn-outline-secondary" href="{{ url_for('core.process_list') }}">
          <i class="fas fa-list me-2"></i>Lista de Processos
        </a>
      </div>
    </div>
  </div>
</div>
</form>
{% endblock %}



================================================================================
FILE: templates/processes/reextract_ocr.html
================================================================================
{% extends "base.html" %}

{% block title %}Re-extra√ß√£o OCR - Sistema Jur√≠dico{% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row justify-content-center">
        <div class="col-lg-10">
            <div class="d-flex align-items-center justify-content-between mb-4">
                <div>
                    <h2 class="text-white mb-1">
                        <i class="fas fa-file-image me-2"></i>Re-extra√ß√£o OCR Seletiva
                    </h2>
                    <p class="text-white-50 mb-0">
                        Recuperar campos vazios de PDFs com anexos escaneados (TRCT, contracheques)
                    </p>
                </div>
                <a href="{{ url_for('batch.batch_list') }}" class="btn btn-outline-light">
                    <i class="fas fa-arrow-left me-2"></i>Voltar
                </a>
            </div>

            <div class="row mb-4">
                <div class="col-md-3">
                    <div class="card bg-primary text-white shadow-sm">
                        <div class="card-body text-center">
                            <h3 class="mb-1">{{ stats.total }}</h3>
                            <small>Total de Processos</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card bg-warning text-dark shadow-sm">
                        <div class="card-body text-center">
                            <h3 class="mb-1">{{ stats.sem_salario }}</h3>
                            <small><i class="fas fa-dollar-sign me-1"></i>Sem Sal√°rio</small>
                            <div class="small mt-1">{{ "%.1f"|format(stats.sem_salario / stats.total * 100 if stats.total > 0 else 0) }}%</div>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card bg-info text-white shadow-sm">
                        <div class="card-body text-center">
                            <h3 class="mb-1">{{ stats.sem_pis }}</h3>
                            <small><i class="fas fa-id-card me-1"></i>Sem PIS</small>
                            <div class="small mt-1">{{ "%.1f"|format(stats.sem_pis / stats.total * 100 if stats.total > 0 else 0) }}%</div>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card bg-secondary text-white shadow-sm">
                        <div class="card-body text-center">
                            <h3 class="mb-1">{{ stats.sem_ctps }}</h3>
                            <small><i class="fas fa-briefcase me-1"></i>Sem CTPS</small>
                            <div class="small mt-1">{{ "%.1f"|format(stats.sem_ctps / stats.total * 100 if stats.total > 0 else 0) }}%</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card shadow-lg">
                <div class="card-header bg-gradient text-white" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <h5 class="mb-0">
                        <i class="fas fa-magic me-2"></i>Iniciar Re-extra√ß√£o em Lote
                    </h5>
                </div>
                <div class="card-body">
                    <div class="alert alert-info mb-4">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Como funciona:</strong> O sistema identifica p√°ginas com anexos escaneados (TRCT, contracheques) 
                        e aplica OCR apenas nessas p√°ginas espec√≠ficas, extraindo campos que n√£o foram encontrados pelo texto nativo.
                        <br><small class="text-muted">Tempo estimado: 5-15 segundos por processo (apenas p√°ginas relevantes s√£o processadas)</small>
                    </div>

                    <form method="POST" id="reextractForm">
                        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                        
                        <div class="mb-4">
                            <label class="form-label fw-bold">Campos a recuperar:</label>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="form-check form-check-lg">
                                        <input class="form-check-input" type="checkbox" name="fields" value="salario" id="field_salario" checked>
                                        <label class="form-check-label" for="field_salario">
                                            <i class="fas fa-dollar-sign text-success me-1"></i>Sal√°rio
                                            <span class="badge bg-warning text-dark ms-2">{{ stats.sem_salario }} vazios</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="form-check form-check-lg">
                                        <input class="form-check-input" type="checkbox" name="fields" value="pis" id="field_pis" checked>
                                        <label class="form-check-label" for="field_pis">
                                            <i class="fas fa-id-card text-info me-1"></i>PIS
                                            <span class="badge bg-info ms-2">{{ stats.sem_pis }} vazios</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="form-check form-check-lg">
                                        <input class="form-check-input" type="checkbox" name="fields" value="ctps" id="field_ctps" checked>
                                        <label class="form-check-label" for="field_ctps">
                                            <i class="fas fa-briefcase text-secondary me-1"></i>CTPS
                                            <span class="badge bg-secondary ms-2">{{ stats.sem_ctps }} vazios</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="mb-4">
                            <label for="limit" class="form-label fw-bold">Quantidade de processos:</label>
                            <div class="row align-items-center">
                                <div class="col-md-4">
                                    <input type="range" class="form-range" id="limitRange" min="5" max="50" step="5" value="20" 
                                           oninput="document.getElementById('limit').value = this.value; document.getElementById('limitDisplay').textContent = this.value;">
                                </div>
                                <div class="col-md-2">
                                    <input type="number" class="form-control" id="limit" name="limit" value="20" min="1" max="100">
                                </div>
                                <div class="col-md-6">
                                    <small class="text-muted">
                                        Processar at√© <strong id="limitDisplay">20</strong> processos com campos vazios
                                    </small>
                                </div>
                            </div>
                        </div>

                        <div class="d-grid gap-2 d-md-flex justify-content-md-end">
                            <button type="submit" class="btn btn-lg btn-primary" id="submitBtn">
                                <i class="fas fa-play me-2"></i>Iniciar Re-extra√ß√£o OCR
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <div class="card mt-4 shadow">
                <div class="card-header bg-dark text-white">
                    <h6 class="mb-0">
                        <i class="fas fa-question-circle me-2"></i>Sobre OCR Seletivo
                    </h6>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <h6 class="text-primary">Quando usar?</h6>
                            <ul class="list-unstyled">
                                <li><i class="fas fa-check text-success me-2"></i>PDFs com anexos escaneados (TRCT/contracheques)</li>
                                <li><i class="fas fa-check text-success me-2"></i>Campos vazios ap√≥s extra√ß√£o normal</li>
                                <li><i class="fas fa-check text-success me-2"></i>Documentos h√≠bridos (texto + imagem)</li>
                            </ul>
                        </div>
                        <div class="col-md-6">
                            <h6 class="text-primary">Estrat√©gia</h6>
                            <ul class="list-unstyled">
                                <li><i class="fas fa-crosshairs text-info me-2"></i>Identifica p√°ginas de TRCT e contracheques</li>
                                <li><i class="fas fa-bolt text-warning me-2"></i>Processa apenas p√°ginas relevantes</li>
                                <li><i class="fas fa-search text-secondary me-2"></i>Regex otimizado para documentos trabalhistas</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
document.getElementById('reextractForm').addEventListener('submit', function(e) {
    const btn = document.getElementById('submitBtn');
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Processando...';
});
</script>
{% endblock %}



================================================================================
FILE: templates/processes/batch_upload.html
================================================================================
{% extends "base.html" %}

{% block title %}Upload em Lote - Sistema Jur√≠dico{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-10 col-lg-8">
        <div class="card shadow-lg">
            <div class="card-header bg-gradient text-white">
                <h4 class="mb-0">
                    <i class="fas fa-cloud-upload-alt me-2"></i>
                    Upload em Lote de Processos
                </h4>
            </div>
            <div class="card-body p-4">
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>
                    <strong>Processamento Autom√°tico:</strong> Envie m√∫ltiplos PDFs de uma vez. 
                    O sistema ir√° extrair os dados de cada PDF e criar os processos automaticamente.
                </div>

                <form id="upload-form" method="POST" enctype="multipart/form-data">
                    <div class="mb-4">
                        <label for="pdfs" class="form-label fw-bold">
                            <i class="fas fa-file-pdf text-danger me-2"></i>
                            Selecione os PDFs (m√°ximo 20 arquivos)
                        </label>
                        <input type="file" class="form-control form-control-lg" id="pdfs" name="pdfs" 
                               multiple accept=".pdf" required>
                        <div class="form-text">
                            <i class="fas fa-exclamation-circle text-warning me-1"></i>
                            Cada arquivo deve ter no m√°ximo 16MB. Formatos aceitos: PDF
                        </div>
                    </div>

                    <div id="file-list" class="mb-4"></div>

                    <!-- Barra de progresso do upload -->
                    <div id="upload-progress-container" class="mb-4" style="display: none;">
                        <div class="card bg-light">
                            <div class="card-body">
                                <h6 class="card-title">
                                    <i class="fas fa-cloud-upload-alt me-2 text-primary"></i>
                                    <span id="upload-status-text">Enviando arquivos...</span>
                                </h6>
                                <div class="progress" style="height: 25px;">
                                    <div id="upload-progress-bar" class="progress-bar progress-bar-striped progress-bar-animated bg-primary" 
                                         role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                                        0%
                                    </div>
                                </div>
                                <div class="mt-2 d-flex justify-content-between">
                                    <small class="text-muted" id="upload-speed">Calculando velocidade...</small>
                                    <small class="text-muted" id="upload-eta">Tempo restante: calculando...</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="d-grid gap-2">
                        <button type="submit" id="submit-btn" class="btn btn-primary btn-lg">
                            <i class="fas fa-rocket me-2"></i>
                            Enviar e Processar
                        </button>
                        <a href="{{ url_for('batch.batch_list') }}" class="btn btn-outline-secondary">
                            <i class="fas fa-list me-2"></i>
                            Ver Batches Anteriores
                        </a>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<script>
const submitBtn = document.getElementById('submit-btn');
const pdfInput = document.getElementById('pdfs');
const uploadForm = document.getElementById('upload-form');
const progressContainer = document.getElementById('upload-progress-container');
const progressBar = document.getElementById('upload-progress-bar');
const statusText = document.getElementById('upload-status-text');
const speedText = document.getElementById('upload-speed');
const etaText = document.getElementById('upload-eta');

let uploadStartTime = null;

pdfInput.addEventListener('change', function(e) {
    const fileList = document.getElementById('file-list');
    const files = Array.from(e.target.files);
    
    if (files.length === 0) {
        fileList.innerHTML = '';
        submitBtn.disabled = false;
        return;
    }
    
    let totalSize = 0;
    files.forEach(file => totalSize += file.size);
    const totalMB = (totalSize / (1024 * 1024)).toFixed(1);
    const maxTotalMB = 350;
    const totalExceeded = totalSize > maxTotalMB * 1024 * 1024;
    
    if (totalExceeded) {
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-ban me-2"></i>Limite Excedido - Remova Arquivos';
        submitBtn.classList.remove('btn-primary');
        submitBtn.classList.add('btn-danger');
    } else {
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fas fa-rocket me-2"></i>Enviar e Processar';
        submitBtn.classList.remove('btn-danger');
        submitBtn.classList.add('btn-primary');
    }
    
    let html = '<div class="card bg-light"><div class="card-body">';
    html += `<h6 class="card-title"><i class="fas fa-list me-2"></i>Arquivos Selecionados (${files.length}):</h6>`;
    
    if (totalExceeded) {
        html += `<div class="alert alert-danger mb-3">
            <i class="fas fa-exclamation-triangle me-2"></i>
            <strong>Limite excedido!</strong> Total: ${totalMB}MB (m√°ximo: ${maxTotalMB}MB)
        </div>`;
    } else {
        html += `<div class="alert alert-info mb-3">
            <i class="fas fa-info-circle me-2"></i>
            Tamanho total: <strong>${totalMB}MB</strong> de ${maxTotalMB}MB
        </div>`;
    }
    
    html += '<ul class="list-group list-group-flush" style="max-height: 200px; overflow-y: auto;">';
    
    files.forEach((file, index) => {
        const size = (file.size / (1024 * 1024)).toFixed(2);
        const icon = '<i class="fas fa-file-pdf text-danger me-2"></i>';
        const sizeClass = file.size > 16 * 1024 * 1024 ? 'text-danger' : 'text-muted';
        
        html += `<li class="list-group-item d-flex justify-content-between align-items-center py-1">
            <span class="small">${icon}${file.name}</span>
            <span class="${sizeClass} small">${size} MB</span>
        </li>`;
    });
    
    html += '</ul></div></div>';
    fileList.innerHTML = html;
});

uploadForm.addEventListener('submit', function(e) {
    e.preventDefault();
    
    const files = Array.from(pdfInput.files);
    if (files.length === 0) return;
    
    let totalSize = 0;
    files.forEach(file => totalSize += file.size);
    
    if (totalSize > 350 * 1024 * 1024) {
        alert('Erro: O tamanho total dos arquivos excede 350MB.');
        return false;
    }
    
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Preparando upload...';
    
    progressContainer.style.display = 'block';
    uploadStartTime = Date.now();
    
    const formData = new FormData(uploadForm);
    
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', function(e) {
        if (e.lengthComputable) {
            const percentComplete = Math.round((e.loaded / e.total) * 100);
            progressBar.style.width = percentComplete + '%';
            progressBar.textContent = percentComplete + '%';
            progressBar.setAttribute('aria-valuenow', percentComplete);
            
            const elapsedTime = (Date.now() - uploadStartTime) / 1000;
            const bytesPerSecond = e.loaded / elapsedTime;
            const speedMBps = (bytesPerSecond / (1024 * 1024)).toFixed(2);
            speedText.textContent = `Velocidade: ${speedMBps} MB/s`;
            
            if (bytesPerSecond > 0) {
                const remainingBytes = e.total - e.loaded;
                const remainingSeconds = remainingBytes / bytesPerSecond;
                
                if (remainingSeconds < 60) {
                    etaText.textContent = `Tempo restante: ${Math.round(remainingSeconds)}s`;
                } else {
                    const minutes = Math.floor(remainingSeconds / 60);
                    const seconds = Math.round(remainingSeconds % 60);
                    etaText.textContent = `Tempo restante: ${minutes}m ${seconds}s`;
                }
            }
            
            const uploadedMB = (e.loaded / (1024 * 1024)).toFixed(1);
            const totalMB = (e.total / (1024 * 1024)).toFixed(1);
            statusText.textContent = `Enviando: ${uploadedMB}MB de ${totalMB}MB (${files.length} arquivos)`;
        }
    });
    
    xhr.addEventListener('load', function() {
        if (xhr.status >= 200 && xhr.status < 400) {
            progressBar.classList.remove('progress-bar-animated', 'bg-primary');
            progressBar.classList.add('bg-success');
            progressBar.textContent = '100% - Redirecionando...';
            statusText.textContent = 'Upload conclu√≠do! Redirecionando...';
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(xhr.responseText, 'text/html');
            
            if (xhr.responseURL && xhr.responseURL.includes('/batch/')) {
                window.location.href = xhr.responseURL;
            } else {
                const match = xhr.responseText.match(/\/processos\/batch\/(\d+)/);
                if (match) {
                    window.location.href = '/processos/batch/' + match[1] + '/progress';
                } else {
                    window.location.href = '/processos/batch/list';
                }
            }
        } else {
            progressBar.classList.remove('progress-bar-animated', 'bg-primary');
            progressBar.classList.add('bg-danger');
            progressBar.textContent = 'Erro no upload';
            statusText.textContent = 'Erro ao enviar arquivos. Tente novamente.';
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="fas fa-rocket me-2"></i>Tentar Novamente';
        }
    });
    
    xhr.addEventListener('error', function() {
        progressBar.classList.remove('progress-bar-animated', 'bg-primary');
        progressBar.classList.add('bg-danger');
        progressBar.textContent = 'Erro de conex√£o';
        statusText.textContent = 'Erro de conex√£o. Verifique sua internet.';
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="fas fa-rocket me-2"></i>Tentar Novamente';
    });
    
    xhr.open('POST', uploadForm.action || window.location.href, true);
    xhr.send(formData);
});
</script>

<style>
.bg-gradient {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
}
</style>
{% endblock %}



================================================================================
FILE: templates/processes/batch_list.html
================================================================================
{% extends "base.html" %}

{% block title %}Batches de Processamento - Sistema Jur√≠dico{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="card shadow-lg">
            <div class="card-header bg-gradient text-white d-flex justify-content-between align-items-center">
                <h4 class="mb-0">
                    <i class="fas fa-layer-group me-2"></i>
                    Meus Batches de Processamento
                </h4>
                <a href="{{ url_for('batch.batch_new') }}" class="btn btn-light btn-sm">
                    <i class="fas fa-plus me-2"></i>
                    Novo Batch
                </a>
            </div>
            <div class="card-body">
                {% if batches %}
                    <div class="mb-3">
                        <button type="button" class="btn btn-danger" id="deleteSelectedBtn" onclick="deleteSelected()" disabled>
                            <i class="fas fa-trash me-1"></i>Deletar Selecionados (<span id="selectedCount">0</span>)
                        </button>
                    </div>
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead>
                                <tr>
                                    <th style="width: 40px;">
                                        <input type="checkbox" id="selectAll" onchange="toggleSelectAll(this)">
                                    </th>
                                    <th>ID</th>
                                    <th>Status</th>
                                    <th>Progresso</th>
                                    <th>Total</th>
                                    <th>Criado em</th>
                                    <th>A√ß√µes</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for batch in batches %}
                                <tr>
                                    <td>
                                        <input type="checkbox" class="batch-checkbox" value="{{ batch.id }}" onchange="updateSelectedCount()">
                                    </td>
                                    <td><strong>#{{ batch.id }}</strong></td>
                                    <td>
                                        {% if batch.status == 'completed' %}
                                            <span class="badge bg-success">
                                                <i class="fas fa-check-circle me-1"></i>Conclu√≠do
                                            </span>
                                        {% elif batch.status == 'running' %}
                                            <span class="badge bg-primary">
                                                <i class="fas fa-spinner fa-spin me-1"></i>Em Execu√ß√£o
                                            </span>
                                        {% elif batch.status == 'ready' %}
                                            <span class="badge bg-info">
                                                <i class="fas fa-check me-1"></i>Pronto
                                            </span>
                                        {% elif batch.status == 'extracting' %}
                                            <span class="badge bg-warning">
                                                <i class="fas fa-cog fa-spin me-1"></i>Extraindo
                                            </span>
                                        {% elif batch.status == 'error' %}
                                            <span class="badge bg-danger">
                                                <i class="fas fa-exclamation-triangle me-1"></i>Erro
                                            </span>
                                        {% else %}
                                            <span class="badge bg-secondary">{{ batch.status }}</span>
                                        {% endif %}
                                    </td>
                                    <td>
                                        <div class="progress" style="height: 20px;">
                                            {% set percent = (batch.processed_count / batch.total_count * 100) | int if batch.total_count > 0 else 0 %}
                                            <div class="progress-bar {% if percent == 100 %}bg-success{% endif %}" 
                                                 role="progressbar" 
                                                 style="width: {{ percent }}%">
                                                {{ percent }}%
                                            </div>
                                        </div>
                                    </td>
                                    <td>{{ batch.processed_count }}/{{ batch.total_count }}</td>
                                    <td>{{ batch.created_at.strftime('%d/%m/%Y %H:%M') if batch.created_at else '-' }}</td>
                                    <td>
                                        <a href="{{ url_for('batch.batch_detail', id=batch.id) }}" 
                                           class="btn btn-sm btn-primary me-1">
                                            <i class="fas fa-eye me-1"></i>Detalhes
                                        </a>
                                        <form method="POST" action="{{ url_for('batch.batch_delete', id=batch.id) }}" 
                                              style="display:inline;" 
                                              onsubmit="return confirm('‚ö†Ô∏è ATEN√á√ÉO: Isso ir√° deletar o batch E todos os processos associados. Tem certeza?');">
                                            <button type="submit" class="btn btn-sm btn-danger">
                                                <i class="fas fa-trash me-1"></i>Deletar
                                            </button>
                                        </form>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                {% else %}
                    <div class="alert alert-info text-center">
                        <i class="fas fa-inbox fa-3x mb-3 d-block"></i>
                        <h5>Nenhum batch encontrado</h5>
                        <p class="mb-0">Voc√™ ainda n√£o criou nenhum batch de processamento.</p>
                        <a href="{{ url_for('batch.batch_new') }}" class="btn btn-primary mt-3">
                            <i class="fas fa-plus me-2"></i>
                            Criar Primeiro Batch
                        </a>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<style>
.bg-gradient {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
}
</style>

<script>
function toggleSelectAll(checkbox) {
    const checkboxes = document.querySelectorAll('.batch-checkbox');
    checkboxes.forEach(cb => cb.checked = checkbox.checked);
    updateSelectedCount();
}

function updateSelectedCount() {
    const checkboxes = document.querySelectorAll('.batch-checkbox:checked');
    const count = checkboxes.length;
    document.getElementById('selectedCount').textContent = count;
    document.getElementById('deleteSelectedBtn').disabled = count === 0;
    
    // Atualizar estado do checkbox "selecionar todos"
    const totalCheckboxes = document.querySelectorAll('.batch-checkbox').length;
    const selectAllCheckbox = document.getElementById('selectAll');
    if (count === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (count === totalCheckboxes) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
    } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
    }
}

function deleteSelected() {
    const checkboxes = document.querySelectorAll('.batch-checkbox:checked');
    const ids = Array.from(checkboxes).map(cb => cb.value);
    
    if (ids.length === 0) return;
    
    const message = `‚ö†Ô∏è ATEN√á√ÉO: Isso ir√° deletar ${ids.length} batch(es) E TODOS OS PROCESSOS associados. Tem certeza?`;
    if (!confirm(message)) return;
    
    // Criar formul√°rio e submeter
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = '{{ url_for("batch.batch_delete_multiple") }}';
    
    ids.forEach(id => {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'batch_ids';
        input.value = id;
        form.appendChild(input);
    });
    
    document.body.appendChild(form);
    form.submit();
}
</script>
{% endblock %}



================================================================================
FILE: templates/processes/batch_detail.html
================================================================================
{% extends "base.html" %}

{% block title %}Batch #{{ batch.id }} - Sistema Jur√≠dico{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <!-- Card de Status do Batch -->
        <div class="card shadow-lg mb-4">
            <div class="card-header bg-gradient text-white d-flex justify-content-between align-items-center">
                <h4 class="mb-0">
                    <i class="fas fa-layer-group me-2"></i>
                    Batch #{{ batch.id }}
                </h4>
                <span class="badge bg-light text-dark">
                    <span id="batch-status">{{ batch.status }}</span>
                </span>
            </div>
            <div class="card-body">
                <!-- Progresso Geral -->
                <div class="row mb-4">
                    <div class="col-md-8">
                        <h6 class="text-muted mb-2">Progresso Geral</h6>
                        <div class="progress" style="height: 30px;">
                            <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" style="width: 0%">
                                <span id="progress-text">0%</span>
                            </div>
                        </div>
                        <small class="text-muted">
                            <span id="progress-count">0</span>/<span id="total-count">{{ batch.total_count }}</span> processos
                        </small>
                    </div>
                    <div class="col-md-4 text-end">
                        <div id="batch-action-buttons">
                            {% if batch.status in ['ready', 'partial_ready'] %}
                            <button id="btn-start" class="btn btn-success btn-lg" onclick="startBatch()">
                                <i class="fas fa-play me-2"></i>
                                Iniciar Processamento RPA
                            </button>
                            {% elif batch.status == 'running' %}
                            <button id="btn-start" class="btn btn-primary btn-lg" disabled>
                                <i class="fas fa-spinner fa-spin me-2"></i>
                                Processando...
                            </button>
                            {% elif batch.status in ['completed', 'partial_completed'] %}
                            <button id="btn-start" class="btn btn-success btn-lg" disabled>
                                <i class="fas fa-check-circle me-2"></i>
                                Completo
                            </button>
                            {% endif %}
                        </div>
                        
                        <!-- Bot√£o Reprocessar (mostra quando h√° itens pendentes, erro ou sem process_id) -->
                        {% set has_pending = items|selectattr('status', 'equalto', 'pending')|list|length > 0 %}
                        {% set has_errors = items|selectattr('status', 'equalto', 'error')|list|length > 0 %}
                        {% set has_ready_no_process = items|selectattr('status', 'equalto', 'ready')|selectattr('process_id', 'none')|list|length > 0 %}
                        {% if has_pending or has_errors or has_ready_no_process or batch.status in ['error', 'running', 'pending'] %}
                        <form action="{{ url_for('batch.batch_reprocess', id=batch.id) }}" method="POST" class="d-inline ms-2">
                            <button type="submit" class="btn btn-warning btn-lg" onclick="return confirm('Deseja reprocessar os itens pendentes/erro?');">
                                <i class="fas fa-redo me-2"></i>
                                Reprocessar
                            </button>
                        </form>
                        {% endif %}
                    </div>
                </div>

                <!-- Informa√ß√µes do Batch -->
                <div class="row text-center border-top pt-3">
                    <div class="col-md-3">
                        <div class="metric">
                            <i class="fas fa-calendar-alt text-primary fa-2x mb-2"></i>
                            <h6 class="text-muted">Criado em</h6>
                            <p class="mb-0">{{ batch.created_at.strftime('%d/%m/%Y %H:%M') if batch.created_at else '-' }}</p>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="metric">
                            <i class="fas fa-play-circle text-info fa-2x mb-2"></i>
                            <h6 class="text-muted">Iniciado em</h6>
                            <p class="mb-0" id="started-at">{{ batch.started_at.strftime('%d/%m/%Y %H:%M') if batch.started_at else '-' }}</p>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="metric">
                            <i class="fas fa-check-circle text-success fa-2x mb-2"></i>
                            <h6 class="text-muted">Finalizado em</h6>
                            <p class="mb-0" id="finished-at">{{ batch.finished_at.strftime('%d/%m/%Y %H:%M') if batch.finished_at else '-' }}</p>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="metric">
                            <i class="fas fa-file-pdf text-danger fa-2x mb-2"></i>
                            <h6 class="text-muted">Total de PDFs</h6>
                            <p class="mb-0">{{ batch.total_count }}</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tabela de Items -->
        <div class="card shadow-lg">
            <div class="card-header bg-light">
                <h5 class="mb-0">
                    <i class="fas fa-list me-2"></i>
                    Arquivos do Batch
                </h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-hover" id="items-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Arquivo</th>
                                <th>Status</th>
                                <th>Status RPA</th>
                                <th>Processo</th>
                                <th>Tentativas</th>
                                <th>Erro</th>
                                <th>A√ß√µes</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for item in items %}
                            <tr data-item-id="{{ item.id }}">
                                <td>{{ loop.index }}</td>
                                <td>
                                    <i class="fas fa-file-pdf text-danger me-2"></i>
                                    {{ item.source_filename }}
                                </td>
                                <td class="status-cell">
                                    {% if item.status == 'success' %}
                                        <span class="badge bg-success">
                                            <i class="fas fa-check-circle me-1"></i>Sucesso
                                        </span>
                                    {% elif item.status == 'running' %}
                                        <span class="badge bg-primary">
                                            <i class="fas fa-spinner fa-spin me-1"></i>Executando
                                        </span>
                                    {% elif item.status == 'ready' %}
                                        <span class="badge bg-info">
                                            <i class="fas fa-clock me-1"></i>Pronto
                                        </span>
                                    {% elif item.status == 'extracting' %}
                                        <span class="badge bg-warning">
                                            <i class="fas fa-cog fa-spin me-1"></i>Extraindo
                                        </span>
                                    {% elif item.status == 'error' %}
                                        <span class="badge bg-danger">
                                            <i class="fas fa-exclamation-triangle me-1"></i>Erro
                                        </span>
                                    {% elif item.status == 'pending' %}
                                        <span class="badge bg-secondary">
                                            <i class="fas fa-hourglass-start me-1"></i>Pendente
                                        </span>
                                    {% else %}
                                        <span class="badge bg-secondary">{{ item.status }}</span>
                                    {% endif %}
                                </td>
                                <td class="rpa-status-cell" data-process-id="{{ item.process_id if item.process_id else '' }}">
                                    {% if item.process and item.process.elaw_status == 'running' %}
                                        <span class="badge bg-info">
                                            <i class="fas fa-spinner fa-pulse me-1"></i><span class="rpa-status-text">Iniciando...</span>
                                        </span>
                                    {% elif item.process and item.process.elaw_status == 'success' %}
                                        <span class="badge bg-success">
                                            <i class="fas fa-check me-1"></i>Conclu√≠do
                                        </span>
                                    {% elif item.process and item.process.elaw_status == 'error' %}
                                        <span class="badge bg-danger">
                                            <i class="fas fa-times me-1"></i>Erro
                                        </span>
                                    {% else %}
                                        <span class="text-muted">-</span>
                                    {% endif %}
                                </td>
                                <td class="process-cell">
                                    {% if item.process_id %}
                                        <span class="badge bg-success">
                                            <i class="fas fa-check-circle me-1"></i>Processo #{{ item.process_id }}
                                        </span>
                                    {% else %}
                                        <span class="text-muted">-</span>
                                    {% endif %}
                                </td>
                                <td class="attempts-cell">{{ item.attempt_count }}</td>
                                <td class="error-cell">
                                    {% if item.last_error %}
                                        <button class="btn btn-sm btn-outline-danger" 
                                                data-bs-toggle="tooltip" 
                                                title="{{ item.last_error }}">
                                            <i class="fas fa-info-circle"></i>
                                        </button>
                                    {% else %}
                                        <span class="text-muted">-</span>
                                    {% endif %}
                                </td>
                                <td class="actions-cell" data-item-id="{{ item.id }}" data-process-id="{{ item.process_id if item.process_id else '' }}">
                                    <div class="btn-group" role="group">
                                        {% if item.process_id %}
                                        {% if item.process and item.process.elaw_status == 'running' %}
                                        <a href="{{ url_for('core.rpa_progress', process_id=item.process_id, batch_id=batch.id) }}" 
                                           class="btn btn-sm btn-info" 
                                           data-bs-toggle="tooltip" title="Ver Progresso RPA">
                                            <i class="fas fa-spinner fa-pulse"></i>
                                        </a>
                                        {% else %}
                                        {% set missing_fields = item.process.get_missing_critical_fields() if item.process else [] %}
                                        {% set has_missing = missing_fields|length > 0 %}
                                        <a href="{{ url_for('core.process_view', id=item.process_id, batch_id=batch.id) }}" 
                                           class="btn btn-sm {% if has_missing %}btn-danger{% else %}btn-outline-primary{% endif %}" 
                                           data-bs-toggle="tooltip" title="{% if has_missing %}Campos faltando: {{ missing_fields|join(', ') }}{% else %}Visualizar processo{% endif %}"
                                           id="view-btn-{{ item.process_id }}">
                                            <i class="fas fa-eye"></i>
                                        </a>
                                        {% endif %}
                                        <a href="{{ url_for('core.process_edit', id=item.process_id, batch_id=batch.id) }}" 
                                           class="btn btn-sm btn-outline-secondary" 
                                           data-bs-toggle="tooltip" title="Editar processo">
                                            <i class="fas fa-edit"></i>
                                        </a>
                                        {% endif %}
                                        <a href="{{ url_for('batch.batch_item_pdf', id=item.id) }}" 
                                           class="btn btn-sm btn-outline-info" 
                                           data-bs-toggle="tooltip" title="Ver PDF original" target="_blank">
                                            <i class="fas fa-file-pdf"></i>
                                        </a>
                                        {% if item.process and item.process.elaw_screenshot_before_path %}
                                        <a href="{{ url_for('core.serve_rpa_screenshot', filename=item.process.elaw_screenshot_before_path) }}" 
                                           class="btn btn-sm btn-outline-success" 
                                           data-bs-toggle="tooltip" title="Screenshot ANTES de salvar" target="_blank">
                                            <i class="fas fa-camera"></i>
                                        </a>
                                        {% endif %}
                                        {% if item.process and item.process.elaw_screenshot_after_path %}
                                        <a href="{{ url_for('core.serve_rpa_screenshot', filename=item.process.elaw_screenshot_after_path) }}" 
                                           class="btn btn-sm btn-outline-primary" 
                                           data-bs-toggle="tooltip" title="Screenshot DEPOIS de salvar" target="_blank">
                                            <i class="fas fa-camera-retro"></i>
                                        </a>
                                        {% endif %}
                                        {% if item.process and item.process.elaw_screenshot_reclamadas_path %}
                                        <a href="{{ url_for('core.serve_rpa_screenshot', filename=item.process.elaw_screenshot_reclamadas_path) }}" 
                                           class="btn btn-sm btn-outline-warning" 
                                           data-bs-toggle="tooltip" title="Screenshot RECLAMADAS" target="_blank">
                                            <i class="fas fa-users"></i>
                                        </a>
                                        {% endif %}
                                        {% if item.process and item.process.elaw_screenshot_pedidos_path %}
                                        <a href="{{ url_for('core.serve_rpa_screenshot', filename=item.process.elaw_screenshot_pedidos_path) }}" 
                                           class="btn btn-sm btn-outline-info" 
                                           data-bs-toggle="tooltip" title="Screenshot PEDIDOS" target="_blank">
                                            <i class="fas fa-list-alt"></i>
                                        </a>
                                        {% endif %}
                                        {% if item.status in ['error', 'ready'] and item.process_id %}
                                        <form action="{{ url_for('batch.batch_item_retry', id=item.id) }}" 
                                              method="POST" style="display:inline;">
                                            <button type="submit" class="btn btn-sm btn-warning" 
                                                    data-bs-toggle="tooltip" title="Reprocessar RPA">
                                                <i class="fas fa-redo"></i>
                                            </button>
                                        </form>
                                        {% endif %}
                                        <form action="{{ url_for('batch.batch_item_delete', id=item.id) }}" 
                                              method="POST" style="display:inline;" 
                                              onsubmit="return confirm('Tem certeza que deseja deletar este item?');">
                                            <button type="submit" class="btn btn-sm btn-outline-danger" 
                                                    data-bs-toggle="tooltip" title="Deletar">
                                                <i class="fas fa-trash"></i>
                                            </button>
                                        </form>
                                    </div>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="mt-3">
            <a href="{{ url_for('batch.batch_list') }}" class="btn btn-secondary">
                <i class="fas fa-arrow-left me-2"></i>
                Voltar para Lista
            </a>
            <span id="final-buttons-container">
                {% if batch.status in ['completed', 'partial_completed'] %}
                <a href="{{ url_for('core.dashboard') }}" class="btn btn-success ms-2">
                    <i class="fas fa-home me-2"></i>Voltar para Dashboard
                </a>
                <a href="{{ url_for('batch.batch_new') }}" class="btn btn-primary ms-2">
                    <i class="fas fa-plus me-2"></i>Iniciar Outro Batch
                </a>
                {% endif %}
            </span>
        </div>
    </div>
</div>

<script>
let pollingInterval = null;
const POLL_INTERVAL = 5000; // 5 segundos (otimizado para reduzir carga)
const batchId = {{ batch.id }};
let completionToastShown = false; // Flag para evitar toasts repetidos
const initialBatchStatus = '{{ batch.status }}'; // Status inicial ao carregar a p√°gina

async function startBatch() {
    const btn = document.getElementById('btn-start');
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Iniciando...';
    
    try {
        const response = await fetch(`/processos/batch/${batchId}/start`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'}
        });
        
        const data = await response.json();
        
        if (data.success) {
            showToast(data.message, 'success');
            startPolling();
        } else {
            showToast('Erro: ' + (data.error || 'Falha ao iniciar processamento'), 'error');
            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-play me-2"></i>Iniciar Processamento RPA';
        }
    } catch (error) {
        console.error('Erro ao iniciar batch:', error);
        showToast('Erro de conex√£o. Tente novamente.', 'error');
        btn.disabled = false;
        btn.innerHTML = '<i class="fas fa-play me-2"></i>Iniciar Processamento RPA';
    }
}

async function updateBatchStatus() {
    try {
        const response = await fetch(`/processos/batch/${batchId}/status`);
        const data = await response.json();
        
        // Atualizar progresso
        const percent = data.progress_percent || 0;
        document.getElementById('progress-bar').style.width = percent + '%';
        document.getElementById('progress-text').textContent = percent + '%';
        document.getElementById('progress-count').textContent = data.processed_count;
        document.getElementById('total-count').textContent = data.total_count;
        document.getElementById('batch-status').textContent = data.status;
        
        // Atualizar timestamps
        if (data.started_at) {
            document.getElementById('started-at').textContent = new Date(data.started_at).toLocaleString('pt-BR');
        }
        if (data.finished_at) {
            document.getElementById('finished-at').textContent = new Date(data.finished_at).toLocaleString('pt-BR');
        }
        
        // Atualizar items
        data.items.forEach(item => {
            const row = document.querySelector(`tr[data-item-id="${item.id}"]`);
            if (row) {
                updateItemRow(row, item);
            }
        });
        
        // Atualizar status RPA para processos em execu√ß√£o
        await updateRPAStatuses();
        
        // Parar polling se conclu√≠do
        if (['completed', 'partial_completed'].includes(data.status)) {
            stopPolling();
            document.getElementById('progress-bar').classList.remove('progress-bar-animated');
            document.getElementById('progress-bar').classList.add('bg-success');
            
            // Atualizar bot√£o para "Completo"
            const btnStart = document.getElementById('btn-start');
            if (btnStart) {
                btnStart.innerHTML = '<i class="fas fa-check-circle me-2"></i>Completo';
                btnStart.className = 'btn btn-success btn-lg';
                btnStart.disabled = true;
            }
            
            // MOSTRAR BOT√ïES FINAIS AUTOMATICAMENTE
            const finalButtonsContainer = document.getElementById('final-buttons-container');
            if (finalButtonsContainer) {
                finalButtonsContainer.innerHTML = `
                    <a href="/dashboard" class="btn btn-success ms-2">
                        <i class="fas fa-home me-2"></i>Voltar para Dashboard
                    </a>
                    <a href="/processos/batch/new" class="btn btn-primary ms-2">
                        <i class="fas fa-plus me-2"></i>Iniciar Outro Batch
                    </a>
                `;
            }
            
            // Calcular estat√≠sticas e mostrar toast APENAS UMA VEZ
            // Evitar spam de toasts: s√≥ mostrar se n√£o foi mostrado antes E se o status mudou
            // (n√£o mostrar se o batch j√° estava conclu√≠do quando a p√°gina carregou)
            if (!completionToastShown && !['completed', 'partial_completed'].includes(initialBatchStatus)) {
                completionToastShown = true; // Marcar como mostrado
                
                const successCount = data.items.filter(item => item.status === 'success').length;
                const totalCount = data.items.length;
                
                if (data.status === 'completed') {
                    showToast(`Batch RPA conclu√≠do! ${successCount}/${totalCount} processos preenchidos com sucesso no eLaw.`, 'success');
                } else {
                    const errorCount = totalCount - successCount;
                    showToast(`Batch RPA conclu√≠do parcialmente. ${successCount} sucesso(s), ${errorCount} erro(s). Verifique os detalhes abaixo.`, 'warning');
                }
            }
        }
        
    } catch (error) {
        console.error('Erro ao atualizar status:', error);
    }
}

async function updateRPAStatuses() {
    // Buscar todas as c√©lulas com process_id
    const rpaCells = document.querySelectorAll('.rpa-status-cell[data-process-id]');
    
    for (const cell of rpaCells) {
        const processId = cell.getAttribute('data-process-id');
        if (!processId) continue;
        
        try {
            const response = await fetch(`/api/rpa-status/${processId}`);
            const rpaStatus = await response.json();
            
            // PRIORIZAR status 'completed'/'success' PRIMEIRO
            if (rpaStatus.status === 'completed' || rpaStatus.status === 'success') {
                // Check verde para processos conclu√≠dos
                cell.innerHTML = `
                    <span class="badge bg-success">
                        <i class="fas fa-check me-1"></i>Conclu√≠do
                    </span>
                `;
            } else if (rpaStatus.status === 'error') {
                cell.innerHTML = `
                    <span class="badge bg-danger">
                        <i class="fas fa-times me-1"></i>Erro
                    </span>
                `;
            } else if (rpaStatus.status === 'running' || rpaStatus.current_step) {
                const message = rpaStatus.message || rpaStatus.current_step || 'Processando...';
                cell.innerHTML = `
                    <span class="badge bg-info">
                        <i class="fas fa-spinner fa-pulse me-1"></i>${message}
                    </span>
                `;
            }
        } catch (error) {
            // Silenciar erros (processo pode n√£o ter RPA ativo)
        }
    }
}

async function updateItemRow(row, item) {
    const statusCell = row.querySelector('.status-cell');
    const processCell = row.querySelector('.process-cell');
    const attemptsCell = row.querySelector('.attempts-cell');
    const errorCell = row.querySelector('.error-cell');
    const actionsCell = row.querySelector('.actions-cell');
    
    // Status badge
    const statusIcons = {
        'success': '<i class="fas fa-check-circle me-1"></i>Sucesso',
        'running': '<i class="fas fa-spinner fa-spin me-1"></i>Executando',
        'ready': '<i class="fas fa-clock me-1"></i>Pronto',
        'extracting': '<i class="fas fa-cog fa-spin me-1"></i>Extraindo',
        'error': '<i class="fas fa-exclamation-triangle me-1"></i>Erro',
        'pending': '<i class="fas fa-hourglass-start me-1"></i>Pendente'
    };
    
    const statusClasses = {
        'success': 'bg-success',
        'running': 'bg-primary',
        'ready': 'bg-info',
        'extracting': 'bg-warning',
        'error': 'bg-danger',
        'pending': 'bg-secondary'
    };
    
    statusCell.innerHTML = `<span class="badge ${statusClasses[item.status] || 'bg-secondary'}">${statusIcons[item.status] || item.status}</span>`;
    
    // Process link
    if (item.process_id) {
        processCell.innerHTML = `<a href="/processos/${item.process_id}" class="btn btn-sm btn-outline-primary"><i class="fas fa-eye me-1"></i>Ver #${item.process_id}</a>`;
    }
    
    // Attempts
    attemptsCell.textContent = item.attempt_count;
    
    // Error
    if (item.last_error) {
        errorCell.innerHTML = `<button class="btn btn-sm btn-outline-danger" data-bs-toggle="tooltip" title="${item.last_error}"><i class="fas fa-info-circle"></i></button>`;
        // Inicializar tooltip do bot√£o de erro com fun√ß√£o centralizada
        initTooltips(errorCell);
    }
    
    // NOVA FUN√á√ÉO: Atualizar coluna A√ß√µes com screenshots em tempo real
    if (actionsCell && item.process_id) {
        await updateActionsCell(actionsCell, item);
    }
}

async function updateActionsCell(actionsCell, item) {
    const processId = item.process_id;
    const itemId = item.id;
    
    // N√£o atualizar se n√£o houver process_id
    if (!processId) {
        return;
    }
    
    try {
        // üîß FIX: Usar dados do processo que j√° v√™m na API batch/status
        // ao inv√©s de fazer outro fetch desnecess√°rio
        const processData = item.process || {};
        
        // Construir HTML dos bot√µes
        let buttonsHTML = '<div class="btn-group" role="group">';
        
        // Bot√£o Ver/Progresso RPA
        if (processData.elaw_status === 'running') {
            buttonsHTML += `
                <a href="/processos/rpa/progress/${processId}?batch_id=${batchId}" 
                   class="btn btn-sm btn-info" 
                   data-bs-toggle="tooltip" title="Ver Progresso RPA">
                    <i class="fas fa-spinner fa-pulse"></i>
                </a>
            `;
        } else {
            buttonsHTML += `
                <a href="/processos/${processId}?batch_id=${batchId}" 
                   class="btn btn-sm btn-outline-primary" 
                   data-bs-toggle="tooltip" title="Visualizar processo">
                    <i class="fas fa-eye"></i>
                </a>
            `;
        }
        
        // Bot√£o Editar
        buttonsHTML += `
            <a href="/processos/${processId}/edit?batch_id=${batchId}" 
               class="btn btn-sm btn-outline-secondary" 
               data-bs-toggle="tooltip" title="Editar processo">
                <i class="fas fa-edit"></i>
            </a>
        `;
        
        // Bot√£o PDF
        buttonsHTML += `
            <a href="/processos/batch/item/${itemId}/pdf" 
               class="btn btn-sm btn-outline-info" 
               data-bs-toggle="tooltip" title="Ver PDF original" target="_blank">
                <i class="fas fa-file-pdf"></i>
            </a>
        `;
        
        // Bot√£o Screenshot ANTES (aparece se existir)
        if (processData.elaw_screenshot_before_path) {
            // üîß FIX: Usar rota /rpa_screenshots/ em vez de /static/
            buttonsHTML += `
                <a href="/rpa_screenshots/${processData.elaw_screenshot_before_path}" 
                   class="btn btn-sm btn-outline-success" 
                   data-bs-toggle="tooltip" title="Screenshot ANTES de salvar" target="_blank">
                    <i class="fas fa-camera"></i>
                </a>
            `;
        }
        
        // Bot√£o Screenshot DEPOIS (aparece se existir)
        if (processData.elaw_screenshot_after_path) {
            // üîß FIX: Usar rota /rpa_screenshots/ em vez de /static/
            buttonsHTML += `
                <a href="/rpa_screenshots/${processData.elaw_screenshot_after_path}" 
                   class="btn btn-sm btn-outline-primary" 
                   data-bs-toggle="tooltip" title="Screenshot DEPOIS de salvar" target="_blank">
                    <i class="fas fa-camera-retro"></i>
                </a>
            `;
        }
        
        // Bot√£o Screenshot RECLAMADAS (aparece se existir)
        if (processData.elaw_screenshot_reclamadas_path) {
            buttonsHTML += `
                <a href="/rpa_screenshots/${processData.elaw_screenshot_reclamadas_path}" 
                   class="btn btn-sm btn-outline-warning" 
                   data-bs-toggle="tooltip" title="Screenshot RECLAMADAS" target="_blank">
                    <i class="fas fa-users"></i>
                </a>
            `;
        }
        
        // Bot√£o Screenshot PEDIDOS (aparece se existir)
        if (processData.elaw_screenshot_pedidos_path) {
            buttonsHTML += `
                <a href="/rpa_screenshots/${processData.elaw_screenshot_pedidos_path}" 
                   class="btn btn-sm btn-outline-info" 
                   data-bs-toggle="tooltip" title="Screenshot PEDIDOS" target="_blank">
                    <i class="fas fa-list-alt"></i>
                </a>
            `;
        }
        
        // Bot√£o Reprocessar (s√≥ se erro)
        if (item.status === 'error') {
            buttonsHTML += `
                <form action="/processos/batch/item/${itemId}/retry" method="POST" style="display:inline;">
                    <button type="submit" class="btn btn-sm btn-warning" 
                            data-bs-toggle="tooltip" title="Reprocessar">
                        <i class="fas fa-redo"></i>
                    </button>
                </form>
            `;
        }
        
        // Bot√£o Deletar
        buttonsHTML += `
            <form action="/processos/batch/item/${itemId}/delete" method="POST" style="display:inline;" 
                  onsubmit="return confirm('Tem certeza que deseja deletar este item?');">
                <button type="submit" class="btn btn-sm btn-outline-danger" 
                        data-bs-toggle="tooltip" title="Deletar">
                    <i class="fas fa-trash"></i>
                </button>
            </form>
        `;
        
        buttonsHTML += '</div>';
        
        // Atualizar HTML da c√©lula
        actionsCell.innerHTML = buttonsHTML;
        
        // Reinicializar tooltips com fun√ß√£o centralizada
        initTooltips(actionsCell);
        
    } catch (error) {
        console.error('Erro ao atualizar a√ß√µes:', error);
    }
}

function startPolling() {
    if (!pollingInterval) {
        pollingInterval = setInterval(updateBatchStatus, POLL_INTERVAL);
    }
}

function stopPolling() {
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
    }
}

// Fun√ß√£o para inicializar tooltips com configura√ß√£o correta
function initTooltips(container = document) {
    const tooltipTriggerList = container.querySelectorAll('[data-bs-toggle="tooltip"]');
    tooltipTriggerList.forEach(el => {
        // Destruir tooltip existente se houver
        const existingTooltip = bootstrap.Tooltip.getInstance(el);
        if (existingTooltip) {
            existingTooltip.dispose();
        }
        // Criar novo tooltip com trigger expl√≠cito
        new bootstrap.Tooltip(el, {
            trigger: 'hover',
            delay: { show: 200, hide: 0 }
        });
    });
}

// Inicializar tooltips existentes ao carregar a p√°gina
document.addEventListener('DOMContentLoaded', async function() {
    initTooltips();
    
    // üîß FIX: For√ßar atualiza√ß√£o de TODOS os bot√µes de a√ß√£o ao carregar a p√°gina
    // Isso garante que screenshots apare√ßam mesmo se o polling j√° tiver parado
    const allRows = document.querySelectorAll('tr[data-item-id]');
    for (const row of allRows) {
        const actionsCell = row.querySelector('.actions-cell');
        const processId = row.querySelector('.process-cell a')?.href?.match(/\/processos\/(\d+)/)?.[1];
        
        if (actionsCell && processId) {
            await updateActionsCell(actionsCell, { 
                id: row.getAttribute('data-item-id'),
                process_id: parseInt(processId),
                status: row.querySelector('.status-cell .badge')?.textContent?.toLowerCase().includes('sucesso') ? 'success' : 'unknown'
            });
        }
    }
});

// Iniciar polling se batch est√° em execu√ß√£o
{% if batch.status in ['running', 'extracting', 'queued'] %}
startPolling();
{% endif %}

// üîß FIX: Tamb√©m iniciar polling se batch est√° "completed" mas h√° processos success sem screenshots
// Isso garante que os bot√µes apare√ßam mesmo se a p√°gina for recarregada ap√≥s o batch terminar
{% if batch.status in ['completed', 'partial_completed'] %}
(async function() {
    // Aguardar 2 segundos e verificar se h√° processos success sem screenshots
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const successRows = document.querySelectorAll('tr[data-item-id]');
    let needsUpdate = false;
    
    for (const row of successRows) {
        const statusBadge = row.querySelector('.status-cell .badge');
        const actionsCell = row.querySelector('.actions-cell');
        
        if (statusBadge?.textContent?.toLowerCase().includes('sucesso')) {
            // Verificar se tem bot√µes de screenshot
            const hasScreenshotButtons = actionsCell?.querySelector('a[title*="Screenshot"]');
            if (!hasScreenshotButtons) {
                needsUpdate = true;
                break;
            }
        }
    }
    
    // Se encontrou processos success sem screenshots, iniciar polling por mais 30 segundos
    if (needsUpdate) {
        console.log('[BATCH] Detectados processos success sem screenshots - iniciando polling adicional');
        startPolling();
        setTimeout(stopPolling, 30000); // Parar ap√≥s 30 segundos
    }
})();
{% endif %}

// Cleanup ao sair da p√°gina
window.addEventListener('beforeunload', stopPolling);
</script>

<style>
.bg-gradient {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
}

.metric {
    padding: 15px;
}

.progress {
    border-radius: 10px;
}

.progress-bar {
    transition: width 0.5s ease;
}
</style>
{% endblock %}



================================================================================
FILE: templates/processes/batch_progress.html
================================================================================
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processando Lote - Batch #{{ batch_id }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #1e3c72;
            --secondary-color: #2a5298;
            --accent-color: #7e8ba3;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e8ba3 100%);
            background-attachment: fixed;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            padding: 40px 20px;
            max-width: 900px;
        }

        .progress-card {
            background: rgba(255, 255, 255, 0.98);
            border: none;
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .progress-card-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .progress-card-header h2 {
            margin: 0;
            font-size: 26px;
            font-weight: 600;
        }

        .progress-card-header .batch-info {
            font-size: 14px;
            opacity: 0.9;
            margin-top: 5px;
        }

        .progress-card-body {
            padding: 40px;
        }

        .hourglass-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        .hourglass {
            width: 60px;
            height: 60px;
            position: relative;
            animation: flip 2s ease-in-out infinite;
        }

        @keyframes flip {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(180deg); }
        }

        .hourglass i {
            font-size: 60px;
            color: var(--secondary-color);
        }

        .main-progress {
            margin-bottom: 30px;
        }

        .main-progress .progress {
            height: 12px;
            border-radius: 10px;
            background: rgba(30, 60, 114, 0.1);
            overflow: visible;
        }

        .main-progress .progress-bar {
            background: linear-gradient(90deg, #1e3c72, #2a5298);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(30, 60, 114, 0.3);
            transition: width 0.4s ease;
        }

        .status-message {
            text-align: center;
            margin-bottom: 30px;
            padding: 15px;
            background: rgba(30, 60, 114, 0.05);
            border-radius: 10px;
            border-left: 4px solid var(--primary-color);
        }

        .status-message h4 {
            color: var(--primary-color);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .status-message p {
            color: #666;
            margin: 0;
            font-size: 14px;
        }

        .files-list {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 10px;
        }

        .file-item {
            padding: 12px 15px;
            margin-bottom: 10px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .file-item.processing {
            border-left: 4px solid #0d6efd;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .file-item.success {
            border-left: 4px solid #28a745;
        }

        .file-item.error {
            border-left: 4px solid #dc3545;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .file-icon {
            font-size: 24px;
        }

        .file-name {
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }

        .file-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-top-color: #0d6efd;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .completion-message {
            text-align: center;
            padding: 30px;
            display: none;
        }

        .completion-message.success {
            color: #28a745;
        }

        .completion-message.error {
            color: #dc3545;
        }

        .completion-message i {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .btn-custom {
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-custom:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="progress-card">
            <div class="progress-card-header">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <a href="/processos/batch/{{ batch_id }}" class="btn btn-sm btn-outline-light">
                        <i class="fas fa-arrow-left me-1"></i>Voltar
                    </a>
                    <a href="/processos/batch" class="btn btn-sm btn-outline-light">
                        <i class="fas fa-list me-1"></i>Ver Todos
                    </a>
                </div>
                <h2><i class="fas fa-layer-group me-2"></i>Processando Lote</h2>
                <div class="batch-info">Batch #{{ batch_id }} - <span id="total-files">0</span> arquivo(s)</div>
            </div>

            <div class="progress-card-body">
                <div class="hourglass-container">
                    <div class="hourglass">
                        <i class="fas fa-hourglass-half"></i>
                    </div>
                </div>

                <div class="main-progress">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span style="font-size: 14px; font-weight: 500; color: #666;">Progresso Geral</span>
                        <span id="progress-percent" style="font-size: 18px; font-weight: 600; color: var(--primary-color);">0%</span>
                    </div>
                    <div class="progress">
                        <div id="main-progress-bar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                    <div class="text-center mt-2">
                        <small class="text-muted"><span id="processed-count">0</span> de <span id="total-count">0</span> processados</small>
                    </div>
                </div>

                <div id="status-message" class="status-message">
                    <h4 id="current-step">Iniciando...</h4>
                    <p id="current-message">Preparando para processar arquivos...</p>
                </div>

                <div class="files-list" id="files-list">
                    <!-- Arquivos ser√£o inseridos dinamicamente -->
                </div>

                <div id="completion-message" class="completion-message">
                    <i class="fas fa-check-circle"></i>
                    <h3>Processamento Conclu√≠do!</h3>
                    <p id="completion-text"></p>
                    <div class="mt-4">
                        <a href="/processos/batch/{{ batch_id }}" class="btn btn-primary btn-custom">
                            <i class="fas fa-eye me-2"></i>Ver Detalhes do Batch
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const batchId = {{ batch_id }};
        const pollInterval = 3000; // 3 segundos (otimizado para reduzir carga)
        let filesData = {};

        async function checkProgress() {
            try {
                const response = await fetch(`/processos/batch/${batchId}/progress-status`);
                const data = await response.json();

                // Atualizar progresso geral
                const progressPercent = Math.round((data.processed_count / data.total_count) * 100) || 0;
                document.getElementById('progress-percent').textContent = progressPercent + '%';
                document.getElementById('main-progress-bar').style.width = progressPercent + '%';
                document.getElementById('processed-count').textContent = data.processed_count;
                document.getElementById('total-count').textContent = data.total_count;
                document.getElementById('total-files').textContent = data.total_count;

                // Atualizar mensagem de status
                document.getElementById('current-step').textContent = `Processando arquivos (${data.processed_count}/${data.total_count})`;
                
                if (data.current_file) {
                    document.getElementById('current-message').textContent = `Extraindo dados de: ${data.current_file}`;
                }

                // Atualizar lista de arquivos
                updateFilesList(data.items);

                // Verificar se extra√ß√£o conclu√≠da
                if (data.status === 'ready' || data.status === 'partial_ready' || data.status === 'error') {
                    const successCount = data.items.filter(item => item.status === 'ready' || item.status === 'success').length;
                    const errorCount = data.items.filter(item => item.status === 'error').length;

                    // Redirecionar IMEDIATAMENTE para tela de detalhes do batch
                    window.location.replace(`/processos/batch/${batchId}`);
                } else {
                    // Continuar polling
                    setTimeout(checkProgress, pollInterval);
                }

            } catch (error) {
                console.error('Erro ao verificar progresso:', error);
                setTimeout(checkProgress, pollInterval * 2);
            }
        }

        function updateFilesList(items) {
            const filesList = document.getElementById('files-list');
            let html = '';

            items.forEach((item, index) => {
                let statusClass = '';
                let statusIcon = '';
                let statusText = '';

                switch (item.status) {
                    case 'extracting':
                        statusClass = 'processing';
                        statusIcon = '<div class="spinner"></div>';
                        statusText = 'Extraindo dados...';
                        break;
                    case 'ready':
                    case 'success':
                        statusClass = 'success';
                        statusIcon = '<i class="fas fa-check-circle text-success"></i>';
                        statusText = 'Conclu√≠do';
                        break;
                    case 'error':
                        statusClass = 'error';
                        statusIcon = '<i class="fas fa-times-circle text-danger"></i>';
                        statusText = 'Erro';
                        break;
                    default:
                        statusClass = '';
                        statusIcon = '<i class="fas fa-clock text-muted"></i>';
                        statusText = 'Aguardando';
                }

                html += `
                    <div class="file-item ${statusClass}">
                        <div class="file-info">
                            <i class="fas fa-file-pdf file-icon text-danger"></i>
                            <span class="file-name">${item.filename}</span>
                        </div>
                        <div class="file-status">
                            ${statusIcon}
                            <span>${statusText}</span>
                        </div>
                    </div>
                `;
            });

            filesList.innerHTML = html;
        }

        // Iniciar polling
        checkProgress();
    </script>
</body>
</html>



================================================================================
FILE: templates/processes/rpa_progress.html
================================================================================
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processando RPA - Processo #{{ process_id }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #1e3c72;
            --secondary-color: #2a5298;
            --accent-color: #7e8ba3;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e8ba3 100%);
            background-attachment: fixed;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            padding: 40px 20px;
            max-width: 900px;
        }

        .progress-card {
            background: rgba(255, 255, 255, 0.98);
            border: none;
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .progress-card-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .progress-card-header h2 {
            margin: 0;
            font-size: 26px;
            font-weight: 600;
        }

        .progress-card-header .process-number {
            font-size: 14px;
            opacity: 0.9;
            margin-top: 5px;
        }

        .progress-card-body {
            padding: 40px;
        }

        /* Ampulheta animada */
        .hourglass-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        .hourglass {
            width: 60px;
            height: 60px;
            position: relative;
            animation: flip 2s ease-in-out infinite;
        }

        @keyframes flip {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(180deg); }
        }

        .hourglass i {
            font-size: 60px;
            color: var(--secondary-color);
        }

        /* Barra de progresso principal */
        .main-progress {
            margin-bottom: 30px;
        }

        .main-progress .progress {
            height: 12px;
            border-radius: 10px;
            background: rgba(30, 60, 114, 0.1);
            overflow: hidden;
        }

        .main-progress .progress-bar {
            background: linear-gradient(90deg, #1e3c72 0%, #2a5298 50%, #7e8ba3 100%);
            background-size: 200% 100%;
            animation: shimmer 2s linear infinite;
            transition: width 0.5s ease;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .progress-percentage {
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: var(--primary-color);
            margin-top: 10px;
        }

        /* Status atual */
        .current-status {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.08) 0%, rgba(126, 139, 163, 0.08) 100%);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: center;
            border: 2px solid rgba(30, 60, 114, 0.1);
        }

        .current-status-title {
            font-size: 16px;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .current-status-message {
            font-size: 20px;
            color: var(--primary-color);
            font-weight: 500;
        }

        /* Lista de etapas */
        .steps-timeline {
            position: relative;
        }

        .step-item {
            display: flex;
            align-items: flex-start;
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 12px;
            transition: all 0.3s ease;
            position: relative;
            background: white;
            border: 2px solid #e0e0e0;
        }

        .step-item.pending {
            opacity: 0.5;
            border-color: #e0e0e0;
        }

        .step-item.active {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.05) 0%, rgba(126, 139, 163, 0.05) 100%);
            border-color: var(--secondary-color);
            box-shadow: 0 4px 15px rgba(30, 60, 114, 0.15);
            animation: pulse 2s ease-in-out infinite;
        }

        .step-item.completed {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.03);
        }

        .step-item.error {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.03);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(30, 60, 114, 0.15);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 6px 20px rgba(30, 60, 114, 0.25);
            }
        }

        .step-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            flex-shrink: 0;
            font-size: 18px;
        }

        .step-item.pending .step-icon {
            background: #e0e0e0;
            color: #999;
        }

        .step-item.active .step-icon {
            background: var(--secondary-color);
            color: white;
            animation: rotate 1s linear infinite;
        }

        .step-item.completed .step-icon {
            background: #28a745;
            color: white;
        }

        .step-item.error .step-icon {
            background: #dc3545;
            color: white;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
            color: #333;
        }

        .step-description {
            font-size: 13px;
            color: #666;
            margin: 0;
        }

        .step-time {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }

        /* Powered by Inova */
        .powered-by {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .powered-by-text {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .powered-by img {
            max-height: 40px;
            opacity: 0.9;
            transition: opacity 0.3s ease;
        }

        .powered-by img:hover {
            opacity: 1;
        }

        /* Anima√ß√µes de entrada */
        .step-item {
            animation: fadeInLeft 0.5s ease-out backwards;
        }

        .step-item:nth-child(1) { animation-delay: 0.1s; }
        .step-item:nth-child(2) { animation-delay: 0.2s; }
        .step-item:nth-child(3) { animation-delay: 0.3s; }
        .step-item:nth-child(4) { animation-delay: 0.4s; }
        .step-item:nth-child(5) { animation-delay: 0.5s; }
        .step-item:nth-child(6) { animation-delay: 0.6s; }
        .step-item:nth-child(7) { animation-delay: 0.7s; }
        .step-item:nth-child(8) { animation-delay: 0.8s; }

        @keyframes fadeInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 20px 15px;
            }

            .progress-card-body {
                padding: 25px 20px;
            }

            .progress-card-header h2 {
                font-size: 22px;
            }

            .current-status-message {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="progress-card">
            <div class="progress-card-header">
                <h2><i class="fas fa-robot me-2"></i>Preenchimento Autom√°tico eLaw</h2>
                <div class="process-number">Processo #{{ process_id }}</div>
            </div>
            
            <div class="progress-card-body">
                <!-- Ampulheta animada -->
                <div class="hourglass-container">
                    <div class="hourglass">
                        <i class="fas fa-hourglass-half"></i>
                    </div>
                </div>

                <!-- Barra de progresso -->
                <div class="main-progress">
                    <div class="progress">
                        <div id="progress-bar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                    <div id="progress-percentage" class="progress-percentage">0%</div>
                </div>

                <!-- Status atual -->
                <div class="current-status">
                    <div class="current-status-title">Status Atual</div>
                    <div id="current-status-message" class="current-status-message">
                        Iniciando RPA...
                    </div>
                </div>

                <!-- Timeline de etapas -->
                <div class="steps-timeline">
                    <h5 class="mb-3" style="color: var(--primary-color); font-weight: 600;">
                        <i class="fas fa-list-check me-2"></i>Progresso das Etapas
                    </h5>
                    
                    <div id="step-login" class="step-item pending">
                        <div class="step-icon">
                            <i class="fas fa-sign-in-alt"></i>
                        </div>
                        <div class="step-content">
                            <div class="step-title">Login no eLaw</div>
                            <div class="step-description">Autenticando no sistema eLaw</div>
                            <div class="step-time"></div>
                        </div>
                    </div>

                    <div id="step-navegacao" class="step-item pending">
                        <div class="step-icon">
                            <i class="fas fa-compass"></i>
                        </div>
                        <div class="step-content">
                            <div class="step-title">Navega√ß√£o</div>
                            <div class="step-description">Acessando formul√°rio de cadastro</div>
                            <div class="step-time"></div>
                        </div>
                    </div>

                    <div id="step-preenchimento" class="step-item pending">
                        <div class="step-icon">
                            <i class="fas fa-pen-to-square"></i>
                        </div>
                        <div class="step-content">
                            <div class="step-title">Preenchimento de Dados</div>
                            <div class="step-description">Inserindo informa√ß√µes do processo</div>
                            <div class="step-time"></div>
                        </div>
                    </div>

                    <div id="step-audiencia" class="step-item pending">
                        <div class="step-icon">
                            <i class="fas fa-gavel"></i>
                        </div>
                        <div class="step-content">
                            <div class="step-title">Cadastro de Primeira Audi√™ncia</div>
                            <div class="step-description">Registrando data e hora da audi√™ncia inicial</div>
                            <div class="step-time"></div>
                        </div>
                    </div>

                    <div id="step-screenshot-before" class="step-item pending">
                        <div class="step-icon">
                            <i class="fas fa-camera"></i>
                        </div>
                        <div class="step-content">
                            <div class="step-title">Captura de Tela (Antes)</div>
                            <div class="step-description">Registrando formul√°rio preenchido</div>
                            <div class="step-time"></div>
                        </div>
                    </div>

                    <div id="step-salvamento" class="step-item pending">
                        <div class="step-icon">
                            <i class="fas fa-save"></i>
                        </div>
                        <div class="step-content">
                            <div class="step-title">Salvamento</div>
                            <div class="step-description">Enviando dados ao eLaw</div>
                            <div class="step-time"></div>
                        </div>
                    </div>

                    <div id="step-screenshot-after" class="step-item pending">
                        <div class="step-icon">
                            <i class="fas fa-camera"></i>
                        </div>
                        <div class="step-content">
                            <div class="step-title">Captura de Tela (Depois)</div>
                            <div class="step-description">Verificando confirma√ß√£o de salvamento</div>
                            <div class="step-time"></div>
                        </div>
                    </div>

                    <div id="step-finalizacao" class="step-item pending">
                        <div class="step-icon">
                            <i class="fas fa-check-circle"></i>
                        </div>
                        <div class="step-content">
                            <div class="step-title">Finaliza√ß√£o</div>
                            <div class="step-description">Processo conclu√≠do com sucesso</div>
                            <div class="step-time"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Powered by Inova -->
        <div class="powered-by">
            <div class="powered-by-text">Powered by</div>
            <img src="{{ url_for('static', filename='images/inovailab-logo.png') }}" alt="InovaLab">
        </div>
    </div>

    <script>
        const processId = {{ process_id }};
        const pollInterval = 3000; // 3 segundos (otimizado para reduzir carga)
        const maxDuration = 600000; // 10 minutos timeout
        let startTime = Date.now();
        let currentProgress = 0;

        // Mapeamento de etapas do backend para IDs dos elementos
        const stepMapping = {
            // Login
            'abrindo_navegador': 'step-login',
            'login': 'step-login',
            'fazendo_login': 'step-login',
            'login_sucesso': 'step-login',
            
            // Navega√ß√£o
            'navegando': 'step-navegacao',
            'navegacao': 'step-navegacao',
            
            // Preenchimento
            'preenchendo_campos': 'step-preenchimento',
            'preenchendo_dados': 'step-preenchimento',
            'preenchendo_cnj': 'step-preenchimento',
            'cnj_preenchido': 'step-preenchimento',
            'localizacao_preenchida': 'step-preenchimento',
            'cliente_preenchido': 'step-preenchimento',
            'parte_adversa_preenchida': 'step-preenchimento',
            
            // Audi√™ncia
            'cadastrando_audiencia': 'step-audiencia',
            
            // Screenshot before
            'capturando_screenshot_before': 'step-screenshot-before',
            'screenshot_before_captured': 'step-screenshot-before',
            
            // Salvamento
            'salvando': 'step-salvamento',
            'salvando_processo': 'step-salvamento',
            'clicando_salvar': 'step-salvamento',
            'processo_salvo': 'step-salvamento',
            
            // Screenshot after
            'capturando_screenshot_after': 'step-screenshot-after',
            'screenshot_after_captured': 'step-screenshot-after',
            
            // Finaliza√ß√£o
            'voltando_dashboard': 'step-finalizacao',
            'dashboard_ok': 'step-finalizacao',
            'concluido': 'step-finalizacao',
            'completed': 'step-finalizacao',
            'finalizacao': 'step-finalizacao'
        };

        // Total de etapas para c√°lculo de progresso
        const totalSteps = 8;

        async function checkStatus() {
            try {
                const response = await fetch(`/api/rpa-status/${processId}`);
                const data = await response.json();

                console.log('Status RPA:', data);

                // Atualiza mensagem principal
                updateCurrentStatus(data);

                // Atualiza etapas baseado no hist√≥rico
                if (data.history && data.history.length > 0) {
                    updateSteps(data.history, data.current_step);
                }

                // Atualiza progresso
                updateProgress(data);

                // Verifica se terminou
                if (data.status === 'completed' || data.status === 'success') {
                    markStepCompleted('step-finalizacao');
                    updateProgressBar(100);
                    document.getElementById('current-status-message').innerHTML = 
                        '<i class="fas fa-check-circle me-2"></i>Processo conclu√≠do com sucesso!<br><small>Redirecionando...</small>';
                    setTimeout(() => {
                        window.location.href = '/processos';
                    }, 2500);
                    return;
                } else if (data.status === 'error') {
                    const currentStep = data.current_step || 'unknown';
                    const stepId = stepMapping[currentStep];
                    if (stepId) {
                        markStepError(stepId);
                    }
                    document.getElementById('current-status-message').innerHTML = 
                        `<i class="fas fa-exclamation-triangle me-2"></i>Erro: ${data.message || 'Erro desconhecido'}<br><a href="/processos" class="btn btn-sm btn-secondary mt-3">Voltar para lista</a>`;
                    return;
                }

                // Continua polling
                if (Date.now() - startTime < maxDuration) {
                    setTimeout(checkStatus, pollInterval);
                } else {
                    document.getElementById('current-status-message').innerHTML = 
                        '<i class="fas fa-clock me-2"></i>Timeout: O RPA est√° demorando mais do que o esperado.<br><a href="/processos" class="btn btn-sm btn-secondary mt-3">Voltar</a>';
                }
            } catch (error) {
                console.error('Erro ao verificar status:', error);
                setTimeout(checkStatus, pollInterval * 2);
            }
        }

        function updateCurrentStatus(data) {
            const statusMsg = document.getElementById('current-status-message');
            const message = data.message || data.current_step || 'Processando...';
            statusMsg.textContent = message;
        }

        function updateSteps(history, currentStep) {
            // Marca etapas completadas baseado no hist√≥rico
            const completedSteps = new Set();
            
            history.forEach(item => {
                const stepId = stepMapping[item.step];
                if (stepId) {
                    completedSteps.add(stepId);
                    markStepCompleted(stepId, item.timestamp);
                }
            });

            // Marca etapa atual como ativa
            if (currentStep) {
                const currentStepId = stepMapping[currentStep];
                if (currentStepId && !completedSteps.has(currentStepId)) {
                    markStepActive(currentStepId);
                }
            }
        }

        function updateProgress(data) {
            // Calcula progresso baseado nas etapas completadas
            let completedCount = 0;
            const allSteps = document.querySelectorAll('.step-item.completed');
            completedCount = allSteps.length;

            const progressPercent = Math.round((completedCount / totalSteps) * 100);
            updateProgressBar(progressPercent);
        }

        function updateProgressBar(percent) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-percentage');
            
            progressBar.style.width = percent + '%';
            progressText.textContent = percent + '%';
        }

        function markStepActive(stepId) {
            const step = document.getElementById(stepId);
            if (step) {
                // Remove active de todos
                document.querySelectorAll('.step-item.active').forEach(s => {
                    s.classList.remove('active');
                });
                
                step.classList.remove('pending', 'completed', 'error');
                step.classList.add('active');
            }
        }

        function markStepCompleted(stepId, timestamp = null) {
            const step = document.getElementById(stepId);
            if (step) {
                step.classList.remove('pending', 'active', 'error');
                step.classList.add('completed');
                
                if (timestamp) {
                    const timeEl = step.querySelector('.step-time');
                    if (timeEl) {
                        const time = new Date(timestamp).toLocaleTimeString('pt-BR');
                        timeEl.textContent = time;
                    }
                }
            }
        }

        function markStepError(stepId) {
            const step = document.getElementById(stepId);
            if (step) {
                step.classList.remove('pending', 'active', 'completed');
                step.classList.add('error');
            }
        }

        // Inicia polling
        checkStatus();
    </script>
</body>
</html>



================================================================================
FILE: requirements.txt
================================================================================
# === Core Web App (Flask) ===
Flask==3.0.3
Flask-Login==0.6.3
Flask-WTF==1.2.1
Flask-SQLAlchemy==3.1.1
Flask-Migrate==4.0.5
email-validator==2.2.0
python-dotenv==1.0.1

# === Database ===
psycopg2-binary==2.9.9

# === PDF Processing (lightweight) ===
PyPDF2==3.0.1

# === AI/LLM ===
openai>=1.35.0,<2.0.0
tiktoken==0.7.0

# === Text Processing ===
rapidfuzz==3.10.1
python-slugify>=8.0
lxml>=5.0

# === Documents ===
python-docx==1.1.2

# === HTTP ===
requests>=2.31

# === WebSockets ===
websockets>=12.0

# === Production Server ===
gunicorn==21.2.0
jinja2
playwright
sqlalchemy
urllib3
werkzeug
wtforms



================================================================================
FILE: pyproject.toml
================================================================================
[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Legal Process Management System with AI and RPA"
requires-python = ">=3.11"
dependencies = [
    "email-validator>=2.2.0",
    "flask>=3.1.2",
    "flask-login>=0.6.3",
    "flask-sqlalchemy>=3.1.1",
    "flask-wtf>=1.2.2",
    "gunicorn>=21.2.0",
    "openai>=1.35.0",
    "playwright>=1.48.0",
    "psycopg2-binary>=2.9.9",
    "pypdf2>=3.0.1",
    "python-dotenv>=1.0.1",
    "python-slugify>=8.0.4",
    "rapidfuzz>=3.10.1",
    "sqlalchemy>=2.0.35",
    "tiktoken>=0.7.0",
    "werkzeug>=3.0.3",
    "wtforms>=3.1.2",
]

